require('dotenv').config();
const path = require('path');
const fs = require('fs');
const { Client, GatewayIntentBits, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, SlashCommandBuilder, REST, Routes, ModalBuilder, TextInputBuilder, TextInputStyle, AttachmentBuilder, StringSelectMenuBuilder } = require('discord.js');
const connectDB = require('./database/connection');
const User = require('./models/User');
const { generateVerificationCode, sendVerificationEmail } = require('./services/emailService');
const { huntingAreas, DROP_ITEMS } = require('./data/huntingAreas');
const STOCK_MARKET = require('./data/stockMarket');
const RANDOM_EVENTS = require('./data/randomEvents');
const shopItems = require('./data/shopItems');
const MONSTER_BATTLE = require('./data/oddEvenGame');
const MUSHROOM_GAME = require('./data/mushroomGame');
const ARTIFACT_SYSTEM = require('./data/artifactSystem');
const EXERCISE_SYSTEM = require('./data/exerciseSystem');
const { QUEST_SYSTEM, checkQuestProgress } = require('./data/questSystem');
const BOSS_SYSTEM = require('./data/bossSystem');
const Jimp = require('jimp');

// ì•„ì´í…œ ê²½ë§¤ì¥ ì‹œìŠ¤í…œ
const AUCTION_HOUSE = {
    listings: new Map(),
    priceHistory: new Map(),
    marketVolume: new Map(),
    topItems: [],
    events: []
};

// í˜„ì¬ ì‹œì¥ ìƒí™© ì €ì¥ì†Œ
let currentMarketEvent = null;
let lastMarketUpdate = 0;

// ì˜¤í”ˆ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œìŠ¤í…œ
let openCountdown = {
    isActive: false,
    launchTime: null,
    channelId: null,
    messageId: null,
    interval: null
};

// ì¹´ìš´íŠ¸ë‹¤ìš´ ì²´í¬ í•¨ìˆ˜
function isCountdownActive() {
    if (!openCountdown.isActive) return false;
    return Date.now() < openCountdown.launchTime;
}

// ì¹´ìš´íŠ¸ë‹¤ìš´ ë©”ì‹œì§€ ë°˜í™˜
function getCountdownMessage() {
    if (!openCountdown.isActive) return null;
    
    const remaining = openCountdown.launchTime - Date.now();
    const days = Math.floor(remaining / (1000 * 60 * 60 * 24));
    const hours = Math.floor((remaining % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((remaining % (1000 * 60)) / 1000);
    
    const timeDisplay = days > 0 
        ? `${days}ì¼ ${hours}ì‹œê°„ ${minutes}ë¶„ ${seconds}ì´ˆ`
        : `${hours}ì‹œê°„ ${minutes}ë¶„ ${seconds}ì´ˆ`;
    
    return `ğŸš€ **ê¹€í—Œí„° RPG ì˜¤í”ˆ ì¤€ë¹„ì¤‘!**\n\n` +
           `â±ï¸ **ë‚¨ì€ ì‹œê°„:** \`${timeDisplay}\`\n` +
           `ğŸ“… **ì˜¤í”ˆ ì‹œê°„:** <t:${Math.floor(openCountdown.launchTime.getTime() / 1000)}:F>\n\n` +
           `ğŸ’¡ ì˜¤í”ˆ ì „ê¹Œì§€ ëª¨ë“  ê²Œì„ ê¸°ëŠ¥ì´ ì œí•œë©ë‹ˆë‹¤.`;
}

// ì¶•í•˜ ì´ë¯¸ì§€ ìƒì„±
async function createCelebrationImage() {
    try {
        const width = 800;
        const height = 400;
        
        // ìƒˆ ì´ë¯¸ì§€ ìƒì„±
        const image = new Jimp(width, height, 0x1a1a2eff);
        
        // í°íŠ¸ ë¡œë“œ
        const font64 = await Jimp.loadFont(Jimp.FONT_SANS_64_WHITE);
        const font32 = await Jimp.loadFont(Jimp.FONT_SANS_32_WHITE);
        const font16 = await Jimp.loadFont(Jimp.FONT_SANS_16_WHITE);
        
        // ë°°ê²½ ê·¸ë¼ë°ì´ì…˜ (ì¶•í•˜ ë¶„ìœ„ê¸°)
        for (let y = 0; y < height; y++) {
            const gradient = Math.floor(255 * (1 - y / height) * 0.5);
            const r = 30 + gradient;
            const g = 10 + Math.floor(gradient * 0.8);
            const b = 60 + Math.floor(gradient * 0.5);
            const color = Jimp.rgbaToInt(r, g, b, 255);
            for (let x = 0; x < width; x++) {
                image.setPixelColor(color, x, y);
            }
        }
        
        // ë°˜ì§ì´ëŠ” ë³„ íš¨ê³¼
        for (let i = 0; i < 50; i++) {
            const x = Math.floor(Math.random() * width);
            const y = Math.floor(Math.random() * height);
            const starColor = Jimp.rgbaToInt(255, 255, 255, 200 + Math.floor(Math.random() * 55));
            
            // ì‹­ì ëª¨ì–‘ ë³„
            for (let j = -2; j <= 2; j++) {
                if (x + j >= 0 && x + j < width) {
                    image.setPixelColor(starColor, x + j, y);
                }
                if (y + j >= 0 && y + j < height) {
                    image.setPixelColor(starColor, x, y + j);
                }
            }
        }
        
        // í™©ê¸ˆ í…Œë‘ë¦¬
        const borderColor = Jimp.rgbaToInt(255, 215, 0, 255);
        for (let i = 0; i < 8; i++) {
            // ìƒë‹¨
            for (let x = 0; x < width; x++) {
                image.setPixelColor(borderColor, x, i);
            }
            // í•˜ë‹¨
            for (let x = 0; x < width; x++) {
                image.setPixelColor(borderColor, x, height - 1 - i);
            }
            // ì¢Œì¸¡
            for (let y = 0; y < height; y++) {
                image.setPixelColor(borderColor, i, y);
            }
            // ìš°ì¸¡
            for (let y = 0; y < height; y++) {
                image.setPixelColor(borderColor, width - 1 - i, y);
            }
        }
        
        // ë©”ì¸ í…ìŠ¤íŠ¸
        const mainText = "OPEN!";
        const mainWidth = Jimp.measureText(font64, mainText);
        image.print(font64, (width - mainWidth) / 2, 120, mainText);
        
        // ë¶€ì œëª©
        const subtitle = "KIM HUNTER RPG GRAND OPENING!";
        const subWidth = Jimp.measureText(font32, subtitle);
        image.print(font32, (width - subWidth) / 2, 200, subtitle);
        
        // í•˜ë‹¨ ë©”ì‹œì§€
        const message = "All features are now available!";
        const msgWidth = Jimp.measureText(font16, message);
        image.print(font16, (width - msgWidth) / 2, 300, message);
        
        // ë²„í¼ë¡œ ë³€í™˜
        const buffer = await image.getBufferAsync(Jimp.MIME_PNG);
        return buffer;
        
    } catch (error) {
        console.error('ì¶•í•˜ ì´ë¯¸ì§€ ìƒì„± ì˜¤ë¥˜:', error);
        return null;
    }
}

// ì• ë‹ˆë©”ì´ì…˜ ì¹´ìš´íŠ¸ë‹¤ìš´ GIF ìƒì„± (ë§ˆì§€ë§‰ 30ì´ˆìš©)
async function createAnimatedCountdown(seconds) {
    try {
        const width = 400;
        const height = 200;
        const encoder = new GifEncoder(width, height);
        
        // GIF ìŠ¤íŠ¸ë¦¼ ì„¤ì •
        const chunks = [];
        encoder.createReadStream().on('data', chunk => chunks.push(chunk));
        
        encoder.start();
        encoder.setRepeat(0); // ë¬´í•œ ë°˜ë³µ
        encoder.setDelay(1000); // 1ì´ˆë§ˆë‹¤ í”„ë ˆì„
        encoder.setQuality(10);
        
        // ê° ì´ˆë§ˆë‹¤ í”„ë ˆì„ ìƒì„±
        for (let i = seconds; i >= 0; i--) {
            const frame = new Jimp(width, height, 0x000000ff);
            
            // í°íŠ¸ ë¡œë“œ
            const font64 = await Jimp.loadFont(Jimp.FONT_SANS_64_WHITE);
            const font32 = await Jimp.loadFont(Jimp.FONT_SANS_32_WHITE);
            
            // ë°°ê²½ ìƒ‰ìƒ (ì‹œê°„ì— ë”°ë¼ ë³€í™”)
            const bgColor = i > 10 ? 0xff6600ff : i > 5 ? 0xffff00ff : 0xff0000ff;
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    frame.setPixelColor(bgColor, x, y);
                }
            }
            
            // ì¹´ìš´íŠ¸ë‹¤ìš´ ìˆ«ì
            const text = String(i).padStart(2, '0');
            const textWidth = Jimp.measureText(font64, text);
            frame.print(font64, (width - textWidth) / 2, 60, text);
            
            // í•˜ë‹¨ í…ìŠ¤íŠ¸
            const bottomText = i === 0 ? "OPEN!" : "LAUNCHING...";
            const bottomWidth = Jimp.measureText(font32, bottomText);
            frame.print(font32, (width - bottomWidth) / 2, 130, bottomText);
            
            // í”„ë ˆì„ ì¶”ê°€
            const frameData = await frame.getBufferAsync(Jimp.MIME_PNG);
            const frameBitmap = await Jimp.read(frameData);
            encoder.addFrame(frameBitmap.bitmap.data);
        }
        
        encoder.finish();
        
        // Promiseë¡œ ì™„ë£Œ ëŒ€ê¸°
        return new Promise((resolve) => {
            encoder.createReadStream().on('end', () => {
                resolve(Buffer.concat(chunks));
            });
        });
        
    } catch (error) {
        console.error('ì• ë‹ˆë©”ì´ì…˜ ì¹´ìš´íŠ¸ë‹¤ìš´ ìƒì„± ì˜¤ë¥˜:', error);
        return null;
    }
}

// ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œê³„ ì´ë¯¸ì§€ ìƒì„±
async function createCountdownClock(remainingTime) {
    try {
        const width = 800;
        const height = 400;
        
        // ìƒˆ ì´ë¯¸ì§€ ìƒì„±
        const image = new Jimp(width, height, 0x1a1a2eff);
        
        // ë‚¨ì€ ì‹œê°„ ê³„ì‚°
        const days = Math.floor(remainingTime / (1000 * 60 * 60 * 24));
        const hours = Math.floor((remainingTime % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        const minutes = Math.floor((remainingTime % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((remainingTime % (1000 * 60)) / 1000);
        
        // í°íŠ¸ ë¡œë“œ
        const font64 = await Jimp.loadFont(Jimp.FONT_SANS_64_WHITE);
        const font32 = await Jimp.loadFont(Jimp.FONT_SANS_32_WHITE);
        const font16 = await Jimp.loadFont(Jimp.FONT_SANS_16_WHITE);
        
        // ë°°ê²½ ê·¸ë¼ë°ì´ì…˜ íš¨ê³¼
        for (let y = 0; y < height; y++) {
            const gradient = Math.floor(255 * (1 - y / height) * 0.3);
            const color = Jimp.rgbaToInt(26 + gradient, 26 + gradient, 46 + gradient, 255);
            for (let x = 0; x < width; x++) {
                image.setPixelColor(color, x, y);
            }
        }
        
        // í…Œë‘ë¦¬ ê·¸ë¦¬ê¸°
        const borderColor = Jimp.rgbaToInt(255, 215, 0, 255); // ê¸ˆìƒ‰
        for (let i = 0; i < 5; i++) {
            // ìƒë‹¨
            for (let x = 0; x < width; x++) {
                image.setPixelColor(borderColor, x, i);
            }
            // í•˜ë‹¨
            for (let x = 0; x < width; x++) {
                image.setPixelColor(borderColor, x, height - 1 - i);
            }
            // ì¢Œì¸¡
            for (let y = 0; y < height; y++) {
                image.setPixelColor(borderColor, i, y);
            }
            // ìš°ì¸¡
            for (let y = 0; y < height; y++) {
                image.setPixelColor(borderColor, width - 1 - i, y);
            }
        }
        
        // ì œëª©
        const title = "KIM HUNTER RPG COUNTDOWN";
        const titleWidth = Jimp.measureText(font32, title);
        image.print(font32, (width - titleWidth) / 2, 40, title);
        
        // ì‹œê³„ í‘œì‹œ
        let timeText = "";
        let yPosition = 150;
        
        if (days > 0) {
            // ì¼ìˆ˜ê°€ ìˆì„ ë•Œ
            timeText = `${String(days).padStart(2, '0')}D ${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        } else {
            // ì¼ìˆ˜ê°€ ì—†ì„ ë•Œ (ë” í° ê¸€ì”¨)
            timeText = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }
        
        // ë””ì§€í„¸ ì‹œê³„ íš¨ê³¼ë¥¼ ìœ„í•œ ë°°ê²½
        const clockBgColor = Jimp.rgbaToInt(0, 0, 0, 200);
        const clockX = 150;
        const clockY = yPosition - 10;
        const clockWidth = 500;
        const clockHeight = 100;
        
        for (let y = clockY; y < clockY + clockHeight; y++) {
            for (let x = clockX; x < clockX + clockWidth; x++) {
                image.setPixelColor(clockBgColor, x, y);
            }
        }
        
        // ì‹œê³„ í…Œë‘ë¦¬
        const clockBorderColor = Jimp.rgbaToInt(0, 255, 255, 255); // ì‹œì•ˆìƒ‰
        for (let i = 0; i < 2; i++) {
            // ìƒë‹¨
            for (let x = clockX; x < clockX + clockWidth; x++) {
                image.setPixelColor(clockBorderColor, x, clockY + i);
            }
            // í•˜ë‹¨
            for (let x = clockX; x < clockX + clockWidth; x++) {
                image.setPixelColor(clockBorderColor, x, clockY + clockHeight - 1 - i);
            }
            // ì¢Œì¸¡
            for (let y = clockY; y < clockY + clockHeight; y++) {
                image.setPixelColor(clockBorderColor, clockX + i, y);
            }
            // ìš°ì¸¡
            for (let y = clockY; y < clockY + clockHeight; y++) {
                image.setPixelColor(clockBorderColor, clockX + clockWidth - 1 - i, y);
            }
        }
        
        // ì‹œê°„ í…ìŠ¤íŠ¸
        const timeWidth = Jimp.measureText(font64, timeText);
        image.print(font64, (width - timeWidth) / 2, yPosition, timeText);
        
        // ì§„í–‰ë¥  ë°”
        const progressY = 300;
        const progressHeight = 30;
        const progressWidth = 600;
        const progressX = (width - progressWidth) / 2;
        
        // ì§„í–‰ë¥  ê³„ì‚°
        const totalTime = openCountdown.totalTime || (24 * 60 * 60 * 1000); // ê¸°ë³¸ê°’ 24ì‹œê°„
        const elapsed = totalTime - remainingTime;
        const progress = Math.max(0, Math.min(100, (elapsed / totalTime) * 100));
        
        // ì§„í–‰ë¥  ë°” ë°°ê²½
        const progressBgColor = Jimp.rgbaToInt(50, 50, 50, 255);
        for (let y = progressY; y < progressY + progressHeight; y++) {
            for (let x = progressX; x < progressX + progressWidth; x++) {
                image.setPixelColor(progressBgColor, x, y);
            }
        }
        
        // ì§„í–‰ë¥  ë°” ì±„ìš°ê¸°
        const filledWidth = Math.floor((progress / 100) * progressWidth);
        let progressColor;
        
        if (remainingTime < 60 * 60 * 1000) { // 1ì‹œê°„ ë¯¸ë§Œ
            progressColor = Jimp.rgbaToInt(255, 255, 0, 255); // ë…¸ë€ìƒ‰
        } else if (remainingTime < 6 * 60 * 60 * 1000) { // 6ì‹œê°„ ë¯¸ë§Œ
            progressColor = Jimp.rgbaToInt(255, 165, 0, 255); // ì£¼í™©ìƒ‰
        } else {
            progressColor = Jimp.rgbaToInt(0, 255, 0, 255); // ì´ˆë¡ìƒ‰
        }
        
        for (let y = progressY + 2; y < progressY + progressHeight - 2; y++) {
            for (let x = progressX + 2; x < progressX + filledWidth - 2; x++) {
                image.setPixelColor(progressColor, x, y);
            }
        }
        
        // ì§„í–‰ë¥  í…ìŠ¤íŠ¸
        const progressText = `${progress.toFixed(1)}%`;
        const progressTextWidth = Jimp.measureText(font16, progressText);
        image.print(font16, (width - progressTextWidth) / 2, progressY + progressHeight + 10, progressText);
        
        // í•˜ë‹¨ ë©”ì‹œì§€
        const bottomMessage = remainingTime < 60 * 60 * 1000 ? "OPENING SOON!" : "PLEASE WAIT FOR LAUNCH!";
        const bottomWidth = Jimp.measureText(font16, bottomMessage);
        image.print(font16, (width - bottomWidth) / 2, height - 40, bottomMessage);
        
        // ë²„í¼ë¡œ ë³€í™˜
        const buffer = await image.getBufferAsync(Jimp.MIME_PNG);
        return buffer;
        
    } catch (error) {
        console.error('ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œê³„ ì´ë¯¸ì§€ ìƒì„± ì˜¤ë¥˜:', error);
        return null;
    }
}

// ë³´ìŠ¤ ìŠ¤í° í•¨ìˆ˜
async function spawnBoss(channel) {
    // ëœë¤ ë³´ìŠ¤ ì„ íƒ
    const availableBosses = BOSS_SYSTEM.bosses.filter(boss => {
        // ë ˆë²¨ì— ë”°ë¼ ë³´ìŠ¤ í•„í„°ë§ (ì„ íƒì‚¬í•­)
        return true;
    });
    
    const boss = availableBosses[Math.floor(Math.random() * availableBosses.length)];
    
    // ë³´ìŠ¤ í™œì„±í™”
    BOSS_SYSTEM.activeBoss = {
        ...boss,
        currentHp: boss.hp,
        spawnTime: Date.now(),
        endTime: Date.now() + BOSS_SYSTEM.spawnSettings.duration,
        channelId: channel.id
    };
    
    BOSS_SYSTEM.participants.clear();
    BOSS_SYSTEM.damageDealt.clear();
    BOSS_SYSTEM.battleState.isActive = false;
    
    // ë³´ìŠ¤ ì¶œí˜„ ì•Œë¦¼
    const bossEmbed = new EmbedBuilder()
        .setColor('#ff0000')
        .setTitle('ğŸš¨ ë³´ìŠ¤ ì¶œí˜„ ì•Œë¦¼! ğŸš¨')
        .setDescription(`**${boss.emoji} ${boss.name}**ì´(ê°€) ë‚˜íƒ€ë‚¬ìŠµë‹ˆë‹¤!`)
        .addFields(
            { name: 'âš”ï¸ ë ˆë²¨', value: `${boss.level}`, inline: true },
            { name: 'â¤ï¸ HP', value: `${boss.hp.toLocaleString()}`, inline: true },
            { name: 'ğŸ¯ ìš”êµ¬ ë ˆë²¨', value: `${boss.requiredLevel}`, inline: true }
        )
        .setFooter({ text: '30ë¶„ í›„ ì‚¬ë¼ì§‘ë‹ˆë‹¤! ì„œë‘˜ëŸ¬ íŒŒí‹°ë¥¼ êµ¬ì„±í•˜ì„¸ìš”!' })
        .setTimestamp();
    
    const bossButtons = new ActionRowBuilder()
        .addComponents(
            new ButtonBuilder()
                .setCustomId('boss_challenge')
                .setLabel('ğŸ—¡ï¸ ë³´ìŠ¤ ë„ì „í•˜ê¸°')
                .setStyle(ButtonStyle.Danger),
            new ButtonBuilder()
                .setCustomId('boss_info')
                .setLabel('ğŸ“Š ë³´ìŠ¤ ì •ë³´')
                .setStyle(ButtonStyle.Secondary),
            new ButtonBuilder()
                .setCustomId('boss_participants')
                .setLabel('ğŸ‘¥ ì°¸ê°€ì ëª©ë¡')
                .setStyle(ButtonStyle.Primary)
        );
    
    await channel.send({
        content: '@everyone',
        embeds: [bossEmbed],
        components: [bossButtons]
    });
    
    // 30ë¶„ í›„ ë³´ìŠ¤ ì‚¬ë¼ì§
    setTimeout(async () => {
        if (BOSS_SYSTEM.activeBoss && !BOSS_SYSTEM.battleState.isActive) {
            BOSS_SYSTEM.activeBoss = null;
            await channel.send('â° ë³´ìŠ¤ê°€ ì‚¬ë¼ì¡ŒìŠµë‹ˆë‹¤... ë‹¤ìŒ ê¸°íšŒë¥¼ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”!');
        }
    }, BOSS_SYSTEM.spawnSettings.duration);
}

// ë³´ìŠ¤ ìŠ¤í° ìŠ¤ì¼€ì¤„ëŸ¬
function scheduleBossSpawn() {
    const interval = Math.random() * 
        (BOSS_SYSTEM.spawnSettings.maxInterval - BOSS_SYSTEM.spawnSettings.minInterval) + 
        BOSS_SYSTEM.spawnSettings.minInterval;
    
    setTimeout(async () => {
        // ë³´ìŠ¤ ì±„ë„ ì°¾ê¸° (ì„¤ì • í•„ìš”)
        const bossChannel = client.channels.cache.get(process.env.BOSS_CHANNEL_ID || '1380684353998426122');
        if (bossChannel && !BOSS_SYSTEM.activeBoss) {
            await spawnBoss(bossChannel);
        }
        scheduleBossSpawn(); // ë‹¤ìŒ ìŠ¤í° ì˜ˆì•½
    }, interval);
}

// ê²Œì„ ë©”ë‰´ í‘œì‹œ í•¨ìˆ˜
async function showGameMenu(interaction) {
    const gameCommand = client.application.commands.cache.find(cmd => cmd.name === 'ê²Œì„');
    if (!gameCommand) {
        await interaction.reply({ content: 'ê²Œì„ ëª…ë ¹ì–´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', flags: 64 });
        return;
    }
    
    // /ê²Œì„ ëª…ë ¹ì–´ ì‹¤í–‰
    await interaction.deferUpdate();
    await interaction.editReply({
        content: 'ê²Œì„ ë©”ë‰´ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤...',
        embeds: [],
        components: []
    });
    
    // ë©”ì¸ ë©”ë‰´ í‘œì‹œ
    const categoryEmbed = new EmbedBuilder()
        .setColor('#0099ff')
        .setTitle('ğŸ® ê¹€í—Œí„° RPG ê²Œì„')
        .setDescription('ì›í•˜ì‹œëŠ” ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”!')
        .setFooter({ text: 'ì•„ë˜ ë©”ë‰´ì—ì„œ ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•˜ì„¸ìš”' });
    
    const categoryOptions = Object.entries(MENU_CATEGORIES).map(([key, category]) => ({
        label: category.name,
        description: category.description,
        value: key,
        emoji: category.emoji
    }));
    
    const categoryMenu = new StringSelectMenuBuilder()
        .setCustomId('category_menu')
        .setPlaceholder('ğŸ“ ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•˜ì„¸ìš”')
        .addOptions(categoryOptions);
    
    const categoryRow = new ActionRowBuilder().addComponents(categoryMenu);
    
    await interaction.editReply({
        content: null,
        embeds: [categoryEmbed],
        components: [categoryRow]
    });
}

// ì—ë„ˆì§€ ìœµí•© ë©”ë‰´ í‘œì‹œ í•¨ìˆ˜
async function showEnergyFusionMenu(interaction) {
    const user = await getUser(interaction.user.id);
    if (!user || !user.registered) {
        await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
        return;
    }
    
    // ì—ë„ˆì§€ ì¡°ê° í˜„í™©
    const fragments = user.energyFragments?.fragments || new Map();
    let fragmentText = '';
    let totalFragments = 0;
    
    const sortedLevels = Array.from(fragments.keys()).sort((a, b) => a - b);
    
    if (sortedLevels.length === 0) {
        fragmentText = 'ë³´ìœ í•œ ì¡°ê°ì´ ì—†ìŠµë‹ˆë‹¤.\nì±„êµ´ì„ í†µí•´ ì¡°ê°ì„ íšë“í•˜ì„¸ìš”!';
    } else {
        sortedLevels.slice(0, 10).forEach(level => {
            const count = fragments.get(level);
            totalFragments += count;
            fragmentText += `Lv.${level}: ${count}ê°œ | `;
            if ((sortedLevels.indexOf(level) + 1) % 3 === 0) {
                fragmentText = fragmentText.slice(0, -3) + '\n';
            }
        });
        if (sortedLevels.length > 10) {
            fragmentText += `\n... ì™¸ ${sortedLevels.length - 10}ì¢…ë¥˜`;
        }
    }
    
    const fusionEmbed = new EmbedBuilder()
        .setColor('#ff00ff')
        .setTitle('âš¡ ì—ë„ˆì§€ ìœµí•© ì‹œìŠ¤í…œ')
        .setDescription('3ê°œì˜ ê°™ì€ ë ˆë²¨ ì¡°ê°ì„ ìœµí•©í•˜ì—¬ ë‹¤ìŒ ë ˆë²¨ ì¡°ê°ì„ ë§Œë“œì„¸ìš”!')
        .addFields(
            { name: 'ğŸ“Š ë³´ìœ  ì¡°ê°', value: fragmentText.trim() || 'ì—†ìŒ', inline: false },
            { name: 'ğŸ’ ì´ ì¡°ê°', value: `${totalFragments}ê°œ`, inline: true },
            { name: 'ğŸ¯ ìµœê³  ë ˆë²¨', value: `Lv.${user.energyFragments?.highestLevel || 0}`, inline: true },
            { name: 'ğŸ”„ ì¼ì¼ ìœµí•©', value: `${user.energyFragments?.dailyFusions || 0}/20íšŒ`, inline: true },
            { name: 'ğŸ“ˆ ì‹¤íŒ¨ ìŠ¤íƒ', value: `${user.energyFragments?.failureStack || 0}/10`, inline: true },
            { name: 'ğŸ« ìœµí•©ê¶Œ', value: `${user.energyFragments?.fusionTickets || 0}ê°œ`, inline: true }
        )
        .setFooter({ text: 'ì‹¤íŒ¨ ì‹œ ìŠ¤íƒì´ ìŒ“ì´ë©°, 10ìŠ¤íƒ ì‹œ 100% ì„±ê³µ!' });
    
    const fusionButtons = new ActionRowBuilder()
        .addComponents(
            new ButtonBuilder()
                .setCustomId('fragment_auto_fusion')
                .setLabel('ğŸ”„ ìë™ ìœµí•©')
                .setStyle(ButtonStyle.Success)
                .setDisabled(totalFragments < 3),
            new ButtonBuilder()
                .setCustomId('fragment_manual_fusion')
                .setLabel('ğŸ¯ ìˆ˜ë™ ìœµí•©')
                .setStyle(ButtonStyle.Primary)
                .setDisabled(totalFragments < 3),
            new ButtonBuilder()
                .setCustomId('fusion_info')
                .setLabel('ğŸ“– ìœµí•© ì •ë³´')
                .setStyle(ButtonStyle.Secondary),
            new ButtonBuilder()
                .setCustomId('fusion_back')
                .setLabel('ğŸ”™ ëŒì•„ê°€ê¸°')
                .setStyle(ButtonStyle.Secondary)
        );
    
    if (interaction.deferred || interaction.replied) {
        await interaction.editReply({ embeds: [fusionEmbed], components: [fusionButtons] });
    } else {
        await interaction.reply({ embeds: [fusionEmbed], components: [fusionButtons], flags: 64 });
    }
}


// í˜„ì¬ í™œì„± ì´ë²¤íŠ¸ë“¤
let dailyFortune = null;
let currentWeather = null;
let activeMissions = new Map();
let lastWeatherUpdate = 0;
let lastFortuneUpdate = 0;

// ë…ë²„ì„¯ ê²Œì„ ì„¸ì…˜ ê´€ë¦¬
const mushroomGameSessions = new Map();

// ë…ë²„ì„¯ ê²Œì„ ìƒì„± í•¨ìˆ˜ (ë¼ìš´ë“œë³„)
function generateMushroomGameRound(round) {
    const totalMushrooms = 6;
    const poisonCount = MUSHROOM_GAME.difficultyByRound[round].poisonCount;
    const mushrooms = [];
    
    // ë…ë²„ì„¯ ìœ„ì¹˜ ëœë¤ ìƒì„±
    const poisonPositions = new Set();
    while (poisonPositions.size < poisonCount) {
        poisonPositions.add(Math.floor(Math.random() * totalMushrooms));
    }
    
    // ë²„ì„¯ ë°°ì—´ ìƒì„±
    for (let i = 0; i < totalMushrooms; i++) {
        mushrooms.push({
            position: i,
            isPoisonous: poisonPositions.has(i),
            revealed: false,
            selectedBy: null
        });
    }
    
    return mushrooms;
}

// ë…ë²„ì„¯ ê²Œì„ ë²„íŠ¼ ìƒì„± í•¨ìˆ˜
function createMushroomGameButtons(gameId, mushrooms, currentPlayer) {
    const rows = [];
    const row1 = new ActionRowBuilder();
    const row2 = new ActionRowBuilder();
    
    // ëœë¤ ë²„ì„¯ íƒ€ì… ì„ íƒ
    const mushroomTypes = Object.keys(MUSHROOM_GAME.mushroomTypes);
    const selectedType = mushroomTypes[Math.floor(Math.random() * mushroomTypes.length)];
    const mushroomInfo = MUSHROOM_GAME.mushroomTypes[selectedType];
    
    // 6ê°œ ë²„ì„¯ì„ 2ì¤„ë¡œ ë°°ì¹˜
    mushrooms.forEach((mushroom, index) => {
        const button = new ButtonBuilder()
            .setCustomId(`mushroom_select_${gameId}_${index}`)
            .setStyle(mushroom.revealed ? 
                (mushroom.isPoisonous ? ButtonStyle.Danger : ButtonStyle.Success) : 
                ButtonStyle.Primary)
            .setDisabled(mushroom.revealed || currentPlayer !== 'player');
        
        // ë²„íŠ¼ ë¼ë²¨ ì„¤ì •
        if (mushroom.revealed) {
            button.setLabel(mushroom.isPoisonous ? 'â˜ ï¸' : 'âœ¨');
        } else {
            button.setLabel(`${mushroomInfo.emoji} ${index + 1}`);
        }
        
        if (index < 3) {
            row1.addComponents(button);
        } else {
            row2.addComponents(button);
        }
    });
    
    rows.push(row1, row2);
    return rows;
}

// ë´‡ ì„ íƒ ë¡œì§
function getBotChoice(bot, mushrooms, round) {
    const availablePositions = mushrooms
        .map((m, i) => ({ index: i, mushroom: m }))
        .filter(m => !m.mushroom.revealed)
        .map(m => m.index);
    
    if (availablePositions.length === 0) return -1;
    
    switch (bot.strategy) {
        case 'sequential':
            // ìˆœì°¨ì ìœ¼ë¡œ ì„ íƒ
            for (let i = 0; i < mushrooms.length; i++) {
                if (!mushrooms[i].revealed) return i;
            }
            break;
            
        case 'random':
            // ì™„ì „ ëœë¤
            return availablePositions[Math.floor(Math.random() * availablePositions.length)];
            
        case 'safe_guess':
            // í†µê³„ì ìœ¼ë¡œ ì•ˆì „í•œ ìœ„ì¹˜ ì„ íƒ (ì¤‘ê°„ ìœ„ì¹˜ ì„ í˜¸)
            const middlePositions = availablePositions.filter(p => p >= 2 && p <= 3);
            if (middlePositions.length > 0) {
                return middlePositions[Math.floor(Math.random() * middlePositions.length)];
            }
            return availablePositions[Math.floor(Math.random() * availablePositions.length)];
            
        case 'dangerous_guess':
            // ëª¨í—˜ì ì¸ ì„ íƒ (ê°€ì¥ìë¦¬ ì„ í˜¸)
            const edgePositions = availablePositions.filter(p => p === 0 || p === 5);
            if (edgePositions.length > 0) {
                return edgePositions[Math.floor(Math.random() * edgePositions.length)];
            }
            return availablePositions[Math.floor(Math.random() * availablePositions.length)];
            
        default:
            return availablePositions[0];
    }
}

// ë‹¤ìŒ ë¼ìš´ë“œ ì²˜ë¦¬ í•¨ìˆ˜
async function processNextRound(interaction, session, gameId) {
    session.round++;
    const roundReward = MUSHROOM_GAME.gameSettings.baseReward * (session.round - 1);
    session.earnings += roundReward;
    
    // 5ë¼ìš´ë“œ ì™„ë£Œ ì²´í¬
    if (session.round > MUSHROOM_GAME.gameSettings.maxRounds) {
        // ê²Œì„ ì™„ë£Œ
        const perfectReward = session.earnings + MUSHROOM_GAME.gameSettings.perfectBonus;
        const user = await getUser(session.userId);
        user.gold += perfectReward;
        await user.save();
        
        mushroomGameSessions.delete(gameId);
        
        const completeEmbed = new EmbedBuilder()
            .setColor('#ffd700')
            .setTitle('ğŸ† ê²Œì„ ì™„ë£Œ!')
            .setDescription('ëª¨ë“  ë¼ìš´ë“œë¥¼ í†µê³¼í–ˆìŠµë‹ˆë‹¤! ì™„ë²½í•œ ìŠ¹ë¦¬!')
            .addFields(
                { name: 'ğŸ’° ì´ ë³´ìƒ', value: `${session.earnings}G`, inline: true },
                { name: 'ğŸ ì™„ë²½ ë³´ë„ˆìŠ¤', value: `${MUSHROOM_GAME.gameSettings.perfectBonus}G`, inline: true },
                { name: 'ğŸ’ ì´ íšë“', value: `${perfectReward}G`, inline: true }
            )
            .setImage('attachment://kim_hunting_win.gif');
        
        const winGif = new AttachmentBuilder(path.join(__dirname, 'resource', MUSHROOM_GAME.effects.victory));
        
        await interaction.followUp({ 
            embeds: [completeEmbed],
            files: [winGif]
        });
        return;
    }
    
    // ë‹¤ìŒ ë¼ìš´ë“œ ì¤€ë¹„
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    // ìƒˆë¡œìš´ ë¼ìš´ë“œ ë²„ì„¯ ìƒì„±
    const difficulty = MUSHROOM_GAME.difficultyByRound[session.round];
    session.mushrooms = generateMushroomGameRound(session.round);
    session.currentTurn = 'player';
    
    const nextRoundEmbed = new EmbedBuilder()
        .setColor('#f39c12')
        .setTitle(`ğŸ„ ë¼ìš´ë“œ ${session.round}`)
        .setDescription(`${difficulty.message}\n\në¼ìš´ë“œ ë³´ìƒì´ ${roundReward}G ì¦ê°€í–ˆìŠµë‹ˆë‹¤!`)
        .addFields(
            { name: 'ğŸ’° ëˆ„ì  ë³´ìƒ', value: `${session.earnings}G`, inline: true },
            { name: 'ğŸ† í˜„ì¬ ë°°ìœ¨', value: `x${session.round}`, inline: true },
            { name: 'ğŸ¯ ë‚¨ì€ ë¼ìš´ë“œ', value: `${MUSHROOM_GAME.gameSettings.maxRounds - session.round + 1}`, inline: true }
        )
        .setImage('attachment://kim_hunting_main.png');
    
    const backgroundImage = new AttachmentBuilder(path.join(__dirname, 'resource', MUSHROOM_GAME.backgrounds.mushroomSelect));
    const mushroomButtons = createMushroomGameButtons(gameId, session.mushrooms, 'player');
    
    await interaction.followUp({ 
        embeds: [nextRoundEmbed], 
        components: mushroomButtons,
        files: [backgroundImage]
    });
}

// ë‹¤ìŒ ë¼ìš´ë“œ ì²˜ë¦¬ í•¨ìˆ˜
async function processNextRound(interaction, session, gameId) {
    const user = await getUser(session.userId);
    session.round++;
    
    // ë¼ìš´ë“œ ë³´ìƒ ì¶”ê°€
    const roundReward = MUSHROOM_GAME.gameSettings.baseReward + (MUSHROOM_GAME.gameSettings.survivalBonus * (session.round - 1));
    session.earnings += roundReward;
    
    if (session.round > MUSHROOM_GAME.gameSettings.maxRounds) {
        // ê²Œì„ ì™„ë£Œ
        const totalReward = session.earnings + MUSHROOM_GAME.gameSettings.perfectBonus;
        user.gold += totalReward;
        await user.save();
        
        mushroomGameSessions.delete(gameId);
        
        const completeEmbed = new EmbedBuilder()
            .setColor('#ffd700')
            .setTitle('ğŸ† ì™„ë²½í•œ ìŠ¹ë¦¬!')
            .setDescription(MUSHROOM_GAME.messages.perfectVictory)
            .addFields(
                { name: 'ğŸ’° ë¼ìš´ë“œ ë³´ìƒ', value: `${session.earnings}G`, inline: true },
                { name: 'ğŸ ì™„ë²½ ë³´ë„ˆìŠ¤', value: `${MUSHROOM_GAME.gameSettings.perfectBonus}G`, inline: true },
                { name: 'ğŸ’ ì´ íšë“', value: `${totalReward}G`, inline: true }
            )
            .setImage('attachment://kim_hunting_win.gif');
        
        const winGif = new AttachmentBuilder(path.join(__dirname, 'resource', MUSHROOM_GAME.effects.victory));
        
        await interaction.followUp({ 
            embeds: [completeEmbed], 
            files: [winGif]
        });
    } else {
        // ë‹¤ìŒ ë¼ìš´ë“œ ì‹œì‘
        session.mushrooms = generateMushroomGameRound(session.round);
        session.currentTurn = 'player';
        session.mushroomType = Object.keys(MUSHROOM_GAME.mushroomTypes)[Math.floor(Math.random() * Object.keys(MUSHROOM_GAME.mushroomTypes).length)];
        
        const mushroomInfo = MUSHROOM_GAME.mushroomTypes[session.mushroomType];
        const nextRoundEmbed = new EmbedBuilder()
            .setColor('#2ecc71')
            .setTitle(`ğŸ„ ${MUSHROOM_GAME.difficultyByRound[session.round].message}`)
            .setDescription(`ë¼ìš´ë“œ ${session.round - 1} í´ë¦¬ì–´!\n\n${mushroomInfo.name}ì´ ë‚˜íƒ€ë‚¬ìŠµë‹ˆë‹¤!`)
            .addFields(
                { name: 'ğŸ’° ë¼ìš´ë“œ ë³´ìƒ', value: `+${roundReward}G`, inline: true },
                { name: 'ğŸ’ ëˆ„ì  ë³´ìƒ', value: `${session.earnings}G`, inline: true },
                { name: 'ğŸ¯ í˜„ì¬ ë¼ìš´ë“œ', value: `${session.round}/5`, inline: true }
            )
            .setImage('attachment://kim_hunting2.gif');
        
        const nextGif = new AttachmentBuilder(path.join(__dirname, 'resource', MUSHROOM_GAME.effects.thinking));
        
        await interaction.followUp({ 
            embeds: [nextRoundEmbed], 
            files: [nextGif]
        });
        
        // 3ì´ˆ í›„ ë²„íŠ¼ í‘œì‹œ
        await new Promise(resolve => setTimeout(resolve, 3000));
        
        const buttons = createMushroomGameButtons(gameId, session.mushrooms, 'player');
        
        await interaction.followUp({ 
            content: 'ğŸ„ ë²„ì„¯ì„ ì„ íƒí•˜ì„¸ìš”!',
            components: buttons 
        });
    }
}

// ë“±ê¸‰ë³„ ì´ëª¨ì§€ ë°˜í™˜ í•¨ìˆ˜
function getRarityEmoji(rarity) {
    const rarityEmojis = {
        'ì¼ë°˜': 'âšª',
        'ê³ ê¸‰': 'ğŸŸ¢',
        'ë ˆì–´': 'ğŸ”µ',
        'ì—í”½': 'ğŸŸ£',
        'ë ˆì „ë“œë¦¬': 'ğŸŸ¡',
        'ìœ ë‹ˆí¬': 'ğŸ”´'
    };
    return rarityEmojis[rarity] || 'âšª';
}

// ë©”ë‰´ ì‹œìŠ¤í…œ ì •ì˜
const MENU_DEFINITIONS = {
    // ìºë¦­í„° ê´€ë¦¬ (Character Management)
    stats: {
        label: 'ğŸ’ª ëŠ¥ë ¥ì¹˜',
        description: 'ëŠ¥ë ¥ì¹˜ í™•ì¸ ë° ë¶„ë°°',
        emoji: 'ğŸ’ª',
        category: 'character'
    },
    skills: {
        label: 'ğŸ”® ìŠ¤í‚¬',
        description: 'ìŠ¤í‚¬ í™•ì¸ ë° ì—…ê·¸ë ˆì´ë“œ',
        emoji: 'ğŸ”®',
        category: 'character'
    },
    equipment: {
        label: 'âš”ï¸ ì¥ë¹„ê´€ë¦¬',
        description: 'ì¥ë¹„ ì°©ìš© ë° ê´€ë¦¬',
        emoji: 'âš”ï¸',
        category: 'character'
    },
    inventory: {
        label: 'ğŸ’ ì¸ë²¤í† ë¦¬',
        description: 'ë³´ìœ  ì•„ì´í…œ í™•ì¸',
        emoji: 'ğŸ’',
        category: 'character'
    },
    profile: {
        label: 'ğŸ‘¤ í”„ë¡œí•„',
        description: 'ë‚´ ì •ë³´ ë° í†µê³„ í™•ì¸',
        emoji: 'ğŸ‘¤',
        category: 'character'
    },
    emblem: {
        label: 'ğŸ† ì— ë¸”ëŸ¼',
        description: 'íŠ¹ë³„í•œ ì¹­í˜¸ íšë“ (ë ˆë²¨ 20 ì´ìƒ)',
        emoji: 'ğŸ†',
        category: 'character'
    },
    // ì¼ì¼ í™œë™ (Daily Activities)
    daily: {
        label: 'ğŸ ì¼ì¼ë³´ìƒ',
        description: 'ë§¤ì¼ ë°›ì„ ìˆ˜ ìˆëŠ” ë³´ìƒ',
        emoji: 'ğŸ',
        category: 'daily'
    },
    work: {
        label: 'ğŸƒ ìš´ë™í•˜ê¸°',
        description: 'ìš´ë™ìœ¼ë¡œ ìŠ¤íƒ¯ê³¼ ê³¨ë“œ íšë“',
        emoji: 'ğŸƒ',
        category: 'daily'
    },
    missions: {
        label: 'ğŸ“ ìˆ™ì œ',
        description: 'ì¼ì¼ ë¯¸ì…˜ ìˆ˜í–‰',
        emoji: 'ğŸ“',
        category: 'daily'
    },
    quest: {
        label: 'ğŸ“œ ì˜ë¢°',
        description: 'ëœë¤ í€˜ìŠ¤íŠ¸ ìˆ˜í–‰',
        emoji: 'ğŸ“œ',
        category: 'daily'
    },
    // ì „íˆ¬ ì½˜í…ì¸  (Battle Content)
    hunting: {
        label: 'ğŸ¯ ì‚¬ëƒ¥í•˜ê¸°',
        description: 'ëª¬ìŠ¤í„°ë¥¼ ì‚¬ëƒ¥í•˜ì—¬ ê²½í—˜ì¹˜ì™€ ê³¨ë“œ íšë“',
        emoji: 'ğŸ¯',
        category: 'battle'
    },
    pvp: {
        label: 'âš”ï¸ PVP',
        description: 'ë‹¤ë¥¸ í”Œë ˆì´ì–´ì™€ ê²°íˆ¬',
        emoji: 'âš”ï¸',
        category: 'battle'
    },
    ranking: {
        label: 'ğŸ† í†µí•© ë­í‚¹',
        description: 'ê°ì¢… ìˆœìœ„ í™•ì¸',
        emoji: 'ğŸ†',
        category: 'ranking'
    },
    // ë¯¸ë‹ˆê²Œì„ (Mini Games)
    racing: {
        label: 'ğŸ ë ˆì´ì‹±',
        description: 'ê²½ë§ˆ ë² íŒ… ê²Œì„',
        emoji: 'ğŸ',
        category: 'minigame'
    },
    mushroom: {
        label: 'ğŸ„ ë…ë²„ì„¯ê²Œì„',
        description: 'ë…ë²„ì„¯ì„ í”¼í•˜ëŠ” ê²Œì„',
        emoji: 'ğŸ„',
        category: 'minigame'
    },
    oddeven: {
        label: 'ğŸ² í™€ì§ê²Œì„',
        description: 'ëª¬ìŠ¤í„°ì™€ í™€ì§ ëŒ€ê²°',
        emoji: 'ğŸ²',
        category: 'minigame'
    },
    // ê²½ì œ (Economy)
    // shopì€ ë¹ ë¥¸ ì ‘ê·¼ ë²„íŠ¼ìœ¼ë¡œë§Œ ì œê³µ (ê²½ì œ ì¹´í…Œê³ ë¦¬ì—ì„œ ì œê±°)
    /*shop: {
        label: 'ğŸ›’ ìƒì ',
        description: 'ì•„ì´í…œ êµ¬ë§¤ ë° íŒë§¤',
        emoji: 'ğŸ›’',
        category: 'economy'
    },*/
    stocks: {
        label: 'ğŸ“ˆ ì£¼ì‹ê±°ë˜ì†Œ',
        description: 'í™˜ìƒ ì§€ì—­ ê¸°ì—… ì£¼ì‹ ê±°ë˜',
        emoji: 'ğŸ“ˆ',
        category: 'economy'
    },
    artifacts: {
        label: 'ğŸº ìœ ë¬¼íƒì‚¬',
        description: 'ê³ ëŒ€ ìœ ë¬¼ ë°œê²¬ ë° ê±°ë˜',
        emoji: 'ğŸº',
        category: 'economy'
    },
    auction: {
        label: 'ğŸ›ï¸ ê²½ë§¤ì¥',
        description: 'ì•„ì´í…œ ê²½ë§¤ ê±°ë˜',
        emoji: 'ğŸ›ï¸',
        category: 'economy'
    },
    // ê¸°íƒ€
    enhancement: {
        label: 'ğŸ’ ì¥ë¹„ê°•í™”',
        description: 'ì¥ë¹„ë¥¼ ê°•í™”í•˜ì—¬ ì „íˆ¬ë ¥ ìƒìŠ¹',
        emoji: 'ğŸ’',
        category: 'character'
    },
    fusion: {
        label: 'âš¡ ì¡°ê°ìœµí•©',
        description: 'ì—ë„ˆì§€ ì¡°ê°ì„ ìœµí•©í•˜ì—¬ ìƒìœ„ ì¡°ê° íšë“',
        emoji: 'âš¡',
        category: 'character'
    },
    settings: {
        label: 'âš™ï¸ ì„¤ì •',
        description: 'ë©”ë‰´ ì»¤ìŠ¤í„°ë§ˆì´ì§• ë° ì„¤ì •',
        emoji: 'âš™ï¸',
        category: 'utility'
    }
};

// RPG ìŠ¤íƒ€ì¼ ì¹´í…Œê³ ë¦¬ ì •ì˜
const MENU_CATEGORIES = {
    character: {
        name: 'ìºë¦­í„°',
        description: 'ìºë¦­í„° ì •ë³´ ë° ê´€ë¦¬',
        emoji: 'ğŸ‘¤',
        color: '#ff6b6b'
    },
    daily: {
        name: 'ì¼ì¼ í™œë™',
        description: 'ë§¤ì¼ í•  ìˆ˜ ìˆëŠ” í™œë™ë“¤',
        emoji: 'ğŸŒ…',
        color: '#ffeb3b'
    },
    battle: {
        name: 'ì „íˆ¬ ì½˜í…ì¸ ',
        description: 'ì „íˆ¬ ë° ê²½ìŸ ì½˜í…ì¸ ',
        emoji: 'âš”ï¸',
        color: '#e74c3c'
    },
    minigame: {
        name: 'ë¯¸ë‹ˆê²Œì„',
        description: 'ë‹¤ì–‘í•œ ë¯¸ë‹ˆê²Œì„ì„ ì¦ê²¨ë³´ì„¸ìš”',
        emoji: 'ğŸ®',
        color: '#3498db'
    },
    economy: {
        name: 'ê²½ì œ',
        description: 'ê³¨ë“œ ê´€ë ¨ ê±°ë˜ ì‹œìŠ¤í…œ',
        emoji: 'ğŸ’°',
        color: '#f39c12'
    },
    ranking: {
        name: 'ë­í‚¹',
        description: 'ë‹¤ì–‘í•œ ë¶„ì•¼ë³„ ìˆœìœ„',
        emoji: 'ğŸ†',
        color: '#9b59b6'
    }
};

// ê´€ë¦¬ì ì „ìš© ë©”ë‰´
const ADMIN_MENUS = {
    admin_panel: {
        label: 'ğŸ› ï¸ ê´€ë¦¬ì íŒ¨ë„',
        description: 'ì„œë²„ ê´€ë¦¬ ë° ì‹œìŠ¤í…œ ì œì–´',
        emoji: 'ğŸ› ï¸',
        category: 'admin'
    }
};

// ê´€ë¦¬ì ID ëª©ë¡ (í™˜ê²½ë³€ìˆ˜ì—ì„œ ì½ì–´ì˜¤ê±°ë‚˜ í•˜ë“œì½”ë”©)
const ADMIN_IDS = [
    '1036681976354160670', // ê¸°ë³¸ ê´€ë¦¬ì ID
    '424480594542592009'   // ì¶”ê°€ ê´€ë¦¬ì
];

// ë°ì´í„° ì €ì¥/ë¡œë“œ ì‹œìŠ¤í…œ
const DATA_FILE_PATH = path.join(__dirname, 'data', 'gameData.json');

// ê²Œì„ ë°ì´í„° ì €ì¥
function saveGameData() {
    try {
        const gameData = {
            auctionHouse: {
                listings: Object.fromEntries(AUCTION_HOUSE.listings),
                priceHistory: Object.fromEntries(AUCTION_HOUSE.priceHistory),
                marketVolume: Object.fromEntries(AUCTION_HOUSE.marketVolume),
                topItems: AUCTION_HOUSE.topItems,
                events: AUCTION_HOUSE.events
            },
            currentWeather: currentWeather,
            dailyFortune: dailyFortune,
            activeMissions: Object.fromEntries(activeMissions),
            lastWeatherUpdate: lastWeatherUpdate || 0,
            lastFortuneUpdate: lastFortuneUpdate || 0,
            lastMarketUpdate: lastMarketUpdate,
            currentMarketEvent: currentMarketEvent
        };
        
        fs.writeFileSync(DATA_FILE_PATH, JSON.stringify(gameData, null, 2));
        console.log('ê²Œì„ ë°ì´í„° ì €ì¥ ì™„ë£Œ');
    } catch (error) {
        console.error('ê²Œì„ ë°ì´í„° ì €ì¥ ì‹¤íŒ¨:', error);
    }
}

// ê²Œì„ ë°ì´í„° ë¡œë“œ
function loadGameData() {
    try {
        if (fs.existsSync(DATA_FILE_PATH)) {
            const data = JSON.parse(fs.readFileSync(DATA_FILE_PATH, 'utf8'));
            
            // ê²½ë§¤ì¥ ë°ì´í„° ë³µì›
            if (data.auctionHouse) {
                AUCTION_HOUSE.listings = new Map(Object.entries(data.auctionHouse.listings || {}));
                AUCTION_HOUSE.priceHistory = new Map(Object.entries(data.auctionHouse.priceHistory || {}));
                AUCTION_HOUSE.marketVolume = new Map(Object.entries(data.auctionHouse.marketVolume || {}));
                AUCTION_HOUSE.topItems = data.auctionHouse.topItems || [];
                AUCTION_HOUSE.events = data.auctionHouse.events || [];
            }
            
            // ë‚ ì”¨/ìš´ì„¸ ë°ì´í„° ë³µì›
            currentWeather = data.currentWeather;
            dailyFortune = data.dailyFortune;
            activeMissions = new Map(Object.entries(data.activeMissions || {}));
            lastMarketUpdate = data.lastMarketUpdate || 0;
            currentMarketEvent = data.currentMarketEvent;
            
            console.log('ê²Œì„ ë°ì´í„° ë¡œë“œ ì™„ë£Œ');
        } else {
            console.log('ê²Œì„ ë°ì´í„° íŒŒì¼ì´ ì—†ì–´ ê¸°ë³¸ê°’ìœ¼ë¡œ ì‹œì‘');
        }
    } catch (error) {
        console.error('ê²Œì„ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', error);
        console.log('ê¸°ë³¸ê°’ìœ¼ë¡œ ì´ˆê¸°í™”');
    }
}

// ì¸í„°ë²Œ ê´€ë¦¬ë¥¼ ìœ„í•œ ë°°ì—´
const intervals = [];

// ì£¼ê¸°ì  ë°ì´í„° ì €ì¥ (5ë¶„ë§ˆë‹¤)
intervals.push(setInterval(saveGameData, 5 * 60 * 1000));

// ë´‡ ì¢…ë£Œ ì‹œ ë°ì´í„° ì €ì¥ ë° ë¦¬ì†ŒìŠ¤ ì •ë¦¬
process.on('SIGINT', () => {
    console.log('ë´‡ ì¢…ë£Œ ì¤‘... ë°ì´í„° ì €ì¥ ë° ë¦¬ì†ŒìŠ¤ ì •ë¦¬');
    intervals.forEach(interval => clearInterval(interval));
    saveGameData();
    process.exit(0);
});

process.on('SIGTERM', () => {
    console.log('ë´‡ ì¢…ë£Œ ì¤‘... ë°ì´í„° ì €ì¥ ë° ë¦¬ì†ŒìŠ¤ ì •ë¦¬');
    intervals.forEach(interval => clearInterval(interval));
    saveGameData();
    process.exit(0);
});

// ìŠ¬ë¡¯ ì´ë¦„ í•œê¸€ ë³€í™˜ í•¨ìˆ˜
function getSlotDisplayName(slot) {
    const slotNames = {
        'weapon': 'ë¬´ê¸°',
        'armor': 'ê°‘ì˜·', 
        'helmet': 'í—¬ë©§',
        'gloves': 'ì¥ê°‘',
        'boots': 'ë¶€ì¸ ',
        'accessory': 'ì•¡ì„¸ì„œë¦¬'
    };
    return slotNames[slot] || slot;
}

// ê´€ë¦¬ì ê¶Œí•œ í™•ì¸ í•¨ìˆ˜
function isAdmin(userId) {
    return ADMIN_IDS.includes(userId);
}

// ì‚¬ìš©ìë³„ ì»¤ìŠ¤í„°ë§ˆì´ì§•ëœ ë©”ë‰´ ìƒì„±
// RPG ìŠ¤íƒ€ì¼ ì¹´í…Œê³ ë¦¬ ì„ íƒ ë©”ë‰´ ìƒì„±
function createCategoryMenu() {
    const categoryOptions = Object.entries(MENU_CATEGORIES).map(([key, category]) => ({
        label: `${category.emoji} ${category.name}`,
        description: category.description,
        value: `category_${key}`,
        emoji: category.emoji
    }));
    
    // ì „ì²´ ë©”ë‰´ ë³´ê¸° ì˜µì…˜ ì¶”ê°€
    categoryOptions.push({
        label: 'ğŸ“‹ ì „ì²´ ë©”ë‰´',
        description: 'ëª¨ë“  ë©”ë‰´ë¥¼ í•œë²ˆì— ë³´ê¸°',
        value: 'all_menus',
        emoji: 'ğŸ“‹'
    });
    
    return new StringSelectMenuBuilder()
        .setCustomId('category_menu')
        .setPlaceholder('ğŸ® ì›í•˜ëŠ” ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•˜ì„¸ìš”!')
        .addOptions(categoryOptions);
}

// ì¹´í…Œê³ ë¦¬ë³„ ë©”ë‰´ ìƒì„±
function createCategorySpecificMenu(category) {
    const menuOptions = [];
    const usedValues = new Set(); // ì¤‘ë³µ ë°©ì§€
    
    // í•´ë‹¹ ì¹´í…Œê³ ë¦¬ì˜ ë©”ë‰´ë“¤ë§Œ í•„í„°ë§
    for (const [menuId, menuDef] of Object.entries(MENU_DEFINITIONS)) {
        if (menuDef.category === category && !usedValues.has(menuId)) {
            usedValues.add(menuId);
            menuOptions.push({
                label: `${menuDef.emoji} ${menuDef.label}`,
                description: menuDef.description,
                value: menuId,
                emoji: menuDef.emoji
            });
        }
    }
    
    // ì¹´í…Œê³ ë¦¬ ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸° ì˜µì…˜
    menuOptions.push({
        label: 'ğŸ”™ ì¹´í…Œê³ ë¦¬ ì„ íƒìœ¼ë¡œ',
        description: 'ì¹´í…Œê³ ë¦¬ ì„ íƒ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°€ê¸°',
        value: 'back_to_categories',
        emoji: 'ğŸ”™'
    });
    
    const categoryInfo = MENU_CATEGORIES[category];
    return new StringSelectMenuBuilder()
        .setCustomId('main_menu')
        .setPlaceholder(`${categoryInfo.emoji} ${categoryInfo.name} ë©”ë‰´`)
        .addOptions(menuOptions);
}

async function createCustomizedMenu(userId) {
    try {
        const user = await User.findOne({ discordId: userId });
        const isUserAdmin = isAdmin(userId);
        
        // ê¸°ë³¸ ë©”ë‰´ ìˆœì„œ ë˜ëŠ” ì‚¬ìš©ì ì„¤ì •
        let menuOrder = user?.menuSettings?.menuOrder || [
            // ìºë¦­í„° ê´€ë¦¬
            'stats', 'skills', 'equipment', 'inventory', 'profile', 'emblem',
            // ì¼ì¼ í™œë™
            'daily', 'work', 'quest', 
            // ì „íˆ¬ ì½˜í…ì¸ 
            'hunting', 'pvp', 'ranking',
            // ë¯¸ë‹ˆê²Œì„
            'racing', 'mushroom', 'oddeven',
            // ê²½ì œ
            'shop', 'stocks', 'artifacts', 'auction',
            // ê¸°íƒ€
            'enhancement', 'fusion'
        ];
        const hiddenMenus = user?.menuSettings?.hiddenMenus || [];
        const favoriteMenus = user?.menuSettings?.favoriteMenus || [];
        
        // ìˆ¨ê²¨ì§„ ë©”ë‰´ ì œì™¸
        menuOrder = menuOrder.filter(menuId => !hiddenMenus.includes(menuId));
        
        // ì¦ê²¨ì°¾ê¸° ë©”ë‰´ë¥¼ ë§¨ ì•ìœ¼ë¡œ
        const nonFavorites = menuOrder.filter(menuId => !favoriteMenus.includes(menuId));
        const orderedFavorites = favoriteMenus.filter(menuId => menuOrder.includes(menuId));
        menuOrder = [...orderedFavorites, ...nonFavorites];
        
        // ì¤‘ë³µ ì œê±°
        menuOrder = [...new Set(menuOrder)];
        
        // ë©”ë‰´ ì˜µì…˜ ìƒì„±
        const menuOptions = [];
        const usedValues = new Set(); // ì‚¬ìš©ëœ ê°’ ì¶”ì 
        
        for (const menuId of menuOrder) {
            const menuDef = MENU_DEFINITIONS[menuId];
            if (menuDef && !usedValues.has(menuId)) {
                usedValues.add(menuId);
                const isFavorite = favoriteMenus.includes(menuId);
                menuOptions.push({
                    label: `${isFavorite ? 'â­ ' : ''}${menuDef.label}`,
                    description: menuDef.description,
                    value: menuId,
                    emoji: menuDef.emoji
                });
            }
        }
        
        // ê´€ë¦¬ìë¼ë©´ ê´€ë¦¬ì ë©”ë‰´ ì¶”ê°€
        if (isUserAdmin && !usedValues.has('admin_panel')) {
            usedValues.add('admin_panel');
            menuOptions.push({
                label: 'ğŸ› ï¸ ê´€ë¦¬ì íŒ¨ë„',
                description: 'ì„œë²„ ê´€ë¦¬ ë° ì‹œìŠ¤í…œ ì œì–´',
                value: 'admin_panel',
                emoji: 'ğŸ› ï¸'
            });
        }
        
        // ì„¤ì • ë©”ë‰´ëŠ” í•­ìƒ ë§ˆì§€ë§‰ì—
        if (!hiddenMenus.includes('settings') && !usedValues.has('settings')) {
            usedValues.add('settings');
            menuOptions.push({
                label: 'âš™ï¸ ì„¤ì •',
                description: 'ë©”ë‰´ ì»¤ìŠ¤í„°ë§ˆì´ì§• ë° ì„¤ì •',
                value: 'settings',
                emoji: 'âš™ï¸'
            });
        }
        
        return new StringSelectMenuBuilder()
            .setCustomId('main_menu')
            .setPlaceholder('âœ¨ ê¹€í—Œí„° ì›”ë“œì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!')
            .addOptions(menuOptions.slice(0, 25)); // Discord ì œí•œ: ìµœëŒ€ 25ê°œ
            
    } catch (error) {
        console.error('ë©”ë‰´ ìƒì„± ì˜¤ë¥˜:', error);
        // ê¸°ë³¸ ë©”ë‰´ ë°˜í™˜
        return createDefaultMenu();
    }
}

// ê¸°ë³¸ ë©”ë‰´ ìƒì„±
function createDefaultMenu() {
    const defaultOptions = [
        {
            label: 'ğŸ¯ ì‚¬ëƒ¥í•˜ê¸°',
            description: 'ëª¬ìŠ¤í„°ë¥¼ ì‚¬ëƒ¥í•˜ì—¬ ê²½í—˜ì¹˜ì™€ ê³¨ë“œ íšë“',
            value: 'hunting',
            emoji: 'ğŸ¯'
        },
        {
            label: 'âš”ï¸ ì¥ë¹„ê´€ë¦¬',
            description: 'ì¥ë¹„ ì°©ìš©, ê°•í™” ë° ê´€ë¦¬',
            value: 'equipment',
            emoji: 'âš”ï¸'
        },
        {
            label: 'ğŸ›’ ìƒì ',
            description: 'ì•„ì´í…œ êµ¬ë§¤ ë° íŒë§¤',
            value: 'shop',
            emoji: 'ğŸ›’'
        },
        {
            label: 'ğŸ“ˆ ì£¼ì‹ê±°ë˜ì†Œ',
            description: 'í™˜ìƒ ì§€ì—­ ê¸°ì—… ì£¼ì‹ ê±°ë˜',
            value: 'stocks',
            emoji: 'ğŸ“ˆ'
        }
    ];
    
    return new StringSelectMenuBuilder()
        .setCustomId('main_menu')
        .setPlaceholder('âœ¨ ê¹€í—Œí„° ì›”ë“œì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!')
        .addOptions(defaultOptions);
}

// ë©”ë‰´ ì»¤ìŠ¤í„°ë§ˆì´ì§• ë“œë¡­ë‹¤ìš´ ìƒì„±
function createMenuCustomizer() {
    return new StringSelectMenuBuilder()
        .setCustomId('customize_menu')
        .setPlaceholder('ğŸ¨ ì›í•˜ëŠ” ì„¤ì •ì„ ì„ íƒí•˜ì„¸ìš”')
        .addOptions([
            {
                label: 'â­ ì¦ê²¨ì°¾ê¸° ê´€ë¦¬',
                description: 'ìì£¼ ì‚¬ìš©í•˜ëŠ” ë©”ë‰´ë¥¼ ì¦ê²¨ì°¾ê¸°ì— ì¶”ê°€/ì œê±°',
                value: 'manage_favorites',
                emoji: 'â­'
            },
            {
                label: 'ğŸ¯ í€µìŠ¬ë¡¯ ì„¤ì •',
                description: 'ë¹ ë¥¸ ì ‘ê·¼ì„ ìœ„í•œ í€µìŠ¬ë¡¯ ë²„íŠ¼ ì„¤ì •',
                value: 'manage_quickslots',
                emoji: 'ğŸ¯'
            },
            {
                label: 'ğŸ¨ í…Œë§ˆ ì„¤ì •',
                description: 'ì¸í„°í˜ì´ìŠ¤ ìƒ‰ìƒ í…Œë§ˆ ë³€ê²½',
                value: 'change_theme',
                emoji: 'ğŸ¨'
            },
            {
                label: 'ğŸ“Š UI ë ˆì´ì•„ì›ƒ',
                description: 'ë©”ë‰´ í‘œì‹œ ë°©ì‹ ì„¤ì • (ëª©ë¡/ê·¸ë¦¬ë“œ)',
                value: 'change_layout',
                emoji: 'ğŸ“Š'
            },
            {
                label: 'ğŸ”” ì•Œë¦¼ ì„¤ì •',
                description: 'ê²Œì„ ì•Œë¦¼ ì„¤ì • ê´€ë¦¬',
                value: 'notification_settings',
                emoji: 'ğŸ””'
            },
            {
                label: 'â™»ï¸ ì„¤ì • ì´ˆê¸°í™”',
                description: 'ëª¨ë“  ì„¤ì •ì„ ê¸°ë³¸ê°’ìœ¼ë¡œ ì´ˆê¸°í™”',
                value: 'reset_settings',
                emoji: 'â™»ï¸'
            }
        ]);
}

// ê´€ë¦¬ì íŒ¨ë„ ë©”ë‰´ ìƒì„±
function createAdminPanel() {
    return new StringSelectMenuBuilder()
        .setCustomId('admin_panel')
        .setPlaceholder('ğŸ› ï¸ ê´€ë¦¬ì íŒ¨ë„ - ì‹ ì¤‘í•˜ê²Œ ì‚¬ìš©í•˜ì„¸ìš”')
        .addOptions([
            {
                label: 'ğŸ‘¥ ì‚¬ìš©ì ê´€ë¦¬',
                description: 'ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ ë° ìˆ˜ì •',
                value: 'admin_users',
                emoji: 'ğŸ‘¥'
            },
            {
                label: 'ğŸ’° ê²½ì œ ê´€ë¦¬',
                description: 'ê³¨ë“œ, ì•„ì´í…œ ì§€ê¸‰ ë° ì‹œì¥ ì¡°ì‘',
                value: 'admin_economy',
                emoji: 'ğŸ’°'
            },
            {
                label: 'ğŸ“Š ì„œë²„ í†µê³„',
                description: 'ì„œë²„ ì‚¬ìš© í†µê³„ ë° ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§',
                value: 'admin_stats',
                emoji: 'ğŸ“Š'
            },
            {
                label: 'ğŸ® ê²Œì„ ì‹œìŠ¤í…œ',
                description: 'ê²Œì„ ë°¸ëŸ°ìŠ¤ ë° ì´ë²¤íŠ¸ ê´€ë¦¬',
                value: 'admin_game',
                emoji: 'ğŸ®'
            },
            {
                label: 'ğŸ“ˆ ì£¼ì‹ ì‹œì¥ ê´€ë¦¬',
                description: 'ì£¼ì‹ ê°€ê²© ì¡°ì‘ ë° ì‹œì¥ ì´ë²¤íŠ¸',
                value: 'admin_stocks',
                emoji: 'ğŸ“ˆ'
            },
            {
                label: 'ğŸ—„ï¸ ë°ì´í„°ë² ì´ìŠ¤',
                description: 'ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—… ë° ì •ë¦¬',
                value: 'admin_database',
                emoji: 'ğŸ—„ï¸'
            },
            {
                label: 'ğŸ”§ ì‹œìŠ¤í…œ ì œì–´',
                description: 'ë´‡ ì¬ì‹œì‘, ê³µì§€ì‚¬í•­ ë“±',
                value: 'admin_system',
                emoji: 'ğŸ”§'
            },
            {
                label: 'ğŸš¨ ê¸´ê¸‰ ìƒí™©',
                description: 'ê¸´ê¸‰ ìƒí™© ëŒ€ì‘ ë„êµ¬',
                value: 'admin_emergency',
                emoji: 'ğŸš¨'
            }
        ]);
}

// ì‚¬ìš©ì ê´€ë¦¬ ë©”ë‰´
function createUserManagementMenu() {
    return new StringSelectMenuBuilder()
        .setCustomId('admin_user_management')
        .setPlaceholder('ğŸ‘¥ ì‚¬ìš©ì ê´€ë¦¬')
        .addOptions([
            {
                label: 'ğŸ” ì‚¬ìš©ì ê²€ìƒ‰',
                description: 'íŠ¹ì • ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ',
                value: 'search_user',
                emoji: 'ğŸ”'
            },
            {
                label: 'ğŸ’ ê³¨ë“œ ì§€ê¸‰/ì°¨ê°',
                description: 'ì‚¬ìš©ìì—ê²Œ ê³¨ë“œ ì§€ê¸‰ ë˜ëŠ” ì°¨ê°',
                value: 'modify_gold',
                emoji: 'ğŸ’'
            },
            {
                label: 'ğŸ’ ì•„ì´í…œ ì§€ê¸‰',
                description: 'ì‚¬ìš©ìì—ê²Œ ì•„ì´í…œ ì§€ê¸‰',
                value: 'give_item',
                emoji: 'ğŸ’'
            },
            {
                label: 'ğŸ“Š ë ˆë²¨/ê²½í—˜ì¹˜ ìˆ˜ì •',
                description: 'ì‚¬ìš©ì ë ˆë²¨ ë° ê²½í—˜ì¹˜ ì¡°ì •',
                value: 'modify_level',
                emoji: 'ğŸ“Š'
            },
            {
                label: 'ğŸ”’ ê³„ì • ê´€ë¦¬',
                description: 'ê³„ì • ì°¨ë‹¨/í•´ì œ ë“±',
                value: 'account_management',
                emoji: 'ğŸ”’'
            },
            {
                label: 'ğŸ“ˆ ì‚¬ìš©ì í†µê³„',
                description: 'ì „ì²´ ì‚¬ìš©ì í†µê³„ ì¡°íšŒ',
                value: 'user_statistics',
                emoji: 'ğŸ“ˆ'
            }
        ]);
}

// ê²½ì œ ê´€ë¦¬ ë©”ë‰´
function createEconomyManagementMenu() {
    return new StringSelectMenuBuilder()
        .setCustomId('admin_economy_management')
        .setPlaceholder('ğŸ’° ê²½ì œ ê´€ë¦¬')
        .addOptions([
            {
                label: 'ğŸ“ˆ ì£¼ì‹ ê°€ê²© ì¡°ì‘',
                description: 'íŠ¹ì • ì£¼ì‹ì˜ ê°€ê²© ì§ì ‘ ì¡°ì •',
                value: 'manipulate_stocks',
                emoji: 'ğŸ“ˆ'
            },
            {
                label: 'ğŸº ìœ ë¬¼ ì‹œì¥ ì¡°ì‘',
                description: 'ìœ ë¬¼ ì‹œì¥ ê°€ì¹˜ ì¡°ì •',
                value: 'manipulate_artifacts',
                emoji: 'ğŸº'
            },
            {
                label: 'ğŸ›’ ìƒì  ê´€ë¦¬',
                description: 'ìƒì  ì•„ì´í…œ ë° ê°€ê²© ê´€ë¦¬',
                value: 'manage_shop',
                emoji: 'ğŸ›’'
            },
            {
                label: 'ğŸ ì „ì²´ ê³¨ë“œ ì§€ê¸‰',
                description: 'ëª¨ë“  ì‚¬ìš©ìì—ê²Œ ê³¨ë“œ ì§€ê¸‰',
                value: 'global_gold_distribution',
                emoji: 'ğŸ'
            },
            {
                label: 'ğŸ“Š ê²½ì œ í†µê³„',
                description: 'ì „ì²´ ê²½ì œ ìƒí™© ë¶„ì„',
                value: 'economy_statistics',
                emoji: 'ğŸ“Š'
            },
            {
                label: 'âš–ï¸ ì¸í”Œë ˆì´ì…˜ ì œì–´',
                description: 'ê²½ì œ ë°¸ëŸ°ìŠ¤ ì¡°ì • ë„êµ¬',
                value: 'inflation_control',
                emoji: 'âš–ï¸'
            }
        ]);
}

// ì‹œìŠ¤í…œ ì œì–´ ë©”ë‰´
function createSystemControlMenu() {
    return new StringSelectMenuBuilder()
        .setCustomId('admin_system_control')
        .setPlaceholder('ğŸ”§ ì‹œìŠ¤í…œ ì œì–´')
        .addOptions([
            {
                label: 'ğŸ“¢ ê³µì§€ì‚¬í•­ ë°œì†¡',
                description: 'ì „ì²´ ì„œë²„ì— ê³µì§€ì‚¬í•­ ë°œì†¡',
                value: 'send_announcement',
                emoji: 'ğŸ“¢'
            },
            {
                label: 'ğŸ”„ ë´‡ ì¬ì‹œì‘',
                description: 'ë´‡ì„ ì•ˆì „í•˜ê²Œ ì¬ì‹œì‘',
                value: 'restart_bot',
                emoji: 'ğŸ”„'
            },
            {
                label: 'ğŸ’¾ ë°ì´í„° ì €ì¥',
                description: 'í˜„ì¬ ê²Œì„ ë°ì´í„° ê°•ì œ ì €ì¥',
                value: 'force_save',
                emoji: 'ğŸ’¾'
            },
            {
                label: 'ğŸ§¹ ìºì‹œ ì •ë¦¬',
                description: 'ë©”ëª¨ë¦¬ ìºì‹œ ì •ë¦¬',
                value: 'clear_cache',
                emoji: 'ğŸ§¹'
            },
            {
                label: 'ğŸ“Š ì‹œìŠ¤í…œ ìƒíƒœ',
                description: 'ì„œë²„ ë° ë´‡ ìƒíƒœ í™•ì¸',
                value: 'system_status',
                emoji: 'ğŸ“Š'
            },
            {
                label: 'ğŸª ì´ë²¤íŠ¸ ìƒì„±',
                description: 'íŠ¹ë³„ ì´ë²¤íŠ¸ ìƒì„± ë° ê´€ë¦¬',
                value: 'create_event',
                emoji: 'ğŸª'
            }
        ]);
}

const GifEncoder = require('gif-encoder-2');


// ìƒì  ì¹´í…Œê³ ë¦¬ ë°ì´í„° ì •ì˜ (ì „ì—­ìœ¼ë¡œ ì‚¬ìš©)
const SHOP_CATEGORIES = {
    weapon: {
        name: 'ë¬´ê¸°',
        emoji: 'âš”ï¸',
        gif: 'kim_shop_weapon.png',
        items: [
            // ğŸŒ¸ ì¼ë°˜ ë“±ê¸‰ - ê½ƒì ì„¸íŠ¸
            { 
                id: 'petal_sword',
                name: 'ê½ƒì ì¹¼', 
                rarity: 'ì¼ë°˜', 
                price: 500, 
                type: 'weapon',
                setName: 'ê½ƒì ì„¸íŠ¸',
                level: 1,
                description: 'ê½ƒì˜ í˜ì´ ê¹ƒë“  ê¸°ë³¸ ë¬´ê¸°ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [15, 25], 
                    defense: [5, 10], 
                    dodge: [0, 0], 
                    luck: [0, 0] 
                }
            },
            { 
                id: 'bouquet_axe',
                name: 'ê½ƒë‹¤ë°œ ë„ë¼', 
                rarity: 'ì¼ë°˜', 
                price: 600, 
                type: 'weapon',
                setName: 'ê½ƒì ì„¸íŠ¸',
                level: 1,
                description: 'ê½ƒë‹¤ë°œì²˜ëŸ¼ ì•„ë¦„ë‹µì§€ë§Œ ê°•ë ¥í•œ ë„ë¼ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [25, 35], 
                    defense: [3, 8], 
                    dodge: [-2, -2], 
                    luck: [0, 0] 
                }
            },
            { 
                id: 'fragrance_bow',
                name: 'ê½ƒí–¥ê¸° í™œ', 
                rarity: 'ì¼ë°˜', 
                price: 550, 
                type: 'weapon',
                setName: 'ê½ƒì ì„¸íŠ¸',
                level: 1,
                description: 'ê½ƒí–¥ê¸°ê°€ í¼ì§€ë©° í–‰ìš´ì„ ë¶€ë¥´ëŠ” í™œì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [18, 28], 
                    defense: [0, 0], 
                    dodge: [0, 0], 
                    luck: [5, 10] 
                }
            },
            // â­ ê³ ê¸‰ ë“±ê¸‰ - ë³„ë¹› ì„¸íŠ¸
            { 
                name: 'ë³„ë¹› ì¹¼', 
                rarity: 'ê³ ê¸‰', 
                price: 2500, 
                type: 'weapon',
                setName: 'ë³„ë¹› ì„¸íŠ¸',
                level: 20,
                description: 'ë³„ì˜ í˜ì´ ê¹ƒë“  ë¬´ê¸°ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [50, 70], 
                    defense: [15, 25], 
                    dodge: [3, 3], 
                    luck: [0, 0] 
                }
            },
            { 
                name: 'ìœ ì„± ë„ë¼', 
                rarity: 'ê³ ê¸‰', 
                price: 2800, 
                type: 'weapon',
                setName: 'ë³„ë¹› ì„¸íŠ¸',
                level: 20,
                description: 'ìœ ì„±ì˜ íŒŒê´´ë ¥ì´ ë‹´ê¸´ ê°•ë ¥í•œ ë„ë¼ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [70, 95], 
                    defense: [10, 20], 
                    dodge: [-3, -3], 
                    luck: [5, 5] 
                }
            },
            { 
                name: 'ì€í•˜ í™œ', 
                rarity: 'ê³ ê¸‰', 
                price: 2600, 
                type: 'weapon',
                setName: 'ë³„ë¹› ì„¸íŠ¸',
                level: 20,
                description: 'ì€í•˜ì˜ ì‹ ë¹„ë¡œìš´ í˜ì„ ë‹´ì€ í™œì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [55, 75], 
                    defense: [0, 0], 
                    dodge: [8, 8], 
                    luck: [12, 20] 
                }
            },
            // ğŸ”¥ ë ˆì–´ ë“±ê¸‰ - ë“œë˜ê³¤ ì„¸íŠ¸
            { 
                name: 'ë“œë˜ê³¤ í‚¬ëŸ¬', 
                rarity: 'ë ˆì–´', 
                price: 12000, 
                type: 'weapon',
                setName: 'ë“œë˜ê³¤ ì„¸íŠ¸',
                level: 40,
                description: 'ìš©ì„ ì²˜ì¹˜í•  ìˆ˜ ìˆëŠ” ê°•ë ¥í•œ ë¬´ê¸°ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [120, 180], 
                    defense: [40, 60], 
                    dodge: [0, 0], 
                    luck: [8, 8] 
                }
            },
            { 
                name: 'ìš©ì˜ ë¶„ë…¸ ë„ë¼', 
                rarity: 'ë ˆì–´', 
                price: 15000, 
                type: 'weapon',
                setName: 'ë“œë˜ê³¤ ì„¸íŠ¸',
                level: 40,
                description: 'ë“œë˜ê³¤ì˜ ë¶„ë…¸ê°€ ë‹´ê¸´ íŒŒê´´ì ì¸ ë„ë¼ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [180, 250], 
                    defense: [25, 45], 
                    dodge: [-5, -5], 
                    luck: [10, 10] 
                }
            },
            { 
                name: 'ë“œë˜ê³¤ë¸Œë ˆìŠ¤ í™œ', 
                rarity: 'ë ˆì–´', 
                price: 13000, 
                type: 'weapon',
                setName: 'ë“œë˜ê³¤ ì„¸íŠ¸',
                level: 40,
                description: 'ë“œë˜ê³¤ì˜ ë¸Œë ˆìŠ¤ë¥¼ ì‚¬ìš©í•˜ëŠ” ì‹ ë¹„í•œ í™œì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [140, 200], 
                    defense: [0, 0], 
                    dodge: [15, 15], 
                    luck: [20, 35] 
                }
            },
            // ğŸŒ™ ì—í”½ ë“±ê¸‰ - ì‹œê³µ ì„¸íŠ¸
            { 
                name: 'ì‹œê°„ì˜ ì¹¼', 
                rarity: 'ì—í”½', 
                price: 50000, 
                type: 'weapon',
                setName: 'ì‹œê³µ ì„¸íŠ¸',
                level: 60,
                description: 'ì‹œê°„ì„ ì¡°ì‘í•  ìˆ˜ ìˆëŠ” ì‹ ë¹„í•œ ëŠ¥ë ¥ì´ ë‹´ê¸´ ì¹¼ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [300, 450], 
                    defense: [100, 150], 
                    dodge: [20, 20], 
                    luck: [15, 15] 
                }
            },
            { 
                name: 'ê³µê°„ ì ˆë‹¨ ë„ë¼', 
                rarity: 'ì—í”½', 
                price: 60000, 
                type: 'weapon',
                setName: 'ì‹œê³µ ì„¸íŠ¸',
                level: 60,
                description: 'ê³µê°„ì„ ì ˆë‹¨í•  ìˆ˜ ìˆëŠ” ì°¨ì› ì¡°ì‘ ë„ë¼ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [450, 650], 
                    defense: [80, 120], 
                    dodge: [-8, -8], 
                    luck: [20, 20] 
                }
            },
            { 
                name: 'ì°¨ì› í™œ', 
                rarity: 'ì—í”½', 
                price: 55000, 
                type: 'weapon',
                setName: 'ì‹œê³µ ì„¸íŠ¸',
                level: 60,
                description: 'ë‹¤ë¥¸ ì°¨ì›ì—ì„œ í™”ì‚´ì„ ì†Œí™˜í•˜ëŠ” ì‹ ë¹„í•œ í™œì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [350, 500], 
                    defense: [0, 0], 
                    dodge: [30, 30], 
                    luck: [40, 60] 
                }
            },
            // âœ¨ ë ˆì „ë“œë¦¬ ë“±ê¸‰ - ê°•í™”ì™• ì„¸íŠ¸
            { 
                name: 'ê°•í™”ì™•ì˜ ì¹¼', 
                rarity: 'ë ˆì „ë“œë¦¬', 
                price: 200000, 
                type: 'weapon',
                setName: 'ê°•í™”ì™• ì„¸íŠ¸',
                level: 80,
                description: 'ê°•í™”ì˜ ì™œì´ ë˜ì–´ ì „ì„¤ì´ ëœ ìµœê°•ì˜ ì¹¼ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [600, 900], 
                    defense: [200, 300], 
                    dodge: [30, 30], 
                    luck: [25, 25] 
                }
            },
            { 
                name: 'ì ˆëŒ€ íŒŒê´´ ë„ë¼', 
                rarity: 'ë ˆì „ë“œë¦¬', 
                price: 250000, 
                type: 'weapon',
                setName: 'ê°•í™”ì™• ì„¸íŠ¸',
                level: 80,
                description: 'ëª¨ë“  ê²ƒì„ íŒŒê´´í•  ìˆ˜ ìˆëŠ” ì ˆëŒ€ì ì¸ í˜ì˜ ë„ë¼ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [900, 1300], 
                    defense: [150, 250], 
                    dodge: [-10, -10], 
                    luck: [35, 35] 
                }
            },
            { 
                name: 'ìš´ëª… ì§€ë°° í™œ', 
                rarity: 'ë ˆì „ë“œë¦¬', 
                price: 220000, 
                type: 'weapon',
                setName: 'ê°•í™”ì™• ì„¸íŠ¸',
                level: 80,
                description: 'ìš´ëª…ì„ ì§€ë°°í•˜ì—¬ ì ˆëŒ€ì ì¸ ì‚¬ê²©ì„ ë³´ì¥í•˜ëŠ” ì „ì„¤ì˜ í™œì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [700, 1000], 
                    defense: [0, 0], 
                    dodge: [50, 50], 
                    luck: [60, 90] 
                }
            }
        ]
    },
    helmet: {
        name: 'í—¬ë©§',
        emoji: 'â›‘ï¸',
        gif: 'kim_shop_hood.png',
        items: [
            // ğŸŒ¸ ì¼ë°˜ ë“±ê¸‰ - ê½ƒì ì„¸íŠ¸
            { 
                name: 'ê½ƒ í™”ê´€', 
                rarity: 'ì¼ë°˜', 
                price: 400, 
                type: 'helmet',
                setName: 'ê½ƒì ì„¸íŠ¸',
                level: 1,
                description: 'ê½ƒììœ¼ë¡œ ë§Œë“  ì•„ë¦„ë‹¤ìš´ ë¨¸ë¦¬ ì¥ì‹ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [0, 0], 
                    defense: [8, 15], 
                    dodge: [3, 6], 
                    luck: [0, 0] 
                }
            },
            // â­ ê³ ê¸‰ ë“±ê¸‰ - ë³„ë¹› ì„¸íŠ¸
            { 
                name: 'ë³„ìë¦¬ ê´€', 
                rarity: 'ê³ ê¸‰', 
                price: 2000, 
                type: 'helmet',
                setName: 'ë³„ë¹› ì„¸íŠ¸',
                level: 20,
                description: 'ë³„ìë¦¬ì˜ ì¶•ë³µì´ ë‹´ê¸´ ì‹ ë¹„í•œ ê´€ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [0, 0], 
                    defense: [20, 35], 
                    dodge: [8, 15], 
                    luck: [5, 5] 
                }
            },
            // ğŸ”¥ ë ˆì–´ ë“±ê¸‰ - ë“œë˜ê³¤ ì„¸íŠ¸
            { 
                name: 'ìš© íˆ¬êµ¬', 
                rarity: 'ë ˆì–´', 
                price: 10000, 
                type: 'helmet',
                setName: 'ë“œë˜ê³¤ ì„¸íŠ¸',
                level: 40,
                description: 'ë“œë˜ê³¤ì˜ ë¹„ëŠ˜ë¡œ ë§Œë“  ê°•ë ¥í•œ ë°©ì–´ë ¥ì˜ íˆ¬êµ¬ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [0, 0], 
                    defense: [50, 80], 
                    dodge: [15, 25], 
                    luck: [10, 10] 
                }
            },
            // ğŸŒ™ ì—í”½ ë“±ê¸‰ - ì‹œê³µ ì„¸íŠ¸
            { 
                name: 'ì‹œê³µê°„ ê´€', 
                rarity: 'ì—í”½', 
                price: 40000, 
                type: 'helmet',
                setName: 'ì‹œê³µ ì„¸íŠ¸',
                level: 60,
                description: 'ì‹œê³µê°„ì„ ì¡°ì‘í•  ìˆ˜ ìˆëŠ” ì‹ ë¹„í•œ í˜ì´ ë‹´ê¸´ ê´€ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [0, 0], 
                    defense: [120, 180], 
                    dodge: [25, 40], 
                    luck: [20, 20] 
                }
            },
            // âœ¨ ë ˆì „ë“œë¦¬ ë“±ê¸‰ - ê°•í™”ì™• ì„¸íŠ¸
            { 
                name: 'ê°•í™”ì™• ê´€', 
                rarity: 'ë ˆì „ë“œë¦¬', 
                price: 180000, 
                type: 'helmet',
                setName: 'ê°•í™”ì™• ì„¸íŠ¸',
                level: 80,
                description: 'ê°•í™”ì˜ ì™•ì´ ì°©ìš©í•˜ëŠ” ìµœê³ ê¸‰ ëŒ€ë§ˆë²•ì‚¬ì˜ ê´€ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [0, 0], 
                    defense: [250, 380], 
                    dodge: [40, 60], 
                    luck: [35, 35] 
                }
            }
        ]
    },
    armor: {
        name: 'ê°‘ì˜·',
        emoji: 'ğŸ›¡ï¸',
        gif: 'kim_shop_armor.png',
        items: [
            // ğŸŒ¸ ì¼ë°˜ ë“±ê¸‰ - ê½ƒì ì„¸íŠ¸
            { 
                name: 'ê½ƒì ì˜·', 
                rarity: 'ì¼ë°˜', 
                price: 450, 
                type: 'armor',
                setName: 'ê½ƒì ì„¸íŠ¸',
                level: 1,
                description: 'ê½ƒììœ¼ë¡œ ë§Œë“  ê°€ë²¼ìš´ ë°©ì–´êµ¬ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [0, 0], 
                    defense: [10, 20], 
                    dodge: [2, 4], 
                    luck: [0, 0] 
                }
            },
            // â­ ê³ ê¸‰ ë“±ê¸‰ - ë³„ë¹› ì„¸íŠ¸
            { 
                name: 'ë³„ë¹› ê°‘ì˜·', 
                rarity: 'ê³ ê¸‰', 
                price: 2200, 
                type: 'armor',
                setName: 'ë³„ë¹› ì„¸íŠ¸',
                level: 20,
                description: 'ë³„ë¹›ì´ ë°˜ì§ì´ëŠ” ì‹ ë¹„ë¡œìš´ ê°‘ì˜·ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [0, 0], 
                    defense: [30, 50], 
                    dodge: [5, 10], 
                    luck: [3, 3] 
                }
            },
            // ğŸ”¥ ë ˆì–´ ë“±ê¸‰ - ë“œë˜ê³¤ ì„¸íŠ¸
            { 
                name: 'ë“œë˜ê³¤ ìŠ¤ì¼€ì¼ ê°‘ì˜·', 
                rarity: 'ë ˆì–´', 
                price: 11000, 
                type: 'armor',
                setName: 'ë“œë˜ê³¤ ì„¸íŠ¸',
                level: 40,
                description: 'ë“œë˜ê³¤ì˜ ë¹„ëŠ˜ë¡œ ë§Œë“  ë‹¨ë‹¨í•œ ê°‘ì˜·ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [0, 0], 
                    defense: [80, 120], 
                    dodge: [10, 18], 
                    luck: [8, 8] 
                }
            },
            // ğŸŒ™ ì—í”½ ë“±ê¸‰ - ì‹œê³µ ì„¸íŠ¸
            { 
                name: 'ì‹œê³µê°„ ê°‘ì˜·', 
                rarity: 'ì—í”½', 
                price: 45000, 
                type: 'armor',
                setName: 'ì‹œê³µ ì„¸íŠ¸',
                level: 60,
                description: 'ì‹œê³µê°„ì˜ ì™œê³¡ìœ¼ë¡œ ê³µê²©ì„ ë°©ì–´í•˜ëŠ” ê°‘ì˜·ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [0, 0], 
                    defense: [150, 230], 
                    dodge: [20, 35], 
                    luck: [15, 15] 
                }
            },
            // âœ¨ ë ˆì „ë“œë¦¬ ë“±ê¸‰ - ê°•í™”ì™• ì„¸íŠ¸
            { 
                name: 'ê°•í™”ì™•ì˜ ê°‘ì˜·', 
                rarity: 'ë ˆì „ë“œë¦¬', 
                price: 190000, 
                type: 'armor',
                setName: 'ê°•í™”ì™• ì„¸íŠ¸',
                level: 80,
                description: 'ê°•í™”ì˜ ì ˆëŒ€ìê°€ ì°©ìš©í•˜ëŠ” ìµœê°•ì˜ ê°‘ì˜·ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [0, 0], 
                    defense: [300, 450], 
                    dodge: [35, 55], 
                    luck: [30, 30] 
                }
            }
        ]
    },
    gloves: {
        name: 'ì¥ê°‘',
        emoji: 'ğŸ§¤',
        gif: 'kim_shop_gloves.png',
        items: [
            // ğŸŒ¸ ì¼ë°˜ ë“±ê¸‰ - ê½ƒì ì„¸íŠ¸
            { 
                name: 'ê½ƒì ì¥ê°‘', 
                rarity: 'ì¼ë°˜', 
                price: 350, 
                type: 'gloves',
                setName: 'ê½ƒì ì„¸íŠ¸',
                level: 1,
                description: 'ë¶€ë“œëŸ¬ìš´ ê½ƒììœ¼ë¡œ ë§Œë“  ì¥ê°‘ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [3, 8], 
                    defense: [5, 10], 
                    dodge: [5, 8], 
                    luck: [2, 2] 
                }
            },
            // â­ ê³ ê¸‰ ë“±ê¸‰ - ë³„ë¹› ì„¸íŠ¸
            { 
                name: 'ë³„ë¹› ì¥ê°‘', 
                rarity: 'ê³ ê¸‰', 
                price: 1800, 
                type: 'gloves',
                setName: 'ë³„ë¹› ì„¸íŠ¸',
                level: 20,
                description: 'ë³„ì˜ í˜ì´ ê¹ƒë“  ë¯¼ì²©í•œ ì¥ê°‘ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [10, 20], 
                    defense: [15, 25], 
                    dodge: [12, 20], 
                    luck: [8, 8] 
                }
            },
            // ğŸ”¥ ë ˆì–´ ë“±ê¸‰ - ë“œë˜ê³¤ ì„¸íŠ¸
            { 
                name: 'ë“œë˜ê³¤ í´ë¡œ', 
                rarity: 'ë ˆì–´', 
                price: 9000, 
                type: 'gloves',
                setName: 'ë“œë˜ê³¤ ì„¸íŠ¸',
                level: 40,
                description: 'ë“œë˜ê³¤ì˜ ë°œí†±ì„ ëª¨ë°©í•œ ê³µê²©ì ì¸ ì¥ê°‘ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [30, 50], 
                    defense: [30, 50], 
                    dodge: [20, 30], 
                    luck: [15, 15] 
                }
            },
            // ğŸŒ™ ì—í”½ ë“±ê¸‰ - ì‹œê³µ ì„¸íŠ¸
            { 
                name: 'ì‹œê³µê°„ ì¥ê°‘', 
                rarity: 'ì—í”½', 
                price: 38000, 
                type: 'gloves',
                setName: 'ì‹œê³µ ì„¸íŠ¸',
                level: 60,
                description: 'ì‹œê³µê°„ì„ ì¡°ì‘í•˜ëŠ” ëŠ¥ë ¥ì´ ë‹´ê¸´ ì¥ê°‘ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [60, 100], 
                    defense: [60, 100], 
                    dodge: [35, 50], 
                    luck: [25, 25] 
                }
            },
            // âœ¨ ë ˆì „ë“œë¦¬ ë“±ê¸‰ - ê°•í™”ì™• ì„¸íŠ¸
            { 
                name: 'ê°•í™”ì™•ì˜ ì¥ê°‘', 
                rarity: 'ë ˆì „ë“œë¦¬', 
                price: 170000, 
                type: 'gloves',
                setName: 'ê°•í™”ì™• ì„¸íŠ¸',
                level: 80,
                description: 'ê°•í™”ì˜ í˜ì„ ê·¹ëŒ€í™”ì‹œí‚¤ëŠ” ì „ì„¤ì˜ ì¥ê°‘ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [120, 200], 
                    defense: [120, 200], 
                    dodge: [50, 70], 
                    luck: [40, 40] 
                }
            }
        ]
    },
    boots: {
        name: 'ë¶€ì¸ ',
        emoji: 'ğŸ‘¢',
        gif: 'kim_shop_boots.png',
        items: [
            // ğŸŒ¸ ì¼ë°˜ ë“±ê¸‰ - ê½ƒì ì„¸íŠ¸
            { 
                name: 'ê½ƒì ì‹ ë°œ', 
                rarity: 'ì¼ë°˜', 
                price: 380, 
                type: 'boots',
                setName: 'ê½ƒì ì„¸íŠ¸',
                level: 1,
                description: 'ê°€ë³ê³  í¸ì•ˆí•œ ê½ƒì ì‹ ë°œì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [0, 0], 
                    defense: [6, 12], 
                    dodge: [8, 12], 
                    luck: [1, 1] 
                }
            },
            // â­ ê³ ê¸‰ ë“±ê¸‰ - ë³„ë¹› ì„¸íŠ¸
            { 
                name: 'ë³„ë¹› ë¶€ì¸ ', 
                rarity: 'ê³ ê¸‰', 
                price: 1900, 
                type: 'boots',
                setName: 'ë³„ë¹› ì„¸íŠ¸',
                level: 20,
                description: 'ë³„ì²˜ëŸ¼ ë¹ ë¥¸ ì†ë„ë¥¼ ìë‘í•˜ëŠ” ë¶€ì¸ ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [0, 0], 
                    defense: [18, 30], 
                    dodge: [18, 28], 
                    luck: [6, 6] 
                }
            },
            // ğŸ”¥ ë ˆì–´ ë“±ê¸‰ - ë“œë˜ê³¤ ì„¸íŠ¸
            { 
                name: 'ë“œë˜ê³¤ ì›Œì»¤', 
                rarity: 'ë ˆì–´', 
                price: 9500, 
                type: 'boots',
                setName: 'ë“œë˜ê³¤ ì„¸íŠ¸',
                level: 40,
                description: 'ë“œë˜ê³¤ì˜ ë°œê±¸ìŒì²˜ëŸ¼ ë¬µì§í•œ ë¶€ì¸ ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [0, 0], 
                    defense: [40, 70], 
                    dodge: [30, 45], 
                    luck: [12, 12] 
                }
            },
            // ğŸŒ™ ì—í”½ ë“±ê¸‰ - ì‹œê³µ ì„¸íŠ¸
            { 
                name: 'ì‹œê³µê°„ ë¶€ì¸ ', 
                rarity: 'ì—í”½', 
                price: 42000, 
                type: 'boots',
                setName: 'ì‹œê³µ ì„¸íŠ¸',
                level: 60,
                description: 'ìˆœê°„ì´ë™ì´ ê°€ëŠ¥í•œ ì‹ ë¹„í•œ ë¶€ì¸ ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [0, 0], 
                    defense: [80, 130], 
                    dodge: [60, 85], 
                    luck: [22, 22] 
                }
            },
            // âœ¨ ë ˆì „ë“œë¦¬ ë“±ê¸‰ - ê°•í™”ì™• ì„¸íŠ¸
            { 
                name: 'ê°•í™”ì™•ì˜ ë¶€ì¸ ', 
                rarity: 'ë ˆì „ë“œë¦¬', 
                price: 175000, 
                type: 'boots',
                setName: 'ê°•í™”ì™• ì„¸íŠ¸',
                level: 80,
                description: 'ì ˆëŒ€ì ì¸ ì†ë„ì™€ íšŒí”¼ë¥¼ ë³´ì¥í•˜ëŠ” ì „ì„¤ì˜ ë¶€ì¸ ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [0, 0], 
                    defense: [160, 260], 
                    dodge: [100, 140], 
                    luck: [38, 38] 
                }
            }
        ]
    },
    accessory: {
        name: 'ì•¡ì„¸ì„œë¦¬',
        emoji: 'ğŸ’',
        gif: 'kim_equipment_acce.gif',
        items: [
            // ğŸŒ¸ ì¼ë°˜ ë“±ê¸‰ - ê½ƒì ì„¸íŠ¸
            { 
                name: 'ê½ƒì ëª©ê±¸ì´', 
                rarity: 'ì¼ë°˜', 
                price: 420, 
                type: 'accessory',
                setName: 'ê½ƒì ì„¸íŠ¸',
                level: 1,
                description: 'í–‰ìš´ì„ ë¶€ë¥´ëŠ” ê½ƒì ëª©ê±¸ì´ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [2, 5], 
                    defense: [2, 5], 
                    dodge: [2, 2], 
                    luck: [8, 12] 
                }
            },
            // â­ ê³ ê¸‰ ë“±ê¸‰ - ë³„ë¹› ì„¸íŠ¸
            { 
                name: 'ë³„ë¹› ë°˜ì§€', 
                rarity: 'ê³ ê¸‰', 
                price: 2100, 
                type: 'accessory',
                setName: 'ë³„ë¹› ì„¸íŠ¸',
                level: 20,
                description: 'ë³„ì˜ ì¶•ë³µì´ ë‹´ê¸´ ì‹ ë¹„í•œ ë°˜ì§€ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [8, 15], 
                    defense: [8, 15], 
                    dodge: [5, 5], 
                    luck: [20, 30] 
                }
            },
            // ğŸ”¥ ë ˆì–´ ë“±ê¸‰ - ë“œë˜ê³¤ ì„¸íŠ¸
            { 
                name: 'ë“œë˜ê³¤ í•˜íŠ¸', 
                rarity: 'ë ˆì–´', 
                price: 10500, 
                type: 'accessory',
                setName: 'ë“œë˜ê³¤ ì„¸íŠ¸',
                level: 40,
                description: 'ë“œë˜ê³¤ì˜ ì‹¬ì¥ì´ ë‹´ê¸´ ê°•ë ¥í•œ ì•¡ì„¸ì„œë¦¬ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [20, 35], 
                    defense: [20, 35], 
                    dodge: [8, 8], 
                    luck: [40, 60] 
                }
            },
            // ğŸŒ™ ì—í”½ ë“±ê¸‰ - ì‹œê³µ ì„¸íŠ¸
            { 
                name: 'ì‹œê³µê°„ í¬ë¦¬ìŠ¤íƒˆ', 
                rarity: 'ì—í”½', 
                price: 48000, 
                type: 'accessory',
                setName: 'ì‹œê³µ ì„¸íŠ¸',
                level: 60,
                description: 'ì‹œê³µê°„ì˜ í˜ì´ ì‘ì¶•ëœ í¬ë¦¬ìŠ¤íƒˆì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [40, 70], 
                    defense: [40, 70], 
                    dodge: [15, 15], 
                    luck: [80, 120] 
                }
            },
            // âœ¨ ë ˆì „ë“œë¦¬ ë“±ê¸‰ - ê°•í™”ì™• ì„¸íŠ¸
            { 
                name: 'ê°•í™”ì™•ì˜ ì¦í‘œ', 
                rarity: 'ë ˆì „ë“œë¦¬', 
                price: 195000, 
                type: 'accessory',
                setName: 'ê°•í™”ì™• ì„¸íŠ¸',
                level: 80,
                description: 'ê°•í™”ì˜ ì ˆëŒ€ìì„ì„ ì¦ëª…í•˜ëŠ” ìµœê³ ì˜ ì•¡ì„¸ì„œë¦¬ì…ë‹ˆë‹¤.',
                stats: { 
                    attack: [80, 140], 
                    defense: [80, 140], 
                    dodge: [25, 25], 
                    luck: [150, 220] 
                }
            }
        ]
    },
    consumable: {
        name: 'ì†Œë¹„',
        emoji: 'ğŸ’Š',
        gif: 'kim_shop_con.gif',
        items: [
            // ì†Œë¹„ ì•„ì´í…œ ì¶”ê°€ ì˜ˆì •
        ]
    },
    enhancement: {
        name: 'ì£¼ë¬¸ì„œ',
        emoji: 'âš’ï¸',
        gif: 'kim_shop_examples.gif',
        items: [
            // ì£¼ë¬¸ì„œ ì•„ì´í…œ ì¶”ê°€ ì˜ˆì •
        ]
    },
    coin: {
        name: 'ì½”ì¸',
        emoji: 'ğŸª™',
        gif: 'kim_shop_coin.gif',
        items: [
            // ì½”ì¸ ì•„ì´í…œ ì¶”ê°€ ì˜ˆì •
        ]
    }
};

// ì˜ë¢° ì‹œìŠ¤í…œ ë°ì´í„°
const QUEST_CLIENTS = {
    // ğŸ’° ì˜ë¢°ì£¼í™”ë¥¼ ì–»ëŠ” ì˜ë¢° (20ê°€ì§€)
    villagers: [
        {
            id: 1,
            name: 'ë§ˆì„ ì£¼ë¯¼ ê¹€ë´‰ìˆœ',
            type: 'reward',
            title: 'ê³ ì–‘ì´ êµ¬ì¶œ ì‘ì „',
            description: 'ì•„, ë‹¹ì‹ ! í˜¹ì‹œ ì‹œê°„ ìˆìœ¼ì„¸ìš”? ìš°ë¦¬ ì§‘ ê³ ì–‘ì´ê°€ ë˜ ë‚˜ë¬´ì— ì˜¬ë¼ê°€ì„œ ë‚´ë ¤ì˜¤ì§ˆ ëª»í•˜ê³  ìˆì–´ìš”. ë„ì™€ì£¼ì‹œë©´ ì‘ì€ ë³´ë‹µì„ ë“œë¦´ê²Œìš”!',
            emoji: 'ğŸ±'
        },
        {
            id: 2,
            name: 'ë§ˆì„ ì£¼ë¯¼ ë°•ì² ìˆ˜',
            type: 'reward',
            title: 'ìš°ë¬¼ ì†ŒìŒ ì¡°ì‚¬',
            description: 'ì–´ë¨¸, ëª¨í—˜ê°€ë‹˜! ë§ˆì¹¨ ì˜ ì˜¤ì…¨ë„¤ìš”. ë§ˆì„ ìš°ë¬¼ì—ì„œ ì´ìƒí•œ ì†Œë¦¬ê°€ ë‚˜ëŠ”ë°... í˜¹ì‹œ í•œ ë²ˆ ë´ì£¼ì‹¤ ìˆ˜ ìˆë‚˜ìš”? ë¬¼ë¡  ìˆ˜ê³ ë¹„ëŠ” ë“œë¦´ê²Œìš”.',
            emoji: 'ğŸº'
        },
        {
            id: 3,
            name: 'ë§ˆì„ ì£¼ë¯¼ ì´ì˜í¬',
            type: 'reward',
            title: 'í• ë¨¸ë‹ˆì˜ ì•½ì´ˆ ìˆ˜ì§‘',
            description: 'ì €ê¸°ìš”, ëª¨í—˜ê°€ë‹˜! ìš°ë¦¬ í• ë¨¸ë‹ˆê°€ ì•½ì´ˆë¥¼ êµ¬í•´ë‹¬ë¼ê³  í•˜ì‹œëŠ”ë°... ë§ˆì„ ê·¼ì²˜ì—ì„œ ì‰½ê²Œ ì°¾ì„ ìˆ˜ ìˆëŠ” ê±°ë¼ê³  í•˜ë„¤ìš”. ë¶€íƒë“œë ¤ë„ ë ê¹Œìš”?',
            emoji: 'ğŸŒ¿'
        },
        {
            id: 4,
            name: 'ë§ˆì„ ì£¼ë¯¼ ìµœë¯¼ìˆ˜',
            type: 'reward',
            title: 'ì°½ê³  ì¥ í‡´ì¹˜',
            description: 'ì•„! ë‹¹ì‹ ì´ ê·¸ ìœ ëª…í•œ ëª¨í—˜ê°€êµ°ìš”! ìš°ë¦¬ ë§ˆì„ ì°½ê³ ì— ì¥ë“¤ì´ ë„ˆë¬´ ë§ì•„ì¡Œì–´ìš”. ì¢€ ì«“ì•„ë‚´ ì£¼ì‹¤ ìˆ˜ ìˆë‚˜ìš”? ê°ì‚¬ì˜ ë§ˆìŒì„ ë‹´ì•„ ë³´ìƒì„ ë“œë¦´ê²Œìš”.',
            emoji: 'ğŸ­'
        },
        {
            id: 5,
            name: 'ë§ˆì„ ì£¼ë¯¼ ì •ìˆ˜ì—°',
            type: 'reward',
            title: 'ë§ˆì„ ê°„íŒ ë³µêµ¬',
            description: 'ëª¨í—˜ê°€ë‹˜, ì ê¹ë§Œìš”! ë§ˆì„ ì…êµ¬ ê°„íŒì´ ë°”ëŒì— ë„˜ì–´ì¡ŒëŠ”ë° í˜¼ìì„œëŠ” ë‹¤ì‹œ ì„¸ìš°ê¸° í˜ë“¤ì–´ìš”. ë„ì™€ì£¼ì‹œë©´ ê³ ë§™ê² ì–´ìš”!',
            emoji: 'ğŸ“‹'
        },
        {
            id: 6,
            name: 'ë§ˆì„ ì£¼ë¯¼ ê°•ì§€í›ˆ',
            type: 'reward',
            title: 'í¸ì§€ ì „ë‹¬ ë¶€íƒ',
            description: 'ì–´ë¼, ëª¨í—˜ê°€ë‹˜! ë§ˆì¹¨ ì˜ ë§Œë‚¬ë„¤ìš”. ì´ì›ƒì§‘ì— í¸ì§€ ì¢€ ì „í•´ì£¼ì‹¤ ìˆ˜ ìˆë‚˜ìš”? ë‹¤ë¦¬ê°€ ì•„íŒŒì„œ ì§ì ‘ ê°€ê¸°ê°€ í˜ë“¤ì–´ì„œìš”...',
            emoji: 'ğŸ’Œ'
        },
        {
            id: 7,
            name: 'ë§ˆì„ ì£¼ë¯¼ ìœ¤ë¯¸ë‚˜',
            type: 'reward',
            title: 'ê´‘ì¥ ì²­ì†Œ ë„ì›€',
            description: 'ì €ê¸°, í˜¹ì‹œ ë°”ì˜ì§€ ì•Šìœ¼ì‹œë‹¤ë©´... ë§ˆì„ ê´‘ì¥ì— ë–¨ì–´ì§„ ë‚™ì—½ë“¤ì„ ì¢€ ì¹˜ì›Œì£¼ì‹¤ ìˆ˜ ìˆë‚˜ìš”? ë§ˆì„ ì¶•ì œ ì¤€ë¹„ ë•Œë¬¸ì— ê¸‰í•´ì„œìš”.',
            emoji: 'ğŸ‚'
        },
        {
            id: 8,
            name: 'ë§ˆì„ ì£¼ë¯¼ ì„í˜„ìš°',
            type: 'reward',
            title: 'ì§€ë¶• ìœ„ ê³µ íšŒìˆ˜',
            description: 'ëª¨í—˜ê°€ë‹˜! ìš°ë¦¬ ì•„ì´ê°€ ê³µì„ ì§€ë¶• ìœ„ì— ì˜¬ë ¤ë²„ë ¸ì–´ìš”. ì‚¬ë‹¤ë¦¬ê°€ ìˆê¸´ í•œë° í˜¼ìì„œëŠ” ìœ„í—˜í•´ì„œ... ë„ì™€ì£¼ì‹¤ ìˆ˜ ìˆë‚˜ìš”?',
            emoji: 'âš½'
        },
        {
            id: 9,
            name: 'ë§ˆì„ ì£¼ë¯¼ ì†¡ë‹¤ì€',
            type: 'reward',
            title: 'ë©§ë¼ì§€ í‡´ì¹˜',
            description: 'ì•„, ë‹¹ì‹ ! ë§ˆì„ ë’¤í¸ í…ƒë°­ì— ë©§ë¼ì§€ê°€ ë‚˜íƒ€ë‚˜ì„œ ë†ì‘ë¬¼ì„ ë§ê°€ëœ¨ë¦¬ê³  ìˆì–´ìš”. ì«“ì•„ë‚´ ì£¼ì‹œë©´ ì •ë§ ê°ì‚¬í•˜ê² ì–´ìš”!',
            emoji: 'ğŸ—'
        },
        {
            id: 10,
            name: 'ë§ˆì„ ì£¼ë¯¼ í•œì§€ìš°',
            type: 'reward',
            title: 'ìš°ë¬¼ ì´ë¬¼ì§ˆ ì œê±°',
            description: 'ëª¨í—˜ê°€ë‹˜, ì ì‹œë§Œìš”! ë§ˆì„ ìš°ë¬¼ë¬¼ì´ íƒí•´ì¡ŒëŠ”ë° ë°‘ì— ë­”ê°€ ë–¨ì–´ì§„ ê²ƒ ê°™ì•„ìš”. ê±´ì ¸ë‚´ ì£¼ì‹¤ ìˆ˜ ìˆë‚˜ìš”? ë³´ìƒì€ ë‹¹ì—°íˆ ë“œë¦´ê²Œìš”.',
            emoji: 'ğŸª£'
        }
    ],
    merchants: [
        {
            id: 11,
            name: 'ì¡í™”ìƒ ëˆë³µì´',
            type: 'reward',
            title: 'ì°½ê³  ì •ë¦¬ ì•Œë°”',
            description: 'ì–´ì–´, ëª¨í—˜ê°€ë‹˜! ë§ˆì¹¨ ì˜ ì˜¤ì…¨ì–´ìš”. ì œê°€ ë¬¼ê±´ì„ ë„ˆë¬´ ë§ì´ ì£¼ë¬¸í•´ì„œ ì°½ê³ ê°€ ê½‰ ì°¼ì–´ìš”. ì •ë¦¬ ì¢€ ë„ì™€ì£¼ì‹œë©´ ìˆ˜ê³ ë¹„ë¥¼ ë“œë¦´ê²Œìš”!',
            emoji: 'ğŸ“¦'
        },
        {
            id: 12,
            name: 'ì¡í™”ìƒ ì¥ì‚¬ê¾¼',
            type: 'reward',
            title: 'ê°„íŒ ì²­ì†Œ ì‘ì—…',
            description: 'ì˜¤, ëª¨í—˜ê°€ë‹˜! í˜¹ì‹œ ì‹œê°„ ë˜ì‹œë©´ ì œ ê°€ê²Œ ê°„íŒ ì¢€ ë‹¦ì•„ì£¼ì‹¤ ìˆ˜ ìˆë‚˜ìš”? ë†’ì€ ê³³ì´ë¼ ì œê°€ í•˜ê¸°ì—” ìœ„í—˜í•´ì„œìš”. ë¬¼ë¡  í’ˆì‚¯ì€ ë“œë¦´ê²Œìš”.',
            emoji: 'ğŸª§'
        },
        {
            id: 13,
            name: 'ì¡í™”ìƒ ì‹¬ìˆ ë§¨',
            type: 'reward',
            title: 'ì•¼ê°„ ê²½ë¹„ ì—…ë¬´',
            description: 'ì•„! ë‹¹ì‹ ì´ ê·¸ ì‹¤ë ¥ìêµ°ìš”! ì œ ìƒì ì— ë„ë‘‘ì´ ë“¤ì–´ì˜¬ê¹Œ ë´ ê±±ì •ì¸ë°... ì˜¤ëŠ˜ ë°¤ í•œ ë²ˆë§Œ ì§€ì¼œë´ ì£¼ì‹¤ ìˆ˜ ìˆë‚˜ìš”? ì‚¬ë¡€ëŠ” ì¶©ë¶„íˆ ë“œë¦´ê²Œìš”.',
            emoji: 'ğŸŒ™'
        },
        {
            id: 14,
            name: 'ì¡í™”ìƒ íƒë°°ì™•',
            type: 'reward',
            title: 'ë¬¼ê±´ ë°°ë‹¬ ì„œë¹„ìŠ¤',
            description: 'ëª¨í—˜ê°€ë‹˜, ì ê¹ë§Œìš”! ë‹¤ë¥¸ ë§ˆì„ì—ì„œ ì£¼ë¬¸í•œ ë¬¼ê±´ì´ ìˆëŠ”ë° ì§ì ‘ ë°°ë‹¬í•´ ì£¼ì‹¤ ìˆ˜ ìˆë‚˜ìš”? ì €ëŠ” ê°€ê²Œë¥¼ ë¹„ìš¸ ìˆ˜ê°€ ì—†ì–´ì„œìš”.',
            emoji: 'ğŸ“®'
        },
        {
            id: 15,
            name: 'ì¡í™”ìƒ ì½”ë§‰í˜',
            type: 'reward',
            title: 'ì§€í•˜ì°½ê³  ëƒ„ìƒˆ ì¡°ì‚¬',
            description: 'ì–´ë¨¸, ëª¨í—˜ê°€ë‹˜! ì œ ê°€ê²Œ ì§€í•˜ì°½ê³ ì— ì´ìƒí•œ ëƒ„ìƒˆê°€ ë‚˜ëŠ”ë°... í˜¹ì‹œ í•œ ë²ˆ í™•ì¸í•´ ì£¼ì‹¤ ìˆ˜ ìˆë‚˜ìš”? ë­”ê°€ ì©ì€ ê²ƒ ê°™ì•„ì„œ ê±±ì •ì´ì—ìš”.',
            emoji: 'ğŸ¤¢'
        },
        {
            id: 16,
            name: 'ì¡í™”ìƒ ê²ìŸì´',
            type: 'reward',
            title: 'ë¬¼ê±´ ìˆ˜ì†¡ í˜¸ìœ„',
            description: 'ì˜¤, ì˜ ì˜¤ì…¨ì–´ìš”! ì œê°€ íŒ” ë¬¼ê±´ë“¤ì„ ë‹¤ë¥¸ ë§ˆì„ì—ì„œ ê°€ì ¸ì™€ì•¼ í•˜ëŠ”ë° ê¸¸ì´ ìœ„í—˜í•´ì„œìš”. í˜¸ìœ„í•´ ì£¼ì‹œë©´ ë„‰ë„‰íˆ ë³´ìƒí•´ ë“œë¦´ê²Œìš”.',
            emoji: 'ğŸ›¡ï¸'
        },
        {
            id: 17,
            name: 'ì¡í™”ìƒ ì •ë³´í†µ',
            type: 'reward',
            title: 'íŠ¹ë³„ ì£¼ë¬¸ ìˆ˜ì§‘',
            description: 'ëª¨í—˜ê°€ë‹˜! ë§ˆì¹¨ ì¢‹ì€ íƒ€ì´ë°ì´ë„¤ìš”. ì œ ë‹¨ê³¨ì†ë‹˜ì´ íŠ¹ë³„í•œ ë¬¼ê±´ì„ ì°¾ê³  ìˆëŠ”ë° êµ¬í•´ë‹¤ ì£¼ì‹¤ ìˆ˜ ìˆë‚˜ìš”? ìˆ˜ìˆ˜ë£ŒëŠ” ì¶©ë¶„íˆ ë“œë¦´ê²Œìš”.',
            emoji: 'ğŸ”'
        },
        {
            id: 18,
            name: 'ì¡í™”ìƒ ìŠ¤íŒŒì´',
            type: 'reward',
            title: 'ê²½ìŸì—…ì²´ ì •ì°°',
            description: 'ì–´ë¼, ëª¨í—˜ê°€ë‹˜! ì œ ê²½ìŸì—…ì²´ê°€ ìê¾¸ ì œ ì†ë‹˜ë“¤ì„ ë¹¼ì•—ì•„ ê°€ëŠ”ë°... ê·¸ìª½ ê°€ê²©ì´ë‚˜ ì•Œì•„ë´ ì£¼ì‹¤ ìˆ˜ ìˆë‚˜ìš”? ì •ë³´ë¹„ëŠ” ë“œë¦´ê²Œìš”.',
            emoji: 'ğŸ•µï¸'
        },
        {
            id: 19,
            name: 'ì¡í™”ìƒ êµ´ì°©ë§¨',
            type: 'reward',
            title: 'ë¯¸ìŠ¤í„°ë¦¬ êµ¬ë© ì¡°ì‚¬',
            description: 'ì•„, ë‹¹ì‹ ! ì œ ê°€ê²Œ ë’¤í¸ì— ì´ìƒí•œ êµ¬ë©ì´ ìƒê²¼ëŠ”ë° ë­”ì§€ í™•ì¸í•´ ì£¼ì‹¤ ìˆ˜ ìˆë‚˜ìš”? í˜¹ì‹œ ì§€í•˜ì— ë­”ê°€ ìˆì„ì§€ë„ ëª°ë¼ì„œìš”.',
            emoji: 'ğŸ•³ï¸'
        },
        {
            id: 20,
            name: 'ì¡í™”ìƒ ì†ë†ˆì´',
            type: 'reward',
            title: 'ì—´ì‡  ì°¾ê¸° ëŒ€ì‘ì „',
            description: 'ëª¨í—˜ê°€ë‹˜, ë¶€íƒì´ ìˆì–´ìš”! ì œê°€ ì‹¤ìˆ˜ë¡œ ì¤‘ìš”í•œ ì—´ì‡ ë¥¼ ì—°ëª»ì— ë¹ ëœ¨ë ¸ëŠ”ë°... ì°¾ì•„ì£¼ì‹œë©´ ì •ë§ ê°ì‚¬í•˜ê² ì–´ìš”. ë³´ìƒì€ í™•ì‹¤íˆ ë“œë¦´ê²Œìš”!',
            emoji: 'ğŸ—ï¸'
        }
    ],
    scammers: [
        {
            id: 21,
            name: 'ìˆ˜ìƒí•œìƒì¸ ì•½ì¥ìˆ˜',
            type: 'scam',
            title: 'íŠ¹ë³„ ë¬¼ì•½ ì‹œìŒíšŒ',
            description: 'ì˜¤ì˜¤, ëª¨í—˜ê°€ë‹˜! íŠ¹ë³„í•œ ê¸°íšŒë¥¼ ë“œë¦´ê²Œìš”! ì´ ë§ˆë²• ë¬¼ì•½ì„ ë¯¸ë¦¬ ë§›ë³´ê¸°ë¡œ ë“œì‹œë©´ íš¨ê³¼ë¥¼ ë³´ì¥í•´ ë“œë ¤ìš”. ë‹¨ëˆ 3ë§Œ ê³¨ë“œë©´ ë˜ê³ ìš”... ì–´ë– ì„¸ìš”?',
            emoji: 'ğŸ§ª',
            scamAmount: 30000
        },
        {
            id: 22,
            name: 'ìˆ˜ìƒí•œìƒì¸ ì •ë³´ê¾¼',
            type: 'scam',
            title: 'ë³´ë¬¼ ìœ„ì¹˜ ì •ë³´ íŒë§¤',
            description: 'ì–´ì–´, ì‹¤ë ¥ìì‹œë„¤ìš”! ì œê°€ íŠ¹ë³„í•œ ì •ë³´ë¥¼ í•˜ë‚˜ ì•Œê³  ìˆëŠ”ë°... ê·¼ì²˜ ë™êµ´ì— ë³´ë¬¼ì´ ìˆ¨ê²¨ì ¸ ìˆì–´ìš”. ìœ„ì¹˜ë¥¼ ì•Œë ¤ë“œë¦´ í…Œë‹ˆ 2ë§Œ ê³¨ë“œë§Œ ì£¼ì„¸ìš”!',
            emoji: 'ğŸ—ºï¸',
            scamAmount: 20000
        },
        {
            id: 23,
            name: 'ìˆ˜ìƒí•œìƒì¸ ë§ˆë²•ì‚¬',
            type: 'scam',
            title: 'í–‰ìš´ì˜ ë§ˆë²• ë°˜ì§€',
            description: 'ëª¨í—˜ê°€ë‹˜! ì´ ë°˜ì§€ ë³´ì„¸ìš”. ë§ˆë²•ì´ ê±¸ë ¤ìˆì–´ì„œ ìš´ì´ ì—„ì²­ ì¢‹ì•„ì§„ë‹¤ê³  í•´ìš”! ì›ë˜ 10ë§Œ ê³¨ë“œì¸ë° ë‹¹ì‹ ì—ê²Œë§Œ íŠ¹ê°€ 4ë§Œ ê³¨ë“œì— ë“œë¦´ê²Œìš”!',
            emoji: 'ğŸ’',
            scamAmount: 40000
        },
        {
            id: 24,
            name: 'ìˆ˜ìƒí•œìƒì¸ ë¹šìŸì´',
            type: 'scam',
            title: 'ê¸‰í•œ ëˆ ëŒ€ì—¬ ë¶€íƒ',
            description: 'ì•„, ë‹¹ì‹ ! í˜¹ì‹œ ì—¬ê¸° ê·¼ì²˜ì—ì„œ ìˆ˜ìƒí•œ ë†ˆë“¤ì„ ë³¸ ì  ìˆë‚˜ìš”? ì œê°€ ë¬¼ì–´ë³´ëŠ” ì´ìœ ê°€... ì•„ë‹ˆ, ì¼ë‹¨ 5ë§Œ ê³¨ë“œë¶€í„° ë¹Œë ¤ì£¼ì‹œë©´ ì„¤ëª…í•´ ë“œë¦´ê²Œìš”.',
            emoji: 'ğŸ’¸',
            scamAmount: 50000
        },
        {
            id: 25,
            name: 'ìˆ˜ìƒí•œìƒì¸ ì‚¬ê¸°ê¾¼',
            type: 'scam',
            title: 'ì¹œêµ¬ ì‘ê¸‰ ì¹˜ë£Œë¹„',
            description: 'ëª¨í—˜ê°€ë‹˜, ê¸´ê¸‰ìƒí™©ì´ì—ìš”! ì œ ì¹œêµ¬ê°€ ë‹¤ë¥¸ ë§ˆì„ì—ì„œ ì‚¬ê³ ë¥¼ ë‹¹í–ˆëŠ”ë° ì¹˜ë£Œë¹„ê°€ í•„ìš”í•´ìš”. 1ë§Œ ê³¨ë“œë§Œ ë¹Œë ¤ì£¼ì‹œë©´ ë‚´ì¼ ë‘ ë°°ë¡œ ê°šì„ê²Œìš”!',
            emoji: 'ğŸš‘',
            scamAmount: 10000
        },
        {
            id: 26,
            name: 'ìˆ˜ìƒí•œìƒì¸ ë³´ê´€ê¾¼',
            type: 'scam',
            title: 'ê·€ì¤‘í’ˆ ë³´ê´€ ì„œë¹„ìŠ¤',
            description: 'ì–´ë¨¸, ëª¨í—˜ê°€ë‹˜! ì œê°€ ê·€ì¤‘í•œ ë¬¼ê±´ì„ ë§¡ì•„ë“œë¦´ê²Œìš”. ë³´ê´€ë£Œë¡œ 3ë§Œ ê³¨ë“œë§Œ ì£¼ì‹œë©´... ì•„, ë¯¸ì•ˆí•´ìš”! ì§€ê¸ˆ ê¸‰í•œ ì¼ì´ ìƒê²¨ì„œ ê°€ë´ì•¼ê² ì–´ìš”!',
            emoji: 'ğŸƒ',
            scamAmount: 30000
        }
    ],
    travelers: [
        {
            id: 27,
            name: 'ìˆ˜ìƒí•œì—¬í–‰ì ë„ë°•ê¾¼',
            type: 'scam',
            title: 'íŠ¹ë³„í•œ ì£¼ì‚¬ìœ„ ê²Œì„',
            description: 'ì €ê¸°ìš”! í˜¹ì‹œ ë„ë°• í•œ íŒ ì–´ë– ì„¸ìš”? ì´ ì£¼ì‚¬ìœ„ëŠ” íŠ¹ë³„í•´ì„œ ê±°ì˜ ì´ê¸¸ ìˆ˜ ìˆì–´ìš”! íŒëˆ 2ë§Œ ê³¨ë“œë§Œ ê±¸ì–´ë³´ì‹œë©´... ë¶„ëª… ì¬ë¯¸ìˆì„ ê±°ì˜ˆìš”!',
            emoji: 'ğŸ²',
            scamAmount: 20000
        },
        {
            id: 28,
            name: 'ìˆ˜ìƒí•œì—¬í–‰ì ëª¨í—˜ê°€',
            type: 'scam',
            title: 'ë³´ë¬¼ì°¾ê¸° ë™ì—… ì œì•ˆ',
            description: 'ëª¨í—˜ê°€ë‹˜! ì €ì™€ í•¨ê»˜ ë³´ë¬¼ì°¾ê¸°ë¥¼ í•˜ì‹œê² ì–´ìš”? ì§€ë„ë„ ìˆê³  ì¥ë¹„ë„ ì¤€ë¹„í–ˆëŠ”ë°... ì°¸ê°€ë¹„ë¡œ 4ë§Œ ê³¨ë“œë§Œ ë‚´ì‹œë©´ ì ˆë°˜ì”© ë‚˜ëˆ ê°€ì ¸ìš”!',
            emoji: 'ğŸ´â€â˜ ï¸',
            scamAmount: 40000
        },
        {
            id: 29,
            name: 'ìˆ˜ìƒí•œì—¬í–‰ì í”¼í•´ì',
            type: 'scam',
            title: 'ê·€ì¤‘í’ˆ ìˆ˜ìƒ‰ ì˜ë¢°',
            description: 'ì•„! ë‹¹ì‹  ê°™ì€ ì‹¤ë ¥ìë¥¼ ì°¾ê³  ìˆì—ˆì–´ìš”! ì œê°€ ëª¬ìŠ¤í„°ì—ê²Œ ìŠµê²©ë‹¹í•´ì„œ ê·€ì¤‘í’ˆì„ ëºê²¼ëŠ”ë°... ì°¾ì•„ì£¼ì‹œë©´ 5ë§Œ ê³¨ë“œë¥¼ ë“œë¦´ê²Œìš”. ë‹¨, ìˆ˜ìƒ‰ë¹„ë¡œ 1ë§Œ ê³¨ë“œê°€ í•„ìš”í•´ìš”.',
            emoji: 'ğŸ‘¹',
            scamAmount: 10000
        },
        {
            id: 30,
            name: 'ìˆ˜ìƒí•œì—¬í–‰ì ê±°ì§€',
            type: 'scam',
            title: 'ê°•ë„ í”¼í•´ ë„ì›€ ìš”ì²­',
            description: 'ëª¨í—˜ê°€ë‹˜, ê¸‰í•´ìš”! ì œê°€ ë§ˆì„ ì…êµ¬ì—ì„œ ê°•ë„ë¥¼ ë‹¹í–ˆëŠ”ë° ì§€ê°‘ì„ ë‹¤ í„¸ë ¸ì–´ìš”. ìˆ™ë°•ë¹„ 1ë§Œ5ì²œ ê³¨ë“œë§Œ ë¹Œë ¤ì£¼ì‹œë©´ ê³ í–¥ì— ê°€ì„œ ê¼­ ê°šì„ê²Œìš”!',
            emoji: 'ğŸ¥º',
            scamAmount: 15000
        }
    ]
};


// í˜ì‹ ì ì¸ ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ
const MARKET_EVENTS = [
    // ëª¬ìŠ¤í„° ê´€ë ¨ ì´ë²¤íŠ¸ (1-20)
    {
        id: 1,
        title: "í¬ë¦¬ìŠ¤íƒˆ ë™êµ´ì— ë‹¤ì´ì•„ ë‚˜ë¹„ ë–¼ ëŒ€ëŸ‰ ì¶œí˜„!",
        description: "ì±„êµ´ ì‘ì—… ì¼ì‹œ ì¤‘ë‹¨ë˜ì–´ í¬ë¦¬ìŠ¤íƒˆ ê³µê¸‰ ë¶€ì¡±",
        effects: [
            { company: 'crystal_mining', change: -25 },
            { company: 'potion_shop', change: 15 }
        ],
        triggers: ['monster_spawn_crystal_cave'],
        probability: 15
    },
    {
        id: 2,
        title: "ì†œì‚¬íƒ• êµ¬ë¦„ì„±ì—ì„œ ì²œì‚¬ ê³ ë˜ ëª©ê²©!",
        description: "ê´€ê´‘ê° ëª°ë ¤ë“¤ì–´ ì§€ì—­ ê²½ì œ í™œì„±í™”",
        effects: [
            { company: 'cotton_candy', change: 30 },
            { company: 'cloud_transport', change: 20 },
            { company: 'traveler_inn', change: 25 }
        ],
        triggers: ['rare_monster_sighting'],
        probability: 8
    },
    // ê°•í™” ê´€ë ¨ ì´ë²¤íŠ¸ (21-35) - +20ê°• ì´ìƒìœ¼ë¡œ ìˆ˜ì •
    {
        id: 21,
        title: "ì „ì„¤ì˜ +20ê°• ë‹¬ì„±! ì „êµ­ ê°•í™” ì—´í’ ì¬ì í™”",
        description: "ê°•í™”ì™•ì˜ ì—…ì ì— ëª¨í—˜ê°€ë“¤ì´ ì—´ê´‘í•˜ë©° ê°•í™” ê´€ë ¨ ì—…ê³„ ëŒ€í˜¸í™©",
        effects: [
            { company: 'crystal_processing', change: 60 },
            { company: 'dragon_weapons', change: 45 },
            { company: 'weapon_store', change: 40 },
            { company: 'potion_shop', change: 35 }
        ],
        triggers: ['player_enhancement_20_plus'],
        probability: 100 // í”Œë ˆì´ì–´ê°€ +20ê°• ë‹¬ì„±ì‹œ 100% ë°œìƒ
    },
    {
        id: 22,
        title: "ì—°ì† ê°•í™” ì‹¤íŒ¨ë¡œ ëª¨í—˜ê°€ë“¤ ì¢Œì ˆê° í™•ì‚°",
        description: "íë§ ì„œë¹„ìŠ¤ì™€ ìœ„ë¡œ ê´€ë ¨ ì—…ê³„ì— íŠ¹ìˆ˜ ë°œìƒ",
        effects: [
            { company: 'dream_healing', change: 35 },
            { company: 'angel_medical', change: 25 },
            { company: 'traveler_inn', change: 20 },
            { company: 'crystal_processing', change: -15 }
        ],
        triggers: ['multiple_enhancement_failures'],
        probability: 30
    },
    // ì‹œê°„ëŒ€ë³„ ì´ë²¤íŠ¸
    {
        id: 51,
        title: "ìƒˆë²½ì˜ ê³ ìš” ì† ì•¼í–‰ì„± ëª¬ìŠ¤í„° í™œë™ ì¦ê°€",
        description: "ë°¤ìƒ˜ ëª¨í—˜ê°€ë“¤ì„ ìœ„í•œ ì„œë¹„ìŠ¤ ìˆ˜ìš” ê¸‰ì¦",
        effects: [
            { company: 'potion_shop', change: 20 },
            { company: 'angel_medical', change: 15 }
        ],
        triggers: ['time_2_6'],
        probability: 60
    },
    {
        id: 52,
        title: "ì ì‹¬ì‹œê°„ ëŒ€í˜• ê¸¸ë“œë“¤ì˜ ë‹¨ì²´ ì‹ì‚¬",
        description: "ìŒì‹ ê´€ë ¨ ì—…ê³„ì™€ ì‚¬êµ ì„œë¹„ìŠ¤ í˜¸í™©",
        effects: [
            { company: 'cotton_candy', change: 25 },
            { company: 'traveler_inn', change: 20 }
        ],
        triggers: ['time_12_14'],
        probability: 40
    }
];

// í”Œë ˆì´ì–´ë³„ í¬íŠ¸í´ë¦¬ì˜¤ ì €ì¥ìš© ê¸€ë¡œë²Œ ë³€ìˆ˜
// global.playerPortfolios = new Map(); // ë” ì´ìƒ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ - ë°ì´í„°ë² ì´ìŠ¤ ì‚¬ìš©

// ğŸš€ í˜ì‹ ì ì¸ ì£¼ì‹ ì‹œìŠ¤í…œ í•µì‹¬ í•¨ìˆ˜ë“¤

// ëª¨ë“  íšŒì‚¬ ì£¼ì‹ ê°€ê²© ì—…ë°ì´íŠ¸ í•¨ìˆ˜
function updateStockPrices() {
    try {
        // ì‹œê°„ëŒ€ë³„ íš¨ê³¼ ì ìš©
        const hour = new Date().getHours();
        applyTimeBasedEffects(hour);
        
        // NPC ê°ì • ë³€í™” ì ìš©
        updateNPCEmotions();
        
        // ëœë¤ ì´ë²¤íŠ¸ ë°œìƒ í™•ì¸
        checkRandomEvents();
        
        // ê¸°ë³¸ ì‹œì¥ ë³€ë™ì„± ì ìš©
        applyBaseVolatility();
    } catch (error) {
        console.error('ì£¼ì‹ ê°€ê²© ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:', error);
    }
}

// NPC ê°ì • ë³€í™” í•¨ìˆ˜
function updateNPCEmotions() {
    const emotions = STOCK_MARKET.npc_emotions;
    
    // ì˜ë¢° ì„±ê³µ/ì‹¤íŒ¨ì— ë”°ë¥¸ NPC ê°ì • ë³€í™”
    Object.keys(emotions).forEach(npcType => {
        // ëœë¤ ê°ì • ë³€í™” (-5 ~ +5)
        Object.keys(emotions[npcType]).forEach(emotion => {
            emotions[npcType][emotion] += (Math.random() - 0.5) * 10;
            emotions[npcType][emotion] = Math.max(0, Math.min(100, emotions[npcType][emotion]));
        });
    });
    
    // ê°ì •ì— ë”°ë¥¸ ì£¼ì‹ ë³€ë™
    if (emotions.villagers.happiness > 70) {
        adjustStockPrice('traveler_inn', 0.25);
        adjustStockPrice('cotton_candy', 0.15);
    }
    
    if (emotions.merchants.greed > 80) {
        adjustStockPrice('weapon_store', 0.4);
        adjustStockPrice('potion_shop', 0.3);
    }
}

// ì‹œê°„ëŒ€ë³„ íš¨ê³¼ ì ìš©
function applyTimeBasedEffects(hour) {
    if (hour >= 2 && hour <= 6) {
        // ìƒˆë²½ ì‹œê°„ - ì•¼í–‰ì„± ì„œë¹„ìŠ¤ ìƒìŠ¹
        adjustStockPrice('potion_shop', 0.15);
        adjustStockPrice('angel_medical', 0.1);
    } else if (hour >= 12 && hour <= 14) {
        // ì ì‹¬ ì‹œê°„ - ìŒì‹ ê´€ë ¨ ìƒìŠ¹
        adjustStockPrice('cotton_candy', 0.2);
        adjustStockPrice('traveler_inn', 0.15);
    } else if (hour >= 18 && hour <= 22) {
        // ì €ë… ì‹œê°„ - ì—”í„°í…Œì¸ë¨¼íŠ¸ ìƒìŠ¹
        adjustStockPrice('fantasy_entertainment', 0.25);
        adjustStockPrice('dream_healing', 0.15);
    }
}

// ê°•í™” ì„±ê³µ/ì‹¤íŒ¨ ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±°
function triggerEnhancementEvent(enhanceLevel, success) {
    if (success && enhanceLevel >= 20) {
        // +20ê°• ì´ìƒ ì„±ê³µì‹œ ëŒ€í˜• ì´ë²¤íŠ¸
        triggerMarketEvent(21);
        STOCK_MARKET.market_state.player_actions.successful_enhancements++;
    } else if (!success) {
        // ê°•í™” ì‹¤íŒ¨ì‹œ íë§ ê´€ë ¨ì£¼ ìƒìŠ¹
        adjustStockPrice('dream_healing', 0.4);
        adjustStockPrice('angel_medical', 0.25);
    }
    
    STOCK_MARKET.market_state.player_actions.total_enhancement_attempts++;
}

// í”Œë ˆì´ì–´ í–‰ë™ ê¸°ë¡ í•¨ìˆ˜
function recordPlayerAction(actionType, details = {}) {
    const actions = STOCK_MARKET.market_state.player_actions;
    
    switch(actionType) {
        case 'shop_purchase':
            actions.shop_purchases++;
            adjustStockPrice('general_store', 0.05);
            break;
        case 'hunt_start':
            actions.hunt_sessions++;
            adjustStockPrice('weapon_store', 0.1);
            adjustStockPrice('potion_shop', 0.1);
            break;
        case 'legendary_craft':
            actions.legendary_crafts++;
            adjustStockPrice('creation_tech', 1);
            break;
        case 'racing_event':
            // ë ˆì´ì‹± ì´ë²¤íŠ¸ê°€ ì£¼ì‹ ì‹œì¥ì— ë¯¸ì¹˜ëŠ” ì˜í–¥
            if (details.potSize > 30000) {
                adjustStockPrice('fantasy_entertainment', 0.75); // ì—”í„°í…Œì¸ë¨¼íŠ¸
                adjustStockPrice('traveler_inn', 0.5);           // ì—¬ê´€ì—…
            }
            if (details.participants >= 6) {
                adjustStockPrice('aurora_tourism', 0.4); // ê´€ê´‘ì—…
            }
            break;
    }
}

// ëœë¤ ì´ë²¤íŠ¸ ì²´í¬
function checkRandomEvents() {
    MARKET_EVENTS.forEach(event => {
        if (Math.random() * 100 < event.probability) {
            triggerMarketEvent(event.id);
        }
    });
}

// ë§ˆì¼“ ì´ë²¤íŠ¸ ë°œìƒ í•¨ìˆ˜
function triggerMarketEvent(eventId) {
    const event = MARKET_EVENTS.find(e => e.id === eventId);
    if (!event) return;
    
    // ì´ë²¤íŠ¸ íš¨ê³¼ ì ìš©
    event.effects.forEach(effect => {
        adjustStockPrice(effect.company, effect.change);
    });
    
    // ê¸€ë¡œë²Œ ì±„ë„ì— ë‰´ìŠ¤ ë°œì†¡ (ë‚˜ì¤‘ì— êµ¬í˜„)
    console.log(`ğŸ“° ë§ˆì¼“ ë‰´ìŠ¤: ${event.title}`);
    
    return event;
}

// ì£¼ì‹ ê°€ê²© ì¡°ì • í•¨ìˆ˜
function adjustStockPrice(companyId, changePercent) {
    // ì§€ì—­ ê¸°ì—…ë“¤ í™•ì¸
    for (const region of Object.values(STOCK_MARKET.regions)) {
        const company = region.companies.find(c => c.id === companyId);
        if (company) {
            const oldPrice = company.price;
            company.price = Math.max(50, Math.floor(company.price * (1 + changePercent / 100)));
            company.change = ((company.price - oldPrice) / oldPrice * 100);
            company.volume += Math.floor(Math.random() * 1000) + 100;
            return;
        }
    }
    
    // ì²´ì¸ ê¸°ì—…ë“¤ í™•ì¸
    const chainCompany = STOCK_MARKET.chains.find(c => c.id === companyId);
    if (chainCompany) {
        const oldPrice = chainCompany.price;
        chainCompany.price = Math.max(50, Math.floor(chainCompany.price * (1 + changePercent / 100)));
        chainCompany.change = ((chainCompany.price - oldPrice) / oldPrice * 100);
        chainCompany.volume += Math.floor(Math.random() * 1000) + 100;
    }
}

// ê¸°ë³¸ ì‹œì¥ ë³€ë™ì„± ì ìš© (ë°¸ëŸ°ìŠ¤ ì¡°ì •)
function applyBaseVolatility() {
    const volatility = STOCK_MARKET.market_state.volatility;
    
    // ëª¨ë“  ì£¼ì‹ì— ê¸°ë³¸ ëœë¤ ë³€ë™ ì ìš© (ë³€ë™í­ ëŒ€í­ ì¶•ì†Œ)
    for (const region of Object.values(STOCK_MARKET.regions)) {
        region.companies.forEach(company => {
            // ê¸°ì¡´ volatility / 10ì—ì„œ volatility / 200ìœ¼ë¡œ ë³€ê²½ (20ë°° ê°ì†Œ)
            const randomChange = (Math.random() - 0.5) * (volatility / 200);
            adjustStockPrice(company.id, randomChange);
        });
    }
    
    STOCK_MARKET.chains.forEach(company => {
        // ê¸°ì¡´ volatility / 10ì—ì„œ volatility / 200ìœ¼ë¡œ ë³€ê²½ (20ë°° ê°ì†Œ)
        const randomChange = (Math.random() - 0.5) * (volatility / 200);
        adjustStockPrice(company.id, randomChange);
    });
}

// í¬íŠ¸í´ë¦¬ì˜¤ ê´€ë¦¬ í•¨ìˆ˜ë“¤
async function getPlayerPortfolio(userId) {
    try {
        // ì‹¤ì œ ìœ ì € ë°ì´í„°ì—ì„œ ê³¨ë“œì™€ ì£¼ì‹ í¬íŠ¸í´ë¦¬ì˜¤ë¥¼ ê°€ì ¸ì˜¤ê¸°
        const user = await User.findOne({ discordId: userId }).select('gold stockPortfolio');
        const userGold = user ? user.gold : 0;
        
        // ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì£¼ì‹ í¬íŠ¸í´ë¦¬ì˜¤ ë¡œë“œ
        const portfolio = {
            cash: userGold,
            stocks: new Map(),
            totalValue: userGold
        };
        
        if (user && user.stockPortfolio && user.stockPortfolio.stocks) {
            // Map ë°ì´í„°ë¥¼ ë³µì›
            for (const [companyId, stockData] of user.stockPortfolio.stocks) {
                portfolio.stocks.set(companyId, {
                    shares: stockData.shares,
                    avgPrice: stockData.avgPrice
                });
            }
        }
        
        return portfolio;
    } catch (error) {
        console.error('í¬íŠ¸í´ë¦¬ì˜¤ ë¡œë“œ ì˜¤ë¥˜:', error);
        // ê¸°ë³¸ í¬íŠ¸í´ë¦¬ì˜¤ ë°˜í™˜
        return {
            cash: 0,
            stocks: new Map(),
            totalValue: 0
        };
    }
}

async function buyStock(userId, companyId, shares) {
    const portfolio = await getPlayerPortfolio(userId);
    const company = findCompany(companyId);
    
    if (!company) return { success: false, message: 'ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê¸°ì—…ì…ë‹ˆë‹¤!' };
    
    const totalCost = company.price * shares;
    if (portfolio.cash < totalCost) {
        return { success: false, message: 'ìê¸ˆì´ ë¶€ì¡±í•©ë‹ˆë‹¤!' };
    }
    
    // ì‹¤ì œ ìœ ì € ê³¨ë“œ ì°¨ê° ë° í¬íŠ¸í´ë¦¬ì˜¤ ì—…ë°ì´íŠ¸ (ì›ìì  ì—…ë°ì´íŠ¸)
    const updateResult = await User.updateOne(
        { 
            discordId: userId, 
            gold: { $gte: totalCost } // ì¶©ë¶„í•œ ê³¨ë“œê°€ ìˆëŠ” ê²½ìš°ë§Œ ì—…ë°ì´íŠ¸
        },
        {
            $inc: { 
                gold: -totalCost,
                'stockPortfolio.totalInvested': totalCost
            },
            $set: { 'stockPortfolio.lastUpdate': new Date() }
        }
    );
    
    if (updateResult.matchedCount === 0) {
        return { success: false, message: 'ìê¸ˆì´ ë¶€ì¡±í•©ë‹ˆë‹¤!' };
    }
    
    // ì£¼ì‹ ë³´ìœ ëŸ‰ ì—…ë°ì´íŠ¸
    const user = await User.findOne({ discordId: userId });
    if (!user.stockPortfolio) {
        user.stockPortfolio = { stocks: new Map(), totalInvested: 0, lastUpdate: new Date() };
    }
    
    const currentStock = user.stockPortfolio.stocks.get(companyId);
    if (currentStock) {
        // ê¸°ì¡´ ì£¼ì‹ì´ ìˆìœ¼ë©´ í‰ê· ê°€ ê³„ì‚°
        const newAvgPrice = (currentStock.avgPrice * currentStock.shares + totalCost) / (currentStock.shares + shares);
        user.stockPortfolio.stocks.set(companyId, {
            shares: currentStock.shares + shares,
            avgPrice: newAvgPrice
        });
    } else {
        // ìƒˆë¡œìš´ ì£¼ì‹
        user.stockPortfolio.stocks.set(companyId, {
            shares: shares,
            avgPrice: company.price
        });
    }
    
    await user.save();
    
    // ê±°ë˜ëŸ‰ ì¦ê°€
    company.volume += shares;
    
    return { success: true, message: `${company.name} ${shares}ì£¼ë¥¼ ${totalCost.toLocaleString()}ê³¨ë“œì— ë§¤ìˆ˜í–ˆìŠµë‹ˆë‹¤!` };
}

async function sellStock(userId, companyId, shares) {
    const portfolio = await getPlayerPortfolio(userId);
    const company = findCompany(companyId);
    
    if (!company) return { success: false, message: 'ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê¸°ì—…ì…ë‹ˆë‹¤!' };
    if (!portfolio.stocks.has(companyId)) return { success: false, message: 'ë³´ìœ í•˜ì§€ ì•Šì€ ì£¼ì‹ì…ë‹ˆë‹¤!' };
    
    const holding = portfolio.stocks.get(companyId);
    if (holding.shares < shares) return { success: false, message: 'ë³´ìœ  ìˆ˜ëŸ‰ì´ ë¶€ì¡±í•©ë‹ˆë‹¤!' };
    
    // ë§¤ë„ ì‹¤í–‰
    const totalValue = company.price * shares;
    
    // ì‹¤ì œ ìœ ì € ê³¨ë“œ ì¦ê°€ (ì›ìì  ì—…ë°ì´íŠ¸)
    await User.updateOne(
        { discordId: userId },
        { $inc: { gold: totalValue } }
    );
    
    // ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì£¼ì‹ ë³´ìœ ëŸ‰ ì—…ë°ì´íŠ¸
    const user = await User.findOne({ discordId: userId });
    const currentStock = user.stockPortfolio.stocks.get(companyId);
    
    if (currentStock.shares <= shares) {
        // ëª¨ë“  ì£¼ì‹ì„ ë§¤ë„í•˜ëŠ” ê²½ìš°
        user.stockPortfolio.stocks.delete(companyId);
    } else {
        // ì¼ë¶€ë§Œ ë§¤ë„í•˜ëŠ” ê²½ìš°
        user.stockPortfolio.stocks.set(companyId, {
            shares: currentStock.shares - shares,
            avgPrice: currentStock.avgPrice // í‰ê· ê°€ëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€
        });
    }
    
    user.stockPortfolio.lastUpdate = new Date();
    await user.save();
    
    // ê±°ë˜ëŸ‰ ì¦ê°€
    company.volume += shares;
    
    return { success: true, message: `${company.name} ${shares}ì£¼ë¥¼ ${totalValue.toLocaleString()}ê³¨ë“œì— ë§¤ë„í–ˆìŠµë‹ˆë‹¤!` };
}

function findCompany(companyId) {
    // ì§€ì—­ ê¸°ì—…ë“¤ ê²€ìƒ‰
    for (const region of Object.values(STOCK_MARKET.regions)) {
        const company = region.companies.find(c => c.id === companyId);
        if (company) return company;
    }
    
    // ì²´ì¸ ê¸°ì—…ë“¤ ê²€ìƒ‰
    const chainCompany = STOCK_MARKET.chains.find(c => c.id === companyId);
    if (chainCompany) return chainCompany;
    
    // ìœ ë¬¼íƒì‚¬íšŒì‚¬ë“¤ ê²€ìƒ‰
    return STOCK_MARKET.exploration_companies.find(c => c.id === companyId);
}

// ğŸº ìœ ë¬¼íƒì‚¬ ì‹œìŠ¤í…œ í•¨ìˆ˜ë“¤

// ìœ ë¬¼íƒì‚¬ ë©”ì¸ ë©”ë‰´ í‘œì‹œ
async function showArtifactExplorationMenu(interaction, user) {
    try {
        const stats = user.explorationStats || {
            totalExplorations: 0,
            totalInvested: 0,
            totalEarned: 0,
            successfulFinds: 0,
            rareFinds: 0
        };
        
        const profitLoss = stats.totalEarned - stats.totalInvested;
        const successRate = stats.totalExplorations > 0 ? 
            ((stats.successfulFinds / stats.totalExplorations) * 100).toFixed(1) : 0;
            
        const embed = new EmbedBuilder()
            .setColor('#f39c12')
            .setTitle('ğŸº ê¹€í—Œí„° ìœ ë¬¼íƒì‚¬ ì„¼í„°')
            .setDescription(`**ì‹ ë¹„í•œ ê³ ëŒ€ ìœ ë¬¼ì„ ì°¾ì•„ ë– ë‚˜ëŠ” ëª¨í—˜!**\n\nê³ ëŒ€ ë¬¸ëª…ì˜ ë³´ë¬¼ì´ ë‹¹ì‹ ì„ ê¸°ë‹¤ë¦¬ê³  ìˆìŠµë‹ˆë‹¤.\nê° ì§€ì—­ì˜ ì „ë¬¸ íƒì‚¬íšŒì‚¬ì™€ í•¨ê»˜ ìœ„í—˜í•˜ì§€ë§Œ ìˆ˜ìµì„± ë†’ì€ ëª¨í—˜ì„ ì‹œì‘í•˜ì„¸ìš”!`)
            .addFields(
                { name: 'ğŸ“Š íƒì‚¬ í†µê³„', value: `ì´ íƒì‚¬: ${stats.totalExplorations}íšŒ\nì„±ê³µë¥ : ${successRate}%\ní¬ê·€ ë°œê²¬: ${stats.rareFinds}ê°œ`, inline: true },
                { name: 'ğŸ’° ìˆ˜ìµ í˜„í™©', value: `íˆ¬ì: ${stats.totalInvested.toLocaleString()}G\nìˆ˜ìµ: ${stats.totalEarned.toLocaleString()}G\nìˆœìµ: ${profitLoss >= 0 ? '+' : ''}${profitLoss.toLocaleString()}G`, inline: true },
                { name: 'ğŸ’ í˜„ì¬ ìƒíƒœ', value: `ë³´ìœ  ê³¨ë“œ: ${user.gold.toLocaleString()}G\nìœ ë¬¼ ë³´ê´€: ${user.artifacts ? user.artifacts.length : 0}ê°œ\në ˆë²¨: ${user.level}`, inline: true }
            )
            .setFooter({ text: 'âš ï¸ ìœ ë¬¼íƒì‚¬ëŠ” ê³ ìœ„í—˜ ê³ ìˆ˜ìµ íˆ¬ìì…ë‹ˆë‹¤! ì‹ ì¤‘í•˜ê²Œ ì„ íƒí•˜ì„¸ìš”.' });

        const menuButtons = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('artifact_direct_explore')
                    .setLabel('â›ï¸ ì§ì ‘ íƒì‚¬')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId('artifact_companies')
                    .setLabel('ğŸ¢ íƒì‚¬íšŒì‚¬ íˆ¬ì')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId('artifact_inventory')
                    .setLabel('ğŸ’ ìœ ë¬¼ ë³´ê´€í•¨')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId('artifact_shop')
                    .setLabel('ğŸª ìœ ë¬¼ ìƒì ')
                    .setStyle(ButtonStyle.Success)
            );

        const extraButtons = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('artifact_rankings')
                    .setLabel('ğŸ† íƒì‚¬ê°€ ë­í‚¹')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId('artifact_guide')
                    .setLabel('ğŸ“– íƒì‚¬ ê°€ì´ë“œ')
                    .setStyle(ButtonStyle.Secondary)
            );

        await interaction.reply({
            embeds: [embed],
            components: [menuButtons, extraButtons],
            flags: 64
        });
        
    } catch (error) {
        console.error('ìœ ë¬¼íƒì‚¬ ë©”ë‰´ í‘œì‹œ ì˜¤ë¥˜:', error);
        await interaction.reply({ content: 'âŒ ë©”ë‰´ ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤!', flags: 64 });
    }
}

// ì§ì ‘ íƒì‚¬ ë©”ë‰´
async function showDirectExplorationMenu(interaction, user) {
    try {
        const companies = ARTIFACT_SYSTEM.companies;
        
        let companyList = '';
        for (const [id, company] of Object.entries(companies)) {
            const costs = ARTIFACT_SYSTEM.explorationCosts[company.specialty];
            companyList += `${company.emoji} **${company.name}**\n`;
            companyList += `   ì§€ì—­: ${company.region}\n`;
            companyList += `   ì„±ê³µë¥ : ${(company.successRate * 100).toFixed(1)}%\n`;
            companyList += `   ë¹„ìš©: ${costs.min.toLocaleString()} ~ ${costs.max.toLocaleString()}G\n\n`;
        }
        
        const embed = new EmbedBuilder()
            .setColor('#e67e22')
            .setTitle('â›ï¸ ì§ì ‘ ìœ ë¬¼ íƒì‚¬')
            .setDescription('íƒì‚¬íšŒì‚¬ë¥¼ ì„ íƒí•˜ì—¬ ì§ì ‘ ìœ ë¬¼ì„ ì°¾ì•„ë³´ì„¸ìš”!\nê° ì§€ì—­ë§ˆë‹¤ íŠ¹ë³„í•œ ìœ ë¬¼ê³¼ ìœ„í—˜ì´ ê¸°ë‹¤ë¦¬ê³  ìˆìŠµë‹ˆë‹¤.')
            .addFields(
                { name: 'ğŸ—ºï¸ íƒì‚¬ ì§€ì—­ & íšŒì‚¬', value: companyList, inline: false },
                { name: 'ğŸ’¡ íƒì‚¬ íŒ', value: 'â€¢ ì„±ê³µë¥ ì´ ë†’ì„ìˆ˜ë¡ ì•ˆì „í•˜ì§€ë§Œ ìˆ˜ìµë¥ ì€ ë‚®ìŠµë‹ˆë‹¤\nâ€¢ ìœ„í—˜í•œ ì§€ì—­ì¼ìˆ˜ë¡ ë ˆì–´ ìœ ë¬¼ í™•ë¥ ì´ ë†’ìŠµë‹ˆë‹¤\nâ€¢ íˆ¬ì ê¸ˆì•¡ì´ í´ìˆ˜ë¡ ë” ì¢‹ì€ ìœ ë¬¼ì„ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤', inline: false }
            );

        const companyButtons = new ActionRowBuilder();
        let buttonCount = 0;
        for (const [id, company] of Object.entries(companies)) {
            if (buttonCount < 5) {
                companyButtons.addComponents(
                    new ButtonBuilder()
                        .setCustomId(`explore_${id}`)
                        .setLabel(`${company.emoji} ${company.name}`)
                        .setStyle(ButtonStyle.Primary)
                );
                buttonCount++;
            }
        }

        const backButton = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('artifact_main_menu')
                    .setLabel('ğŸ”™ ë©”ì¸ ë©”ë‰´')
                    .setStyle(ButtonStyle.Secondary)
            );

        await interaction.update({
            embeds: [embed],
            components: [companyButtons, backButton]
        });
        
    } catch (error) {
        console.error('ì§ì ‘ íƒì‚¬ ë©”ë‰´ ì˜¤ë¥˜:', error);
        await interaction.followUp({ content: 'âŒ íƒì‚¬ ë©”ë‰´ ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤!', flags: 64 });
    }
}

// ìœ ë¬¼ ë°œêµ´ ì‹¤í–‰
async function executeExploration(interaction, user, companyId, investmentAmount) {
    try {
        const company = ARTIFACT_SYSTEM.companies[companyId];
        if (!company) {
            await interaction.editReply({ content: 'âŒ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” íƒì‚¬íšŒì‚¬ì…ë‹ˆë‹¤!' });
            return;
        }
        
        // ê³¨ë“œ í™•ì¸
        if (user.gold < investmentAmount) {
            await interaction.editReply({ content: 'âŒ ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!' });
            return;
        }
        
        // ê³¨ë“œ ì°¨ê°
        await User.updateOne(
            { discordId: interaction.user.id },
            { 
                $inc: { 
                    gold: -investmentAmount,
                    'explorationStats.totalExplorations': 1,
                    'explorationStats.totalInvested': investmentAmount
                },
                $set: { 'explorationStats.lastExploration': new Date() }
            }
        );
        
        // íƒì‚¬ ê²°ê³¼ ê³„ì‚°
        const result = calculateExplorationResult(company, investmentAmount);
        
        // ê²°ê³¼ì— ë”°ë¥¸ ì²˜ë¦¬
        let embed;
        
        if (result.success) {
            // ì„±ê³µ - ìœ ë¬¼ ë°œê²¬
            const artifact = result.artifact;
            
            // ìœ ë¬¼ì„ ì¸ë²¤í† ë¦¬ì— ì¶”ê°€
            const artifactValue = Array.isArray(artifact.value) 
                ? Math.floor(Math.random() * (artifact.value[1] - artifact.value[0] + 1)) + artifact.value[0]
                : artifact.value;
                
            await User.updateOne(
                { discordId: interaction.user.id },
                { 
                    $push: { 
                        artifacts: {
                            name: artifact.name,
                            emoji: artifact.emoji,
                            rarity: result.rarity,
                            value: artifactValue,
                            baseValue: artifactValue, // ê¸°ë³¸ ê°€ì¹˜ ì¶”ê°€
                            currentPrice: artifactValue, // í˜„ì¬ ì‹œì„¸ ì¶”ê°€
                            description: artifact.description,
                            foundDate: new Date(),
                            company: company.name,
                            region: company.region
                        }
                    },
                    $inc: { 
                        'explorationStats.successfulFinds': 1,
                        'explorationStats.totalEarned': artifactValue,
                        'explorationStats.biggestFind': artifactValue > (user.explorationStats?.biggestFind || 0) ? artifactValue - (user.explorationStats?.biggestFind || 0) : 0
                    }
                }
            );
            
            if (result.rarity !== 'common') {
                await User.updateOne(
                    { discordId: interaction.user.id },
                    { $inc: { 'explorationStats.rareFinds': 1 } }
                );
            }
            
            // ì£¼ì‹ ê°€ê²©ì— ì˜í–¥
            updateExplorationCompanyStock(companyId, true, result.rarity);
            
            embed = new EmbedBuilder()
                .setColor(getRarityColor(result.rarity))
                .setTitle('ğŸ‰ ìœ ë¬¼ ë°œê²¬ ì„±ê³µ!')
                .setDescription(result.story)
                .addFields(
                    { name: `${artifact.emoji} ë°œê²¬í•œ ìœ ë¬¼`, value: `**${artifact.name}**\n${artifact.description}`, inline: false },
                    { name: 'ğŸ’ ë“±ê¸‰', value: getRarityText(result.rarity), inline: true },
                    { name: 'ğŸ’° ì¶”ì • ê°€ì¹˜', value: `${artifact.value.toLocaleString()}G`, inline: true },
                    { name: 'ğŸ“ ë°œê²¬ ì§€ì—­', value: `${company.emoji} ${company.region}`, inline: true }
                )
                .setFooter({ text: 'ìœ ë¬¼ì„ ìƒì ì— íŒë§¤í•˜ê±°ë‚˜ ë³´ê´€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!' });
                
        } else {
            // ì‹¤íŒ¨
            updateExplorationCompanyStock(companyId, false);
            
            embed = new EmbedBuilder()
                .setColor('#e74c3c')
                .setTitle('ğŸ’¸ íƒì‚¬ ì‹¤íŒ¨...')
                .setDescription(result.story)
                .addFields(
                    { name: 'ğŸ’” ê²°ê³¼', value: `${result.failure.emoji} ${result.failure.name}\n${result.failure.description}`, inline: false },
                    { name: 'ğŸ“‰ ì†ì‹¤', value: `${investmentAmount.toLocaleString()}G`, inline: true },
                    { name: 'ğŸ“ íƒì‚¬ ì§€ì—­', value: `${company.emoji} ${company.region}`, inline: true }
                )
                .setFooter({ text: 'ë‹¤ìŒ íƒì‚¬ì—ì„œëŠ” ë” ì¢‹ì€ ê²°ê³¼ê°€ ìˆê¸°ë¥¼!' });
        }
        
        const retryButton = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('artifact_direct_explore')
                    .setLabel('ğŸ”„ ë‹¤ì‹œ íƒì‚¬')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId('artifact_inventory')
                    .setLabel('ğŸ’ ìœ ë¬¼ ë³´ê´€í•¨')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId('artifact_main_menu')
                    .setLabel('ğŸ  ë©”ì¸ ë©”ë‰´')
                    .setStyle(ButtonStyle.Secondary)
            );
            
        await interaction.editReply({
            embeds: [embed],
            components: [retryButton]
        });
        
    } catch (error) {
        console.error('ìœ ë¬¼ íƒì‚¬ ì‹¤í–‰ ì˜¤ë¥˜:', error);
        await interaction.editReply({ content: 'âŒ íƒì‚¬ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤!' });
    }
}

// íƒì‚¬ ê²°ê³¼ ê³„ì‚°
function calculateExplorationResult(company, investment) {
    const baseSuccessRate = company.successRate;
    
    // íˆ¬ì ê¸ˆì•¡ì— ë”°ë¥¸ ì„±ê³µë¥  ë³´ë„ˆìŠ¤ (ìµœëŒ€ +20%)
    const costs = ARTIFACT_SYSTEM.explorationCosts[company.specialty];
    const investmentRatio = (investment - costs.min) / (costs.max - costs.min);
    const investmentBonus = Math.min(0.2, investmentRatio * 0.2);
    
    const finalSuccessRate = baseSuccessRate + investmentBonus;
    const random = Math.random();
    
    if (random <= finalSuccessRate) {
        // ì„±ê³µ - ìœ ë¬¼ ë°œê²¬
        const rarityRoll = Math.random();
        let rarity, artifacts;
        
        if (rarityRoll <= 0.02) { // 2% ë ˆì „ë“œë¦¬
            rarity = 'legendary';
            artifacts = ARTIFACT_SYSTEM.artifacts.legendary;
        } else if (rarityRoll <= 0.10) { // 8% ì—í”½
            rarity = 'epic';
            artifacts = ARTIFACT_SYSTEM.artifacts.epic;
        } else if (rarityRoll <= 0.30) { // 20% ë ˆì–´
            rarity = 'rare';
            artifacts = ARTIFACT_SYSTEM.artifacts.rare;
        } else { // 70% ì»¤ë¨¼
            rarity = 'common';
            artifacts = ARTIFACT_SYSTEM.artifacts.common;
        }
        
        // íŠ¹í™” ìœ ë¬¼ í™•ì¸
        const specialArtifacts = ARTIFACT_SYSTEM.specialArtifacts[company.specialty];
        if (specialArtifacts && Math.random() <= 0.05) { // 5% í™•ë¥ ë¡œ íŠ¹í™” ìœ ë¬¼
            const specialArtifact = specialArtifacts[Math.floor(Math.random() * specialArtifacts.length)];
            artifacts = [specialArtifact];
            rarity = specialArtifact.rarity;
        }
        
        const artifact = artifacts[Math.floor(Math.random() * artifacts.length)];
        const value = Array.isArray(artifact.value) ? 
            Math.floor(Math.random() * (artifact.value[1] - artifact.value[0] + 1)) + artifact.value[0] :
            artifact.value;
            
        // íˆ¬ì ê¸ˆì•¡ì— ë”°ë¥¸ ê°€ì¹˜ ë³´ë„ˆìŠ¤
        const valueMultiplier = 1 + (investmentRatio * 0.5); // ìµœëŒ€ 50% ë³´ë„ˆìŠ¤
        const finalValue = Math.floor(value * valueMultiplier);
        
        const story = ARTIFACT_SYSTEM.stories.success[rarity][
            Math.floor(Math.random() * ARTIFACT_SYSTEM.stories.success[rarity].length)
        ];
        
        return {
            success: true,
            rarity: rarity,
            artifact: {
                ...artifact,
                value: finalValue
            },
            story: story
        };
    } else {
        // ì‹¤íŒ¨
        const failure = ARTIFACT_SYSTEM.failures[Math.floor(Math.random() * ARTIFACT_SYSTEM.failures.length)];
        const story = ARTIFACT_SYSTEM.stories.failure[Math.floor(Math.random() * ARTIFACT_SYSTEM.stories.failure.length)];
        
        return {
            success: false,
            failure: failure,
            story: story
        };
    }
}

// ë“±ê¸‰ë³„ ìƒ‰ìƒ
function getRarityColor(rarity) {
    switch (rarity) {
        case 'common': return '#95a5a6';
        case 'rare': return '#3498db';
        case 'epic': return '#9b59b6';
        case 'legendary': return '#f1c40f';
        default: return '#95a5a6';
    }
}

// ë“±ê¸‰ë³„ í…ìŠ¤íŠ¸
function getRarityText(rarity) {
    switch (rarity) {
        case 'common': return 'ğŸ¤ ì¼ë°˜';
        case 'rare': return 'ğŸ’™ í¬ê·€';
        case 'epic': return 'ğŸ’œ ì—í”½';
        case 'legendary': return 'ğŸ’› ì „ì„¤';
        default: return 'ğŸ¤ ì¼ë°˜';
    }
}

// íƒì‚¬íšŒì‚¬ ì£¼ì‹ ê°€ê²© ì—…ë°ì´íŠ¸
function updateExplorationCompanyStock(companyId, success, rarity = 'common') {
    const companies = STOCK_MARKET.exploration_companies;
    const company = companies.find(c => c.id === companyId);
    
    if (company) {
        let priceChange = 0;
        
        if (success) {
            switch (rarity) {
                case 'common': priceChange = 0.05; break;
                case 'rare': priceChange = 0.15; break;
                case 'epic': priceChange = 0.4; break;
                case 'legendary': priceChange = 0.75; break;
            }
        } else {
            priceChange = -0.1; // ì‹¤íŒ¨ ì‹œ ì£¼ê°€ í•˜ë½
        }
        
        adjustStockPrice(companyId, priceChange);
    }
}

// ì°¨íŠ¸ ë°ì´í„° ì—…ë°ì´íŠ¸ í•¨ìˆ˜
function updateChartData() {
    const now = new Date();
    const timestamp = now.toLocaleTimeString('ko-KR', { 
        hour: '2-digit', 
        minute: '2-digit' 
    });
    
    // ì „ì²´ ì‹œì¥ ì§€ìˆ˜ ê³„ì‚°
    let totalValue = 0;
    let companyCount = 0;
    const topCompanies = [];
    
    // ëª¨ë“  ê¸°ì—… ê°€ê²© ìˆ˜ì§‘
    for (const region of Object.values(STOCK_MARKET.regions)) {
        for (const company of region.companies) {
            totalValue += company.price;
            companyCount++;
            topCompanies.push(company);
        }
    }
    
    for (const company of STOCK_MARKET.chains) {
        totalValue += company.price;
        companyCount++;
        topCompanies.push(company);
    }
    
    const marketIndex = Math.round(totalValue / companyCount);
    
    // ì°¨íŠ¸ íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸
    STOCK_MARKET.chart_history.timestamps.push(timestamp);
    STOCK_MARKET.chart_history.market_index.push(marketIndex);
    
    // ëª¨ë“  ê¸°ì—… ì¶”ì  (ì°¨íŠ¸ í‘œì‹œìš©)
    for (const company of topCompanies) {
        if (!STOCK_MARKET.chart_history.top_companies[company.id]) {
            STOCK_MARKET.chart_history.top_companies[company.id] = [];
        }
        STOCK_MARKET.chart_history.top_companies[company.id].push(company.price);
    }
    
    // ìµœëŒ€ 50ê°œ ë°ì´í„°í¬ì¸íŠ¸ ìœ ì§€
    const maxPoints = 50;
    if (STOCK_MARKET.chart_history.timestamps.length > maxPoints) {
        STOCK_MARKET.chart_history.timestamps = STOCK_MARKET.chart_history.timestamps.slice(-maxPoints);
        STOCK_MARKET.chart_history.market_index = STOCK_MARKET.chart_history.market_index.slice(-maxPoints);
        
        for (const companyId in STOCK_MARKET.chart_history.top_companies) {
            STOCK_MARKET.chart_history.top_companies[companyId] = 
                STOCK_MARKET.chart_history.top_companies[companyId].slice(-maxPoints);
        }
    }
}

// ì •ê¸°ì ìœ¼ë¡œ ì£¼ì‹ ê°€ê²© ì—…ë°ì´íŠ¸ (5ë¶„ë§ˆë‹¤)
intervals.push(setInterval(() => {
    updateStockPrices();
    updateChartData();
}, 5 * 60 * 1000));

// ì´ˆê¸° ì°¨íŠ¸ ë°ì´í„° ìƒì„±
updateChartData();

// ì„ì‹œ: ì°¨íŠ¸ ë°ì´í„° ë¹ ë¥´ê²Œ ì±„ìš°ê¸° (ê°œë°œìš©) - ë©”ëª¨ë¦¬ ìµœì í™”
function fillChartDataForDevelopment() {
    console.log('ì°¨íŠ¸ ë°ì´í„° ì´ˆê¸°í™” ì¤‘...');
    // ìµœê·¼ 60ë¶„ ë°ì´í„°ë¥¼ ì‹œë®¬ë ˆì´ì…˜ (5ë¶„ ê°„ê²©ìœ¼ë¡œ 12ê°œ)
    for (let i = 0; i < 12; i++) {
        updateStockPrices();
        updateChartData();
    }
    console.log('ì°¨íŠ¸ ë°ì´í„° ì´ˆê¸°í™” ì™„ë£Œ!');
    console.log('íƒ€ì„ìŠ¤íƒ¬í”„:', STOCK_MARKET.chart_history.timestamps.length);
    console.log('ì‹œì¥ ì§€ìˆ˜:', STOCK_MARKET.chart_history.market_index.length);
}

// ë´‡ ì‹œì‘ì‹œ ì°¨íŠ¸ ë°ì´í„° ì±„ìš°ê¸°
setTimeout(() => {
    fillChartDataForDevelopment();
}, 2000);

// ìœ ë¬¼ ì‹œì„¸ ì‹œìŠ¤í…œ
const artifactMarket = {
    priceHistory: new Map(), // ìœ ë¬¼ë³„ ê°€ê²© ê¸°ë¡
    currentEvent: null,
    lastUpdate: Date.now()
};

// ìœ ë¬¼ ì‹œì„¸ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
function updateArtifactPrices() {
    const now = Date.now();
    const hour = new Date().getHours();
    
    // ì‹œê°„ëŒ€ë³„ ë³´ì •ê°’ ì ìš©
    let timeMultiplier = 1.0;
    if (hour >= 6 && hour < 12) {
        timeMultiplier = ARTIFACT_SYSTEM.marketSystem.timeMultiplier.morning;
    } else if (hour >= 12 && hour < 18) {
        timeMultiplier = ARTIFACT_SYSTEM.marketSystem.timeMultiplier.afternoon;
    } else if (hour >= 18 && hour < 24) {
        timeMultiplier = ARTIFACT_SYSTEM.marketSystem.timeMultiplier.evening;
    } else {
        timeMultiplier = ARTIFACT_SYSTEM.marketSystem.timeMultiplier.night;
    }
    
    // ì‹œì¥ ì´ë²¤íŠ¸ í™•ì¸
    if (!artifactMarket.currentEvent || now - artifactMarket.currentEvent.startTime > artifactMarket.currentEvent.duration) {
        // ìƒˆë¡œìš´ ì´ë²¤íŠ¸ ë°œìƒ (10% í™•ë¥ )
        if (Math.random() < 0.1) {
            const events = ARTIFACT_SYSTEM.marketSystem.marketFactors;
            artifactMarket.currentEvent = {
                ...events[Math.floor(Math.random() * events.length)],
                startTime: now
            };
            console.log(`ìœ ë¬¼ ì‹œì¥ ì´ë²¤íŠ¸ ë°œìƒ: ${artifactMarket.currentEvent.name}`);
        } else {
            artifactMarket.currentEvent = null;
        }
    }
    
    // ëª¨ë“  ìœ ë¬¼ ì¢…ë¥˜ì— ëŒ€í•´ ì‹œì„¸ ì—…ë°ì´íŠ¸
    const allArtifacts = [
        ...ARTIFACT_SYSTEM.artifacts.common,
        ...ARTIFACT_SYSTEM.artifacts.rare,
        ...ARTIFACT_SYSTEM.artifacts.epic,
        ...ARTIFACT_SYSTEM.artifacts.legendary
    ];
    
    allArtifacts.forEach(artifact => {
        if (!artifactMarket.priceHistory.has(artifact.name)) {
            artifactMarket.priceHistory.set(artifact.name, {
                prices: [],
                currentPrice: (artifact.value[0] + artifact.value[1]) / 2
            });
        }
        
        const history = artifactMarket.priceHistory.get(artifact.name);
        const rarity = getRarityByArtifact(artifact.name);
        const volatility = ARTIFACT_SYSTEM.marketSystem.volatility[rarity] || 0.15;
        
        // ê°€ê²© ë³€ë™ ê³„ì‚°
        let priceChange = (Math.random() - 0.5) * 2 * volatility;
        priceChange *= timeMultiplier;
        
        // ì´ë²¤íŠ¸ ì ìš©
        if (artifactMarket.currentEvent) {
            priceChange *= artifactMarket.currentEvent.effect;
        }
        
        // ìƒˆ ê°€ê²© ê³„ì‚° (ìµœì†Œ/ìµœëŒ€ê°’ ì œí•œ)
        let newPrice = history.currentPrice * (1 + priceChange);
        newPrice = Math.max(artifact.value[0] * 0.5, Math.min(artifact.value[1] * 2, newPrice));
        
        history.currentPrice = Math.round(newPrice);
        history.prices.push({
            price: history.currentPrice,
            timestamp: now
        });
        
        // ìµœëŒ€ 50ê°œ ê¸°ë¡ ìœ ì§€
        if (history.prices.length > 50) {
            history.prices = history.prices.slice(-50);
        }
    });
    
    artifactMarket.lastUpdate = now;
}

// ìœ ë¬¼ ë“±ê¸‰ í™•ì¸ í•¨ìˆ˜
function getRarityByArtifact(artifactName) {
    if (ARTIFACT_SYSTEM.artifacts.common.some(a => a.name === artifactName)) return 'common';
    if (ARTIFACT_SYSTEM.artifacts.rare.some(a => a.name === artifactName)) return 'rare';
    if (ARTIFACT_SYSTEM.artifacts.epic.some(a => a.name === artifactName)) return 'epic';
    if (ARTIFACT_SYSTEM.artifacts.legendary.some(a => a.name === artifactName)) return 'legendary';
    return 'common';
}


// ìœ ë¬¼ ì‹œì„¸ ì •ê¸° ì—…ë°ì´íŠ¸ (10ë¶„ë§ˆë‹¤)
intervals.push(setInterval(() => {
    updateArtifactPrices();
}, 10 * 60 * 1000));

// ì´ˆê¸° ìœ ë¬¼ ì‹œì„¸ ì„¤ì •
updateArtifactPrices();

// ìš´ë™í•˜ê¸° ì‹œìŠ¤í…œ í•¨ìˆ˜ë“¤
async function showExerciseMenu(interaction, user) {
    // í”¼ë¡œë„ íšŒë³µ ê³„ì‚°
    const now = Date.now();
    const timeSinceRecovery = now - (user.fitness.lastRecovery || now);
    const hoursElapsed = timeSinceRecovery / (1000 * 60 * 60);
    const recoveryAmount = Math.floor(hoursElapsed * EXERCISE_SYSTEM.fatigue.recoveryRate);
    
    if (recoveryAmount > 0) {
        user.fitness.fatigue = Math.max(0, user.fitness.fatigue - recoveryAmount);
        user.fitness.lastRecovery = now;
        await user.save();
    }
    
    // í˜„ì¬ ìš´ë™ ìƒíƒœ í™•ì¸
    let currentExerciseInfo = '';
    if (user.fitness.currentExercise.type) {
        const exercise = EXERCISE_SYSTEM.exercises[user.fitness.currentExercise.type];
        const elapsed = now - user.fitness.currentExercise.startTime;
        const remaining = user.fitness.currentExercise.duration - elapsed;
        
        if (remaining > 0) {
            const remainingMinutes = Math.ceil(remaining / 60000);
            currentExerciseInfo = `\nğŸƒ **ì§„í–‰ì¤‘**: ${exercise.emoji} ${exercise.name} (${remainingMinutes}ë¶„ ë‚¨ìŒ)`;
        } else {
            // ìš´ë™ ì™„ë£Œ ì²˜ë¦¬
            await completeExercise(user);
            currentExerciseInfo = '\nâœ… ìš´ë™ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤! ë³´ìƒì„ í™•ì¸í•˜ì„¸ìš”.';
        }
    }
    
    // í”¼íŠ¸ë‹ˆìŠ¤ ë ˆë²¨ í™•ì¸
    const fitnessLevel = getFitnessLevel(user.fitness.level);
    
    const embed = new EmbedBuilder()
        .setColor('#ff6b6b')
        .setTitle('ğŸƒ ìš´ë™í•˜ê¸°')
        .setDescription(`**${user.nickname}**ë‹˜ì˜ í”¼íŠ¸ë‹ˆìŠ¤ ì„¼í„°${currentExerciseInfo}`)
        .addFields(
            { 
                name: 'ğŸ’ª í”¼íŠ¸ë‹ˆìŠ¤ ë ˆë²¨', 
                value: `${fitnessLevel.emoji} ${fitnessLevel.name} Lv.${user.fitness.level}`, 
                inline: true 
            },
            { 
                name: 'ğŸ’¦ í”¼ë¡œë„', 
                value: `${user.fitness.fatigue}/100 ${getFatigueBar(user.fitness.fatigue)}`, 
                inline: true 
            },
            { 
                name: 'ğŸ”¥ ì—°ì† ìš´ë™', 
                value: `${user.fitness.streak}ì¼`, 
                inline: true 
            },
            {
                name: 'ğŸ“Š í”¼íŠ¸ë‹ˆìŠ¤ ìŠ¤íƒ¯',
                value: `ğŸ’ª ê·¼ë ¥: ${user.fitness.stats.strength} | ğŸƒ ì²´ë ¥: ${user.fitness.stats.stamina}\n` +
                       `ğŸ¤¸ ìœ ì—°ì„±: ${user.fitness.stats.flexibility} | âš¡ ë¯¼ì²©: ${user.fitness.stats.agility}\n` +
                       `ğŸ§  ì •ì‹ ë ¥: ${user.fitness.stats.mental}`,
                inline: false
            }
        );
    
    // ìš´ë™ ì„ íƒ ë²„íŠ¼ë“¤
    const exerciseButtons = new ActionRowBuilder()
        .addComponents(
            new ButtonBuilder()
                .setCustomId('exercise_select')
                .setLabel('ğŸƒ ìš´ë™ ì‹œì‘')
                .setStyle(ButtonStyle.Primary)
                .setDisabled(user.fitness.fatigue >= EXERCISE_SYSTEM.fatigue.exerciseLimit || user.fitness.currentExercise.type !== null),
            new ButtonBuilder()
                .setCustomId('exercise_equipment')
                .setLabel('ğŸ½ ìš´ë™ ì¥ë¹„')
                .setStyle(ButtonStyle.Secondary),
            new ButtonBuilder()
                .setCustomId('exercise_supplements')
                .setLabel('ğŸ¥¤ ë³´ì¶©ì œ')
                .setStyle(ButtonStyle.Secondary),
            new ButtonBuilder()
                .setCustomId('exercise_goals')
                .setLabel('ğŸ¯ ëª©í‘œ')
                .setStyle(ButtonStyle.Success)
        );
    
    const extraButtons = new ActionRowBuilder()
        .addComponents(
            new ButtonBuilder()
                .setCustomId('exercise_stats')
                .setLabel('ğŸ“Š í†µê³„')
                .setStyle(ButtonStyle.Secondary),
            new ButtonBuilder()
                .setCustomId('exercise_ranking')
                .setLabel('ğŸ† ë­í‚¹')
                .setStyle(ButtonStyle.Secondary),
            new ButtonBuilder()
                .setCustomId('exercise_membership')
                .setLabel('ğŸ’³ ì´ìš©ê¶Œ')
                .setStyle(ButtonStyle.Success)
        );
    
    await interaction.update({
        embeds: [embed],
        components: [exerciseButtons, extraButtons]
    });
}

// í”¼íŠ¸ë‹ˆìŠ¤ ë ˆë²¨ í™•ì¸
function getFitnessLevel(level) {
    let result = { name: 'ìš´ë™ ì´ˆë³´ì', emoji: 'ğŸŒ±' };
    
    for (const [minLevel, data] of Object.entries(EXERCISE_SYSTEM.levelTiers)) {
        if (level >= parseInt(minLevel)) {
            result = data;
        }
    }
    
    return result;
}

// í”¼ë¡œë„ ë°” ìƒì„±
function getFatigueBar(fatigue) {
    const barLength = 10;
    const filledLength = Math.round((fatigue / 100) * barLength);
    const emptyLength = barLength - filledLength;
    
    let bar = '';
    if (fatigue >= EXERCISE_SYSTEM.fatigue.exerciseLimit) {
        bar = 'ğŸ”´'.repeat(filledLength);
    } else if (fatigue >= EXERCISE_SYSTEM.fatigue.warningLevel) {
        bar = 'ğŸŸ¡'.repeat(filledLength);
    } else {
        bar = 'ğŸŸ¢'.repeat(filledLength);
    }
    bar += 'âšª'.repeat(emptyLength);
    
    return bar;
}

// ìš´ë™ ì™„ë£Œ ì²˜ë¦¬
async function completeExercise(user) {
    const exerciseType = user.fitness.currentExercise.type;
    if (!exerciseType) return;
    
    const exercise = EXERCISE_SYSTEM.exercises[exerciseType];
    const actualElapsed = Date.now() - user.fitness.currentExercise.startTime;
    const intendedDuration = user.fitness.currentExercise.duration;
    // Use the minimum of actual elapsed time and intended duration
    const duration = Math.min(actualElapsed, intendedDuration);
    const minutes = Math.floor(duration / 60000);
    
    // ì¥ë¹„ ë³´ë„ˆìŠ¤ ê³„ì‚°
    const clothesBonus = EXERCISE_SYSTEM.equipment.clothes[user.fitness.equipment.clothes].efficiency;
    const shoesBonus = EXERCISE_SYSTEM.equipment.shoes[user.fitness.equipment.shoes].speed;
    
    // ë³´ì¶©ì œ íš¨ê³¼ í™•ì¸
    let supplementBonus = 1.0;
    let fatigueReduction = 1.0;
    const now = Date.now();
    
    if (user.fitness.equipment.activeBooster.type && user.fitness.equipment.activeBooster.expiresAt > now) {
        const supplement = EXERCISE_SYSTEM.supplements[user.fitness.equipment.activeBooster.type];
        
        if (supplement.effect.strength && exercise.efficiency.strength > 0) {
            supplementBonus = supplement.effect.strength;
        } else if (supplement.effect.fatigueReduction) {
            fatigueReduction = supplement.effect.fatigueReduction;
        } else if (supplement.effect.allStats) {
            supplementBonus = supplement.effect.allStats;
        }
    }
    
    // ì—°ì† ìš´ë™ ë³´ë„ˆìŠ¤
    let streakBonus = 1.0;
    for (const bonus of EXERCISE_SYSTEM.streakBonus) {
        if (user.fitness.streak >= bonus.days) {
            streakBonus = 1 + bonus.bonus;
        }
    }
    
    // ë³´ìƒ ê³„ì‚° (ë³´ì¶©ì œ ë³´ë„ˆìŠ¤ ì ìš©)
    const goldReward = Math.floor(exercise.rewards.goldPerMinute * minutes * clothesBonus * streakBonus * supplementBonus);
    const expReward = Math.floor(exercise.rewards.expPerMinute * minutes * clothesBonus * streakBonus * supplementBonus);
    const fitnessExpReward = Math.floor(exercise.rewards.fitnessExpPerMinute * minutes * clothesBonus * shoesBonus * streakBonus * supplementBonus);
    
    // ìŠ¤íƒ¯ ì¦ê°€ ê³„ì‚° (ë³´ì¶©ì œ ë³´ë„ˆìŠ¤ ì ìš©)
    const statGains = {};
    for (const [stat, efficiency] of Object.entries(exercise.efficiency)) {
        statGains[stat] = Math.floor(efficiency * minutes * 0.01 * clothesBonus * streakBonus * supplementBonus);
    }
    
    // ë³´ìƒ ì ìš©
    user.gold += goldReward;
    user.exp += expReward;
    user.fitness.exp += fitnessExpReward;
    
    // ìŠ¤íƒ¯ ì ìš©
    for (const [stat, gain] of Object.entries(statGains)) {
        if (gain > 0) {
            user.fitness.stats[stat] += gain;
        }
    }
    
    // í”¼íŠ¸ë‹ˆìŠ¤ ë ˆë²¨ì—… ì²´í¬
    const requiredExp = getFitnessLevelRequirement(user.fitness.level + 1);
    if (user.fitness.exp >= requiredExp) {
        user.fitness.level += 1;
        user.fitness.exp = 0;
    }
    
    // ìš´ë™ ê¸°ë¡ ì €ì¥
    user.fitness.exerciseHistory.push({
        exerciseType: exerciseType,
        duration: duration,
        rewards: {
            gold: goldReward,
            exp: expReward,
            fitnessExp: fitnessExpReward
        },
        date: new Date()
    });
    
    // ìš´ë™ ì‹œê°„ ëˆ„ì 
    user.fitness.totalExerciseTime += duration;
    
    // ì¼ì¼ ëª©í‘œ ì²´í¬
    const today = new Date().toDateString();
    if (user.fitness.goals.daily.lastReset !== today) {
        user.fitness.goals.daily.minutes30 = false;
        user.fitness.goals.daily.minutes60 = false;
        user.fitness.goals.daily.minutes180 = false;
        user.fitness.goals.daily.lastReset = today;
    }
    
    if (minutes >= 30) user.fitness.goals.daily.minutes30 = true;
    if (minutes >= 60) user.fitness.goals.daily.minutes60 = true;
    if (minutes >= 180) user.fitness.goals.daily.minutes180 = true;
    
    // í˜„ì¬ ìš´ë™ ì´ˆê¸°í™”
    user.fitness.currentExercise = {
        type: null,
        startTime: null,
        duration: 0,
        accumulated: 0
    };
    
    // í”¼ë¡œë„ ì¦ê°€ (ìš´ë™ ì™„ë£Œì‹œ ë‚˜ë¨¸ì§€ í”¼ë¡œë„ ì ìš©)
    const remainingFatigue = Math.floor(exercise.fatigueRate * minutes * 0.5 * fatigueReduction);
    user.fitness.fatigue = Math.min(100, user.fitness.fatigue + remainingFatigue);
    
    await user.save();
}

// í”¼íŠ¸ë‹ˆìŠ¤ ë ˆë²¨ ìš”êµ¬ ê²½í—˜ì¹˜
function getFitnessLevelRequirement(level) {
    return level * level * 50; // ë ˆë²¨^2 * 50
}

// ì˜¤ëŠ˜ ìš´ë™ ì‹œê°„ ê³„ì‚°
function getTodayExerciseTime(user) {
    const today = new Date().toDateString();
    const todayStart = new Date(today).getTime();
    
    let totalTime = 0;
    user.fitness.exerciseHistory.forEach(record => {
        if (new Date(record.date).getTime() >= todayStart) {
            totalTime += record.duration;
        }
    });
    
    // í˜„ì¬ ì§„í–‰ ì¤‘ì¸ ìš´ë™ë„ í¬í•¨
    if (user.fitness.currentExercise.type) {
        const elapsed = Date.now() - user.fitness.currentExercise.startTime;
        totalTime += Math.min(elapsed, user.fitness.currentExercise.duration);
    }
    
    return totalTime;
}

// í†µí•© ë­í‚¹ ë©”ë‰´
async function showRankingMenu(interaction, page = 0) {
    const rankingCategories = [
        {
            id: 'level',
            name: 'ğŸ“ˆ ë ˆë²¨ ë­í‚¹',
            description: 'ìµœê³  ë ˆë²¨ ë‹¬ì„±ì'
        },
        {
            id: 'gold',
            name: 'ğŸ’° ë¶€ì ë­í‚¹',
            description: 'ê³¨ë“œ ë³´ìœ ëŸ‰ TOP'
        },
        {
            id: 'hunting',
            name: 'ğŸ¯ ì‚¬ëƒ¥ ë­í‚¹',
            description: 'ì‚¬ëƒ¥ ì‹¤ë ¥ìë“¤'
        },
        {
            id: 'enhancement',
            name: 'âš”ï¸ ê°•í™” ë­í‚¹',
            description: 'ìµœê³  ê°•í™” ë‹¬ì„±ì'
        },
        {
            id: 'pvp',
            name: 'ğŸ† PVP ë­í‚¹',
            description: 'ìµœê°•ì˜ ê²°íˆ¬ê°€'
        },
        {
            id: 'racing',
            name: 'ğŸ ë ˆì´ì‹± ë­í‚¹',
            description: 'ë² íŒ…ì˜ ë‹¬ì¸'
        },
        {
            id: 'energy',
            name: 'âš¡ ì—ë„ˆì§€ ë­í‚¹',
            description: 'ì—ë„ˆì§€ ì¡°ê° ìˆ˜ì§‘ê°€'
        },
        {
            id: 'oddeven',
            name: 'ğŸ² í™€ì§ ë­í‚¹',
            description: 'í™€ì§ê²Œì„ ë§ˆìŠ¤í„°'
        },
        {
            id: 'artifact',
            name: 'ğŸº ìœ ë¬¼ ë­í‚¹',
            description: 'ìœ ë¬¼ íƒì‚¬ ì „ë¬¸ê°€'
        },
        {
            id: 'fitness',
            name: 'ğŸ’ª ìš´ë™ ë­í‚¹',
            description: 'í”¼íŠ¸ë‹ˆìŠ¤ ë§ˆìŠ¤í„°'
        },
        {
            id: 'popularity',
            name: 'â¤ï¸ ì¸ê¸° ë­í‚¹',
            description: 'ê°€ì¥ ì¸ê¸°ìˆëŠ” ìœ ì €'
        },
        {
            id: 'attendance',
            name: 'ğŸ”¥ ì¶œì„ ë­í‚¹',
            description: 'ê¾¸ì¤€í•œ ì¶œì„ì™•'
        }
    ];
    
    const currentCategory = rankingCategories[page];
    if (!currentCategory) return;
    
    let rankingData = [];
    let fields = [];
    
    try {
        switch (currentCategory.id) {
            case 'level':
                rankingData = await User.find({ registered: true })
                    .sort({ level: -1, exp: -1 })
                    .limit(10);
                    
                fields = rankingData.map((user, index) => {
                    const medal = getMedalEmoji(index);
                    return `${medal} **${user.nickname}**\nã€€ã€€Lv.${user.level} (${user.exp.toLocaleString()} EXP)`;
                });
                break;
                
            case 'gold':
                rankingData = await User.find({ registered: true })
                    .sort({ gold: -1 })
                    .limit(10);
                    
                fields = rankingData.map((user, index) => {
                    const medal = getMedalEmoji(index);
                    return `${medal} **${user.nickname}**\nã€€ã€€${user.gold.toLocaleString()}<:currency_emoji:1377404064316522778>`;
                });
                break;
                
            case 'hunting':
                // ì‚¬ëƒ¥ íšŸìˆ˜ ê¸°ì¤€ (lastHunt í•„ë“œë¡œ ì¶”ì •)
                rankingData = await User.find({ registered: true, level: { $gt: 1 } })
                    .sort({ level: -1 })
                    .limit(10);
                    
                fields = rankingData.map((user, index) => {
                    const medal = getMedalEmoji(index);
                    return `${medal} **${user.nickname}**\nã€€ã€€Lv.${user.level} ì‚¬ëƒ¥ê¾¼`;
                });
                break;
                
            case 'enhancement':
                rankingData = await User.find({ registered: true, 'enhanceStats.maxEnhanceLevel': { $gt: 0 } })
                    .sort({ 'enhanceStats.maxEnhanceLevel': -1 })
                    .limit(10);
                    
                fields = rankingData.map((user, index) => {
                    const medal = getMedalEmoji(index);
                    return `${medal} **${user.nickname}**\nã€€ã€€ìµœê³  +${user.enhanceStats.maxEnhanceLevel}ê°•`;
                });
                break;
                
            case 'pvp':
                rankingData = await User.find({ registered: true })
                    .sort({ 'pvp.rating': -1 })
                    .limit(10);
                    
                fields = rankingData.map((user, index) => {
                    const medal = getMedalEmoji(index);
                    const winRate = user.pvp.totalDuels > 0 ? 
                        ((user.pvp.wins / user.pvp.totalDuels) * 100).toFixed(1) : 0;
                    return `${medal} **${user.nickname}**\nã€€ã€€${user.pvp.rating}ì  (ìŠ¹ë¥  ${winRate}%)`;
                });
                break;
                
            case 'racing':
                rankingData = await User.find({ 'racingStats.wins': { $gt: 0 } })
                    .sort({ 'racingStats.wins': -1 })
                    .limit(10);
                    
                fields = rankingData.map((user, index) => {
                    const medal = getMedalEmoji(index);
                    return `${medal} **${user.nickname}**\nã€€ã€€${user.racingStats.wins}íšŒ ìš°ìŠ¹`;
                });
                break;
                
            case 'energy':
                rankingData = await User.find({ 'energyFragments.highestLevel': { $gt: 0 } })
                    .sort({ 'energyFragments.highestLevel': -1 })
                    .limit(10);
                    
                fields = rankingData.map((user, index) => {
                    const medal = getMedalEmoji(index);
                    return `${medal} **${user.nickname}**\nã€€ã€€ìµœê³  Lv.${user.energyFragments.highestLevel} ë‹¬ì„±`;
                });
                break;
                
            case 'oddeven':
                rankingData = await User.find({ 'oddEvenStats.totalWinnings': { $gt: 0 } })
                    .sort({ 'oddEvenStats.totalWinnings': -1 })
                    .limit(10);
                    
                fields = rankingData.map((user, index) => {
                    const medal = getMedalEmoji(index);
                    const winRate = user.oddEvenStats.totalGames > 0 ?
                        ((user.oddEvenStats.wins / user.oddEvenStats.totalGames) * 100).toFixed(1) : 0;
                    return `${medal} **${user.nickname}**\nã€€ã€€ì´ ${user.oddEvenStats.totalWinnings.toLocaleString()}G íšë“ (ìŠ¹ë¥  ${winRate}%)`;
                });
                break;
                
            case 'artifact':
                rankingData = await User.find({ registered: true, 'explorationStats.totalEarned': { $gt: 0 } })
                    .sort({ 'explorationStats.totalEarned': -1 })
                    .limit(10);
                    
                fields = rankingData.map((user, index) => {
                    const medal = getMedalEmoji(index);
                    const successRate = user.explorationStats.totalExplorations > 0 ? 
                        ((user.explorationStats.successfulFinds / user.explorationStats.totalExplorations) * 100).toFixed(1) : 0;
                    return `${medal} **${user.nickname}**\nã€€ã€€${user.explorationStats.totalEarned.toLocaleString()}G ìˆ˜ìµ (ì„±ê³µë¥  ${successRate}%)`;
                });
                break;
                
            case 'fitness':
                rankingData = await User.find({ 'fitness.level': { $gt: 1 } })
                    .sort({ 'fitness.level': -1, 'fitness.exp': -1 })
                    .limit(10);
                    
                fields = rankingData.map((user, index) => {
                    const medal = getMedalEmoji(index);
                    const hours = Math.floor(user.fitness.totalExerciseTime / 3600000);
                    return `${medal} **${user.nickname}**\nã€€ã€€Lv.${user.fitness.level} (${hours}ì‹œê°„ ìš´ë™)`;
                });
                break;
                
            case 'popularity':
                rankingData = await User.find({ registered: true })
                    .sort({ popularity: -1 })
                    .limit(10);
                    
                fields = rankingData.map((user, index) => {
                    const medal = getMedalEmoji(index);
                    return `${medal} **${user.nickname}**\nã€€ã€€ì¸ê¸°ë„ ${user.popularity} â¤ï¸`;
                });
                break;
                
            case 'attendance':
                rankingData = await User.find({ attendanceStreak: { $gt: 0 } })
                    .sort({ attendanceStreak: -1 })
                    .limit(10);
                    
                fields = rankingData.map((user, index) => {
                    const medal = getMedalEmoji(index);
                    return `${medal} **${user.nickname}**\nã€€ã€€${user.attendanceStreak}ì¼ ì—°ì† ğŸ”¥`;
                });
                break;
        }
        
        const embed = new EmbedBuilder()
            .setColor('#FFD700')
            .setTitle(`ğŸ† ${currentCategory.name}`)
            .setDescription(currentCategory.description)
            .addFields({
                name: `ğŸ“Š TOP 10`,
                value: fields.length > 0 ? fields.join('\n\n') : 'ì•„ì§ ë­í‚¹ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.',
                inline: false
            })
            .setFooter({ 
                text: `í˜ì´ì§€ ${page + 1}/${rankingCategories.length} â€¢ ë§¤ ì‹œê°„ ì—…ë°ì´íŠ¸`,
                iconURL: interaction.client.user.displayAvatarURL()
            });
        
        const navButtons = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId(`ranking_prev_${page}`)
                    .setEmoji('â—€ï¸')
                    .setStyle(ButtonStyle.Secondary)
                    .setDisabled(page === 0),
                new ButtonBuilder()
                    .setCustomId(`ranking_next_${page}`)
                    .setEmoji('â–¶ï¸')
                    .setStyle(ButtonStyle.Secondary)
                    .setDisabled(page >= rankingCategories.length - 1),
                new ButtonBuilder()
                    .setCustomId('ranking_select')
                    .setLabel('ğŸ“‹ ì¹´í…Œê³ ë¦¬ ì„ íƒ')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId('back_to_game_menu')
                    .setLabel('ğŸ® ê²Œì„ ë©”ë‰´')
                    .setStyle(ButtonStyle.Success)
            );
        
        if (interaction.replied || interaction.deferred) {
            await interaction.editReply({ embeds: [embed], components: [navButtons] });
        } else {
            await interaction.update({ embeds: [embed], components: [navButtons] });
        }
        
    } catch (error) {
        console.error('ë­í‚¹ ì¡°íšŒ ì˜¤ë¥˜:', error);
        await interaction.reply({ 
            content: 'ë­í‚¹ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 
            flags: 64 
        });
    }
}

// ë©”ë‹¬ ì´ëª¨ì§€ ë°˜í™˜
function getMedalEmoji(index) {
    switch(index) {
        case 0: return 'ğŸ¥‡';
        case 1: return 'ğŸ¥ˆ';
        case 2: return 'ğŸ¥‰';
        default: return `**${index + 1}.**`;
    }
}

// QuickChart APIë¥¼ ì‚¬ìš©í•œ ì‹¤ì œ ì°¨íŠ¸ ìƒì„±
async function generateRealChart(chartData, title, type = 'line') {
    try {
        if (!chartData || chartData.length < 2) {
            console.log('ì°¨íŠ¸ ë°ì´í„°ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤:', chartData?.length || 0);
            return null;
        }
        
        // ë°ì´í„°ë¥¼ ìµœëŒ€ 25ê°œë¡œ ì œí•œ (ë” ìì„¸í•œ ì°¨íŠ¸)
        const limitedData = chartData.slice(-25);
        
        // ê°„ë‹¨í•œ ì‹œê°„ ë ˆì´ë¸” ìƒì„±
        const labels = [];
        for (let i = 0; i < limitedData.length; i++) {
            labels.push(`-${(limitedData.length - i - 1) * 5}ë¶„`);
        }
        
        // ì°¨íŠ¸ ìƒ‰ìƒ ê²°ì •
        const isPositive = limitedData[limitedData.length - 1] > limitedData[0];
        
        // ê°„ì†Œí™”ëœ ì°¨íŠ¸ ì„¤ì •
        const chartConfig = {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: title,
                    data: limitedData,
                    borderColor: isPositive ? '#00ff88' : '#ff4444',
                    backgroundColor: isPositive ? 'rgba(0,255,136,0.1)' : 'rgba(255,68,68,0.1)',
                    borderWidth: 3,
                    fill: true
                }]
            },
            options: {
                plugins: {
                    title: {
                        display: true,
                        text: title
                    },
                    legend: {
                        display: true
                    }
                },
                layout: {
                    padding: 20
                }
            }
        };
        
        // QuickChart URL ìƒì„± (ì›Œí„°ë§ˆí¬ ì œê±°)
        const chartUrl = `https://quickchart.io/chart?c=${encodeURIComponent(JSON.stringify(chartConfig))}&width=1000&height=500&format=png`;
        
        console.log('ì°¨íŠ¸ Config:', JSON.stringify(chartConfig, null, 2));
        console.log('ì°¨íŠ¸ URL ìƒì„± ì™„ë£Œ');
        
        return chartUrl;
    } catch (error) {
        console.error('generateRealChart ì˜¤ë¥˜:', error);
        return null;
    }
}

// ë‹¤ì¤‘ ë°ì´í„°ì…‹ ì°¨íŠ¸ ìƒì„± (ì‹œì¥ ì „ì²´ + ìƒìœ„ ê¸°ì—…ë“¤)
async function generateMarketOverviewChart() {
    try {
        const chartHistory = STOCK_MARKET.chart_history;
        
        if (chartHistory.timestamps.length === 0) return null;
        
        // ìµœê·¼ 20ê°œ ë°ì´í„° ì‚¬ìš© (ë” ìì„¸í•œ ì°¨íŠ¸)
        const dataPoints = Math.min(20, chartHistory.timestamps.length);
        const labels = [];
        for (let i = 0; i < dataPoints; i++) {
            labels.push(`-${(dataPoints - i - 1) * 5}ë¶„`);
        }
        
        // ê°„ì†Œí™”ëœ ë°ì´í„°ì…‹
        const datasets = [{
            label: 'ì¢…í•©ì§€ìˆ˜',
            data: chartHistory.market_index.slice(-dataPoints),
            borderColor: '#00D4AA',
            borderWidth: 3
        }];
        
        // ìƒìœ„ 2ê°œ ê¸°ì—…ë§Œ ì¶”ê°€ (URL ê¸¸ì´ ë‹¨ì¶•)
        const allCompanies = [];
        for (const region of Object.values(STOCK_MARKET.regions)) {
            allCompanies.push(...region.companies);
        }
        allCompanies.push(...STOCK_MARKET.chains);
        
        const topCompanies = allCompanies
            .sort((a, b) => b.price - a.price)
            .slice(0, 2);
            
        const colors = ['#FF6B6B', '#4ECDC4'];
        topCompanies.forEach((company, index) => {
            if (chartHistory.top_companies[company.id] && chartHistory.top_companies[company.id].length > 1) {
                datasets.push({
                    label: company.name,
                    data: chartHistory.top_companies[company.id].slice(-dataPoints),
                    borderColor: colors[index],
                    borderWidth: 2
                });
            }
        });
        
        // ìµœì†Œí™”ëœ ì°¨íŠ¸ ì„¤ì •
        const chartConfig = {
            type: 'line',
            data: {
                labels: labels,
                datasets: datasets
            },
            options: {
                plugins: {
                    title: {
                        display: true,
                        text: 'ê¹€í—Œí„° ì‹¤ì‹œê°„ ì°¨íŠ¸'
                    },
                    legend: {
                        display: true
                    }
                },
                layout: {
                    padding: 20
                }
            }
        };
        
        const chartUrl = `https://quickchart.io/chart?c=${encodeURIComponent(JSON.stringify(chartConfig))}&width=1000&height=500&bkg=rgb(47,49,54)&format=png`;
        
        console.log('Market chart URL length:', chartUrl.length);
        
        // URLì´ ë„ˆë¬´ ê¸¸ë©´ ë‹¨ì¼ ë°ì´í„°ì…‹ìœ¼ë¡œ ì¶•ì†Œ
        if (chartUrl.length > 2000) {
            const simpleConfig = {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'ì¢…í•©ì§€ìˆ˜',
                        data: chartHistory.market_index.slice(-dataPoints),
                        borderColor: '#00D4AA',
                        borderWidth: 3
                    }]
                }
            };
            
            return `https://quickchart.io/chart?c=${encodeURIComponent(JSON.stringify(simpleConfig))}&width=1000&height=500&format=png`;
        }
        
        return chartUrl;
    } catch (error) {
        console.error('generateMarketOverviewChart ì˜¤ë¥˜:', error);
        return null;
    }
}

// ASCII ì£¼ì‹ ì°¨íŠ¸ ìƒì„± í•¨ìˆ˜
function generateStockChart() {
    const chartHistory = STOCK_MARKET.chart_history;
    
    if (chartHistory.timestamps.length === 0) {
        return null;
    }

    return generateAdvancedASCIIChart(
        chartHistory.market_index, 
        `ê¹€í—Œí„° ì¢…í•©ì§€ìˆ˜ (${chartHistory.timestamps[0]} ~ ${chartHistory.timestamps[chartHistory.timestamps.length - 1]})`
    );
}

// ìº”ë“¤ìŠ¤í‹± ì°¨íŠ¸ ìƒì„± (ê³ ê¸‰)
async function generateCandlestickChart(companyId, companyName) {
    const chartHistory = STOCK_MARKET.chart_history;
    
    if (!chartHistory.top_companies[companyId] || chartHistory.top_companies[companyId].length < 4) {
        return null;
    }
    
    const prices = chartHistory.top_companies[companyId];
    const candleData = [];
    
    // ìº”ë“¤ìŠ¤í‹± ë°ì´í„° ìƒì„± (4ê°œì”© ë¬¶ì–´ì„œ OHLC ìƒì„±)
    for (let i = 0; i < prices.length - 3; i += 4) {
        const slice = prices.slice(i, i + 4);
        candleData.push({
            x: i,
            o: slice[0],
            h: Math.max(...slice),
            l: Math.min(...slice),
            c: slice[3]
        });
    }
    
    const chartConfig = {
        type: 'candlestick',
        data: {
            datasets: [{
                label: companyName,
                data: candleData,
                color: {
                    up: '#00ff88',
                    down: '#ff4444',
                    unchanged: '#999999'
                }
            }]
        },
        options: {
            scales: {
                x: {
                    type: 'linear',
                    offset: true
                },
                y: {
                    beginAtZero: false
                }
            }
        }
    };
    
    const chartUrl = `https://quickchart.io/chart?c=${encodeURIComponent(JSON.stringify(chartConfig))}&width=1000&height=500&backgroundColor=rgb(47,49,54)&format=png`;
    
    return chartUrl;
}

// ğŸº ìœ ë¬¼ ì‹œì¥ ì‹œìŠ¤í…œ
// ìœ ë¬¼ ì‹œì¥ ê°€ì¹˜ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
function updateArtifactMarket() {
    try {
        const artifactMarket = STOCK_MARKET.artifact_market;
        const now = Date.now();
        
        // 5ë¶„ë§ˆë‹¤ ì—…ë°ì´íŠ¸
        if (now - artifactMarket.last_update < 5 * 60 * 1000) return;
        
        // ì‹œì¥ ì´ë²¤íŠ¸ ì²´í¬
        checkArtifactMarketEvents();
        
        // ê° ìœ ë¬¼ ê°€ì¹˜ ë°°ìœ¨ ì—…ë°ì´íŠ¸
        for (const [artifactName, currentMultiplier] of Object.entries(artifactMarket.value_multipliers)) {
            // ê¸°ë³¸ ë³€ë™ë¥  (-2% ~ +2%)
            const baseVariation = (Math.random() - 0.5) * 0.04;
            
            // ë³€ë™ì„±ì— ë”°ë¥¸ ì¶”ê°€ ë³€ë™
            const volatilityMultiplier = artifactMarket.volatility / 100;
            const volatilityVariation = (Math.random() - 0.5) * 0.02 * volatilityMultiplier;
            
            // ì´ ë³€ë™ë¥ 
            const totalVariation = baseVariation + volatilityVariation;
            
            // ìƒˆ ë°°ìœ¨ ê³„ì‚° (0.5 ~ 2.0 ë²”ìœ„ë¡œ ì œí•œ)
            let newMultiplier = currentMultiplier * (1 + totalVariation);
            newMultiplier = Math.max(0.5, Math.min(2.0, newMultiplier));
            
            // ì´ë²¤íŠ¸ íš¨ê³¼ ì ìš©
            newMultiplier = applyArtifactEvents(artifactName, newMultiplier);
            
            artifactMarket.value_multipliers[artifactName] = newMultiplier;
        }
        
        // ì°¨íŠ¸ ë°ì´í„° ì—…ë°ì´íŠ¸
        updateArtifactChartData();
        
        artifactMarket.last_update = now;
        console.log('ğŸº ìœ ë¬¼ ì‹œì¥ ì—…ë°ì´íŠ¸ ì™„ë£Œ');
        
    } catch (error) {
        console.error('ìœ ë¬¼ ì‹œì¥ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:', error);
    }
}

// ìœ ë¬¼ ì‹œì¥ ì´ë²¤íŠ¸ ì²´í¬
function checkArtifactMarketEvents() {
    const artifactMarket = STOCK_MARKET.artifact_market;
    const now = Date.now();
    
    // ë§Œë£Œëœ ì´ë²¤íŠ¸ ì œê±°
    artifactMarket.active_events = artifactMarket.active_events.filter(event => {
        return now < event.start_time + event.duration;
    });
    
    // ìƒˆ ì´ë²¤íŠ¸ ìƒì„± ì²´í¬
    for (const eventTemplate of artifactMarket.market_events) {
        if (Math.random() < eventTemplate.probability) {
            const newEvent = {
                ...eventTemplate,
                start_time: now,
                id: `${eventTemplate.name}_${now}`
            };
            
            // ë™ì¼í•œ ì´ë²¤íŠ¸ê°€ ì´ë¯¸ í™œì„±í™”ë˜ì–´ ìˆì§€ ì•Šë‹¤ë©´ ì¶”ê°€
            if (!artifactMarket.active_events.some(e => e.name === eventTemplate.name)) {
                artifactMarket.active_events.push(newEvent);
                console.log(`ğŸ‰ ìœ ë¬¼ ì‹œì¥ ì´ë²¤íŠ¸ ì‹œì‘: ${eventTemplate.name}`);
            }
        }
    }
}

// ìœ ë¬¼ì— ì´ë²¤íŠ¸ íš¨ê³¼ ì ìš©
function applyArtifactEvents(artifactName, baseMultiplier) {
    const artifactMarket = STOCK_MARKET.artifact_market;
    let finalMultiplier = baseMultiplier;
    
    // ìœ ë¬¼ ë“±ê¸‰ í™•ì¸ (ê°„ë‹¨í•œ ë§¤í•‘)
    const artifactRarity = getArtifactRarity(artifactName);
    
    for (const event of artifactMarket.active_events) {
        if (event.effect.rarity === artifactRarity) {
            finalMultiplier *= event.effect.multiplier;
        }
    }
    
    return finalMultiplier;
}

// ìœ ë¬¼ ë“±ê¸‰ í™•ì¸
function getArtifactRarity(artifactName) {
    // ë ˆì „ë“œë¦¬ ìœ ë¬¼ë“¤
    const legendaryArtifacts = ['ì°½ì¡°ì˜ ì„œíŒ', 'ë¬´í•œì˜ ë³´ì„', 'ì‹œê³µê°„ ì—´ì‡ ', 'ìƒëª…ì˜ ë‚˜ë¬´ ê°€ì§€', 'ë³„ì˜ ëˆˆë¬¼', 
                               'íŒŒë¼ì˜¤ì˜ í™©ê¸ˆ ë§ˆìŠ¤í¬', 'í•´ì ì™•ì˜ ë³´ë¬¼ìƒì', 'ì„¤ì¸ì˜ ë°œìêµ­ í™”ì„', 
                               'ìƒì–´ë²„ë¦° ë„ì‹œì˜ ì—´ì‡ ', 'ì™¸ê³„ ë¬¸ëª…ì˜ ë°ì´í„° ì½”ì–´'];
    
    // ì—í”½ ìœ ë¬¼ë“¤
    const epicArtifacts = ['ì™•ê´€ì˜ ì¡°ê°', 'ìš©ì˜ ë¹„ëŠ˜', 'ì‹ ì˜ ì„±ë¬¼', 'ì‹œê°„ì˜ ëª¨ë˜ì‹œê³„', 'ë¶ˆë©¸ì˜ ì•½ì´ˆ',
                          'ë¯¸ë¼ì˜ ë¶•ëŒ€', 'ì¸ì–´ì˜ ì§„ì£¼', 'ì–¼ìŒ ìˆ˜ì •', 'ì•„ì¦ˆí… í™©ê¸ˆ ì¡°ê°ìƒ', 'ìš´ì„ ì¡°ê°'];
    
    // í¬ê·€ ìœ ë¬¼ë“¤
    const rareArtifacts = ['í™©ê¸ˆ ëª©ê±¸ì´', 'ë³´ì„ ë‹¨ê²€', 'ê³ ëŒ€ ë‘ë£¨ë§ˆë¦¬', 'ìˆ˜ì • êµ¬ìŠ¬', 'ì€ ì”'];
    
    if (legendaryArtifacts.includes(artifactName)) return 'legendary';
    if (epicArtifacts.includes(artifactName)) return 'epic';
    if (rareArtifacts.includes(artifactName)) return 'rare';
    return 'common';
}

// ìœ ë¬¼ ì°¨íŠ¸ ë°ì´í„° ì—…ë°ì´íŠ¸
function updateArtifactChartData() {
    const artifactMarket = STOCK_MARKET.artifact_market;
    const now = new Date();
    const timestamp = now.toLocaleTimeString('ko-KR', { 
        hour: '2-digit', 
        minute: '2-digit' 
    });
    
    // íƒ€ì„ìŠ¤íƒ¬í”„ ì¶”ê°€
    artifactMarket.chart_history.timestamps.push(timestamp);
    
    // ì „ì²´ ìœ ë¬¼ ì‹œì¥ ì§€ìˆ˜ ê³„ì‚° (í‰ê·  ë°°ìœ¨)
    const multipliers = Object.values(artifactMarket.value_multipliers);
    const averageMultiplier = multipliers.reduce((sum, m) => sum + m, 0) / multipliers.length;
    const marketIndex = Math.round(averageMultiplier * 1000); // 1000ì„ ê¸°ì¤€ìœ¼ë¡œ ì§€ìˆ˜í™”
    
    artifactMarket.chart_history.artifact_index.push(marketIndex);
    
    // ê°œë³„ ìœ ë¬¼ ë°ì´í„° ì—…ë°ì´íŠ¸ (ìƒìœ„ 10ê°œë§Œ)
    const topArtifacts = Object.entries(artifactMarket.value_multipliers)
        .sort(([,a], [,b]) => b - a)
        .slice(0, 10);
    
    for (const [artifactName, multiplier] of topArtifacts) {
        if (!artifactMarket.chart_history.individual_artifacts[artifactName]) {
            artifactMarket.chart_history.individual_artifacts[artifactName] = [];
        }
        
        const value = Math.round(multiplier * 100); // ë°±ë¶„ìœ¨ë¡œ ë³€í™˜
        artifactMarket.chart_history.individual_artifacts[artifactName].push(value);
        
        // ìµœëŒ€ 50ê°œ ë°ì´í„°í¬ì¸íŠ¸ë§Œ ìœ ì§€
        if (artifactMarket.chart_history.individual_artifacts[artifactName].length > 50) {
            artifactMarket.chart_history.individual_artifacts[artifactName].shift();
        }
    }
    
    // ìµœëŒ€ 50ê°œ ë°ì´í„°í¬ì¸íŠ¸ë§Œ ìœ ì§€
    if (artifactMarket.chart_history.timestamps.length > 50) {
        artifactMarket.chart_history.timestamps.shift();
        artifactMarket.chart_history.artifact_index.shift();
    }
}

// ìœ ë¬¼ì˜ í˜„ì¬ ì‹œì¥ ê°€ì¹˜ ê³„ì‚°
function calculateArtifactValue(artifact) {
    // ìƒˆë¡œìš´ ì‹œì„¸ ì‹œìŠ¤í…œ ì‚¬ìš©
    const priceData = artifactMarket.priceHistory.get(artifact.name);
    if (priceData && priceData.currentPrice) {
        return priceData.currentPrice;
    }
    
    // ê¸°ì¡´ ì‹œìŠ¤í…œ í´ë°±
    const stockArtifactMarket = STOCK_MARKET.artifact_market;
    const baseValue = artifact.value;
    const multiplier = stockArtifactMarket.value_multipliers[artifact.name] || 1.0;
    
    return Math.round(baseValue * multiplier);
}

// ìœ ë¬¼ ì‹œì¥ ì°¨íŠ¸ ìƒì„±
async function generateArtifactChart(type = 'market') {
    try {
        const artifactMarket = STOCK_MARKET.artifact_market;
        const chartHistory = artifactMarket.chart_history;
        
        if (chartHistory.timestamps.length < 2) {
            return null;
        }
        
        const dataPoints = Math.min(25, chartHistory.timestamps.length);
        const labels = chartHistory.timestamps.slice(-dataPoints);
        
        let chartConfig;
        
        if (type === 'market') {
            // ì „ì²´ ì‹œì¥ ì§€ìˆ˜ ì°¨íŠ¸
            chartConfig = {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'ìœ ë¬¼ ì‹œì¥ ì§€ìˆ˜',
                        data: chartHistory.artifact_index.slice(-dataPoints),
                        borderColor: '#f39c12',
                        backgroundColor: 'rgba(243,156,18,0.1)',
                        borderWidth: 3,
                        fill: true
                    }]
                },
                options: {
                    plugins: {
                        title: {
                            display: true,
                            text: 'ğŸº ìœ ë¬¼ ì‹œì¥ ì¢…í•© ì§€ìˆ˜',
                            color: '#f39c12',
                            font: { size: 16 }
                        },
                        legend: { display: false }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            ticks: { color: '#ffffff' },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        x: {
                            ticks: { color: '#ffffff' },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        }
                    }
                }
            };
        } else {
            // ê°œë³„ ìœ ë¬¼ ì°¨íŠ¸
            const topArtifacts = Object.entries(chartHistory.individual_artifacts)
                .filter(([name, data]) => data.length > 1)
                .slice(0, 5);
            
            const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6'];
            const datasets = topArtifacts.map(([name, data], index) => ({
                label: name,
                data: data.slice(-dataPoints),
                borderColor: colors[index],
                borderWidth: 2,
                fill: false
            }));
            
            chartConfig = {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    plugins: {
                        title: {
                            display: true,
                            text: 'ğŸ’ ì£¼ìš” ìœ ë¬¼ ê°€ì¹˜ ë³€ë™',
                            color: '#f39c12',
                            font: { size: 16 }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            ticks: { color: '#ffffff' },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        x: {
                            ticks: { color: '#ffffff' },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        }
                    }
                }
            };
        }
        
        const chartUrl = `https://quickchart.io/chart?c=${encodeURIComponent(JSON.stringify(chartConfig))}&width=1000&height=500&backgroundColor=rgb(47,49,54)&format=png`;
        return chartUrl;
        
    } catch (error) {
        console.error('ìœ ë¬¼ ì°¨íŠ¸ ìƒì„± ì˜¤ë¥˜:', error);
        return null;
    }
}

// ìœ ë¬¼ ì‹œì¥ ì •ê¸° ì—…ë°ì´íŠ¸ ì‹œì‘
intervals.push(setInterval(updateArtifactMarket, 5 * 60 * 1000)); // 5ë¶„ë§ˆë‹¤ ì—…ë°ì´íŠ¸

// ğŸ ì•„ë°”íƒ€ ë ˆì´ì‹± ì‹œìŠ¤í…œ
class BettingRaceSystem {
    constructor() {
        this.isRacing = false;
        this.waitingPlayers = new Map(); // userId -> player info
        this.raceStartTimer = null;
        this.botTimer = null; // ë´‡ ë§¤ì¹­ íƒ€ì´ë¨¸
        this.minPlayers = 3;
        this.maxPlayers = 8;
        this.minBet = 1000;
        this.maxBet = 50000;
        this.waitTime = 5000; // ê°œë°œìš©: 5ì´ˆ ëŒ€ê¸°
        this.botWaitTime = 5000; // ê°œë°œìš©: 5ì´ˆ í›„ ë´‡ ì¶”ê°€
        this.botNames = [
            'ì² ìˆ˜', 'ì˜í¬', 'ë¯¼ìˆ˜', 'ìˆ˜ì§„', 'ë™í˜¸', 'ì§€ì˜', 'íƒœí˜„', 'ë¯¸ë¼',
            'ì¤€í˜¸', 'ì†Œì˜', 'í˜„ìš°', 'ì˜ˆë¦°', 'ìŠ¹í˜¸', 'ë‚˜ì—°', 'ì •ë¯¼', 'í•˜ëŠ˜',
            'ë°”ëŒ', 'êµ¬ë¦„', 'í–‡ì‚´', 'ë‹¬ë¹›', 'ë³„ë¹›', 'ì²œë‘¥', 'ë²ˆê°œ', 'í­í’'
        ];
        this.raceLength = 100; // ë ˆì´ìŠ¤ ê±°ë¦¬
        this.frameCount = 50; // GIF í”„ë ˆì„ ìˆ˜ ìµœì í™” (í¬ê¸°ì™€ í’ˆì§ˆ ê· í˜•)
    }
    
    // ë ˆì´ì‹± GIF ìƒì„±
    async createRaceGIF(racers, finalResults = null, raceFrames = null) {
        console.log(`ğŸ GIF ìƒì„± ì‹œì‘: ${racers.length}ëª… ë ˆì´ì„œ, ìµœì¢…ê²°ê³¼: ${finalResults}`);
        const startTime = Date.now();
        
        // ì™„ì£¼ í›„ ëŒ€ê¸° ì‹œê°„ì„ ìœ„í•œ ë³€ìˆ˜ ì´ˆê¸°í™”
        this.finishStartFrame = null;
        
        try {
            // ğŸš€ ì•„ë°”íƒ€ ë¯¸ë¦¬ ë¡œë“œ (ì„±ëŠ¥ ê°œì„ )
            console.log('ğŸ–¼ï¸ ì•„ë°”íƒ€ ì´ë¯¸ì§€ ë¯¸ë¦¬ ë¡œë”©...');
            const avatarCache = new Map();
            
            for (const racer of racers) {
                try {
                    const avatarImg = await Jimp.read(racer.avatar);
                    avatarImg.resize(60, 60);
                    avatarImg.circle();
                    avatarCache.set(racer.userId, avatarImg);
                    console.log(`âœ… ${racer.nickname} ì•„ë°”íƒ€ ë¡œë“œ ì„±ê³µ`);
                } catch (e) {
                    console.log(`âš ï¸ ${racer.nickname} ì•„ë°”íƒ€ ë¡œë“œ ì‹¤íŒ¨ - ê¸°ë³¸ ì´ë¯¸ì§€ ì‚¬ìš©`);
                    const circleColor = racer.isBot ? '#888888' : '#' + Math.floor(Math.random()*16777215).toString(16);
                    const circle = new Jimp(60, 60, circleColor);
                    circle.circle();
                    avatarCache.set(racer.userId, circle);
                }
            }

            // ğŸï¸ íŠ¸ë™ ì´ë¯¸ì§€ ë¯¸ë¦¬ ë¡œë“œ (í•œ ë²ˆë§Œ!)
            console.log('ğŸ íŠ¸ë™ ì´ë¯¸ì§€ ë¯¸ë¦¬ ë¡œë”©...');
            let trackImage = null;
            try {
                trackImage = await Jimp.read('./resource/race_track.png');
                console.log('âœ… ì»¤ìŠ¤í…€ íŠ¸ë™ ì´ë¯¸ì§€ ë¡œë“œ ì„±ê³µ!');
            } catch (e) {
                console.log('âš ï¸ ì»¤ìŠ¤í…€ íŠ¸ë™ ì—†ìŒ - ê¸°ë³¸ íŠ¸ë™ ì‚¬ìš©');
            }

            // ğŸŒ‹ ë°°ê²½ ì´ë¯¸ì§€ ë¯¸ë¦¬ ë¡œë“œ (í•œ ë²ˆë§Œ!)
            console.log('ğŸ¨ ë°°ê²½ ì´ë¯¸ì§€ ë¯¸ë¦¬ ë¡œë”©...');
            let backgroundTemplate = null;
            try {
                backgroundTemplate = await Jimp.read('./resource/lava_background.gif');
                console.log('âœ… ì»¤ìŠ¤í…€ ìš©ì•” ë°°ê²½ ë¡œë“œ ì„±ê³µ!');
            } catch (e) {
                console.log('âš ï¸ ì»¤ìŠ¤í…€ ë°°ê²½ ì—†ìŒ - ê¸°ë³¸ ìš©ì•” ë°°ê²½ ìƒì„±');
                
                // ê¸°ë³¸ ìš©ì•” ë°°ê²½ ìƒì„± (í•œ ë²ˆë§Œ!)
                const lavaColors = {
                    dark: '#4A0E0E',
                    medium: '#8B0000',
                    bright: '#FF4500',
                    glow: '#FFD700'
                };
                
                backgroundTemplate = await new Promise((resolve, reject) => {
                    new Jimp(1000, 600, lavaColors.dark, (err, img) => {
                        if (err) reject(err);
                        else resolve(img);
                    });
                });
                
                // ìš©ì•” íš¨ê³¼ ì¶”ê°€
                for (let i = 0; i < 50; i++) {
                    const x = Math.random() * 1000;
                    const y = Math.random() * 600;
                    const size = Math.random() * 20 + 5;
                    const intensity = Math.random();
                    
                    let color;
                    if (intensity > 0.8) {
                        color = lavaColors.glow;
                    } else if (intensity > 0.5) {
                        color = lavaColors.bright;
                    } else {
                        color = lavaColors.medium;
                    }
                    
                    const lavaSpot = new Jimp(size, size, color);
                    lavaSpot.opacity(0.3 + intensity * 0.4);
                    lavaSpot.circle();
                    backgroundTemplate.composite(lavaSpot, x - size/2, y - size/2);
                }
            }
            
            const width = 1000;
            const height = 50 + racers.length * 90 + 50;
            const encoder = new GifEncoder(width, height);
            
            encoder.start();
            encoder.setRepeat(-1); // í•œ ë²ˆë§Œ ì¬ìƒ (ë°˜ë³µ ì—†ìŒ)
            encoder.setDelay(150); // ë‹¬ë¦¬ëŠ” ì†ë„ëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€
            encoder.setQuality(15); // í’ˆì§ˆ ì¡°ì • (íŒŒì¼ í¬ê¸° ìµœì í™”)
            
            // ğŸ“ í°íŠ¸ ë¯¸ë¦¬ ë¡œë“œ (í•œ ë²ˆë§Œ!)
            console.log('ğŸ”¤ í°íŠ¸ ë¯¸ë¦¬ ë¡œë”©...');
            const font = await Jimp.loadFont(Jimp.FONT_SANS_32_WHITE);
            const smallFont = await Jimp.loadFont(Jimp.FONT_SANS_16_WHITE);
            const laneFont = await Jimp.loadFont(Jimp.FONT_SANS_32_WHITE);

            // í”„ë ˆì„ ìƒì„±
            const frames = finalResults ? 1 : this.frameCount;
            console.log(`ğŸ“½ï¸ ì´ ${frames}ê°œ í”„ë ˆì„ ìƒì„± ì‹œì‘...`);
            
            for (let frame = 0; frame < frames; frame++) {
                if (frame % 10 === 0 || frame < 5 || frame >= frames - 5) {
                    console.log(`ğŸ“‹ í”„ë ˆì„ ${frame + 1}/${frames} ìƒì„± ì¤‘...`);
                }
                
                // ë°°ê²½ ë³µì‚¬ (ë§¤ë²ˆ ìƒˆë¡œ ë¡œë“œí•˜ì§€ ì•Šê³  ë³µì‚¬!)
                let image;
                if (backgroundTemplate) {
                    backgroundTemplate.resize(width, height);
                    image = backgroundTemplate.clone();
                } else {
                    image = await new Promise((resolve, reject) => {
                        new Jimp(width, height, '#4A0E0E', (err, img) => {
                            if (err) reject(err);
                            else resolve(img);
                        });
                    });
                }
                
                image.print(font, 0, 10, {
                    text: 'KIM HUNTER RACING',
                    alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER
                }, width);
                
                // ì°¸ê°€ì ìˆœì„œëŒ€ë¡œ ë ˆì´ì„œ ì •ë ¬ (ìœ„ì—ì„œ ì•„ë˜ë¡œ)
                const sortedRacers = [...racers].sort((a, b) => a.lane - b.lane);
                
                for (let i = 0; i < sortedRacers.length; i++) {
                    const y = 70 + i * 90; // í¬ê¸° ìµœì í™”ëœ ê°„ê²©
                    const racer = sortedRacers[i];
                    
                    // íŠ¸ë™ ì´ë¯¸ì§€ ë¡œë“œ (ì™„ì„±ëœ íŠ¸ë™ ì´ë¯¸ì§€ ì‚¬ìš©)
                    const trackWidth = width - 120;
                    const trackHeight = 80;
                    
                    if (trackImage) {
                        // ì»¤ìŠ¤í…€ íŠ¸ë™ ì´ë¯¸ì§€ ì‚¬ìš© (ì´ë¯¸ ë¡œë“œë¨!)
                        const trackImg = trackImage.clone();
                        trackImg.resize(trackWidth, trackHeight);
                        image.composite(trackImg, 60, y);
                    } else {
                        // ê¸°ë³¸ ìš©ì•” íŠ¸ë™ ìƒì„±
                        
                        // ìš©ì•” ëŠë‚Œì˜ íŠ¸ë™ ìƒì„±
                        const track = new Jimp(trackWidth, trackHeight, '#2A0A0A'); // ì–´ë‘ìš´ ìš©ì•” ìƒ‰
                        
                        // ìš©ì•” íŠ¸ë™ ê·¸ë¼ë°ì´ì…˜ íš¨ê³¼
                        for (let gradY = 0; gradY < trackHeight; gradY++) {
                            const progress = gradY / trackHeight;
                            const r = Math.floor(42 + progress * 50);  // 42-92
                            const g = Math.floor(10 + progress * 20);  // 10-30  
                            const b = Math.floor(10 + progress * 10);  // 10-20
                            
                            const gradLine = new Jimp(trackWidth, 1, Jimp.rgbaToInt(r, g, b, 255));
                            track.composite(gradLine, 0, gradY);
                        }
                        
                        // ìš©ì•” ëŠë‚Œ ì¤‘ì•™ì„  (ëœ¨ê±°ìš´ ë§ˆê·¸ë§ˆ ê°™ì´)
                        for (let dashX = 0; dashX < trackWidth; dashX += 25) {
                            const dashLine = new Jimp(15, 3, '#FF6600'); // ì£¼í™©ìƒ‰ ì¤‘ì•™ì„ 
                            dashLine.opacity(0.8);
                            track.composite(dashLine, dashX, Math.floor(trackHeight/2) - 1);
                            
                            // ê¸€ë¡œìš° íš¨ê³¼
                            const glow = new Jimp(20, 5, '#FFD700');
                            glow.opacity(0.3);
                            track.composite(glow, dashX - 2, Math.floor(trackHeight/2) - 2);
                        }
                        
                        // ìš©ì•” í…Œë‘ë¦¬ (ëœ¨ê±°ìš´ ê°€ì¥ìë¦¬)
                        const topBorder = new Jimp(trackWidth, 4, '#FF4500');
                        topBorder.opacity(0.9);
                        const bottomBorder = new Jimp(trackWidth, 4, '#FF4500');
                        bottomBorder.opacity(0.9);
                        track.composite(topBorder, 0, 0);
                        track.composite(bottomBorder, 0, trackHeight - 4);
                        
                        // ë°”ê¹¥ ê·¸ë¦¼ì
                        const topShadow = new Jimp(trackWidth, 2, '#000000');
                        topShadow.opacity(0.5);
                        const bottomShadow = new Jimp(trackWidth, 2, '#000000');
                        bottomShadow.opacity(0.5);
                        track.composite(topShadow, 0, 4);
                        track.composite(bottomShadow, 0, trackHeight - 6);
                        
                        // ìš©ì•” ê²°ìŠ¹ì„  (ëœ¨ê±°ìš´ ì²´í¬ íŒ¨í„´)
                        for (let checkY = 0; checkY < trackHeight; checkY += 6) {
                            for (let checkX = trackWidth - 12; checkX < trackWidth; checkX += 6) {
                                const isHot = (Math.floor(checkY/6) + Math.floor(checkX/6)) % 2 === 0;
                                const checkColor = isHot ? '#FFD700' : '#8B0000'; // ê¸ˆìƒ‰/ì§„í•œ ë¹¨ê°„ìƒ‰
                                const checkSquare = new Jimp(6, Math.min(6, trackHeight - checkY), checkColor);
                                checkSquare.opacity(0.9);
                                track.composite(checkSquare, checkX, checkY);
                            }
                        }
                        
                        image.composite(track, 60, y);
                    }
                    
                    // ë ˆì´ì„œ ì •ë³´ (ì´ë¯¸ ìœ„ì—ì„œ ì •ì˜ë¨)
                    let progress;
                    
                    if (finalResults) {
                        // ìµœì¢… ê²°ê³¼ í‘œì‹œ
                        progress = racer.finished ? 100 : (racer.position || 0);
                    } else {
                        // ì• ë‹ˆë©”ì´ì…˜ ì§„í–‰ (ëœë¤í•˜ì§€ë§Œ 3ë“±ê¹Œì§€ í™•ì‹¤íˆ ë„ì°©)
                        const frameProgress = frame / this.frameCount;
                        
                        // ì‹¤ì œ ë ˆì´ìŠ¤ ë°ì´í„°ê°€ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ ê¸°ì¡´ ë¡œì§
                        if (raceFrames && raceFrames.length > 0) {
                            // ì‹¤ì œ ë ˆì´ìŠ¤ í”„ë ˆì„ì—ì„œ í•´ë‹¹ í”„ë ˆì„ì˜ ë°ì´í„° ì°¾ê¸°
                            const frameIndex = Math.floor((frame / this.frameCount) * raceFrames.length);
                            const currentFrame = raceFrames[Math.min(frameIndex, raceFrames.length - 1)];
                            
                            if (currentFrame) {
                                const racerData = currentFrame.players.find(p => p.userId === racer.userId);
                                if (racerData) {
                                    progress = racerData.position;
                                    racer.currentProgress = progress;
                                } else {
                                    progress = 0;
                                }
                            } else {
                                progress = 0;
                            }
                        } else {
                            // ê¸°ì¡´ ëœë¤ ë¡œì§ (ë°±ì—…ìš©)
                            if (!racer.fixedSpeed) {
                                racer.fixedSpeed = Math.random() * 1.2 + 0.7;
                            }
                            
                            const mainRandomness = Math.sin(frame * 0.1 + i) * 0.08;
                            const microRandomness = (Math.random() - 0.5) * 0.05;
                            const totalRandomness = mainRandomness + microRandomness;
                            
                            let baseProgress = frameProgress * 0.85;
                            const speedMultiplier = racer.fixedSpeed;
                            
                            progress = Math.min(
                                (baseProgress + totalRandomness) * speedMultiplier * 100,
                                100
                            );
                            
                            racer.currentProgress = progress;
                            
                            if (frame >= this.frameCount * 0.8) {
                                const currentRanking = [...sortedRacers]
                                    .map(r => ({ ...r, currentProgress: r.currentProgress || 0 }))
                                    .sort((a, b) => b.currentProgress - a.currentProgress);
                                
                                const currentPosition = currentRanking.findIndex(r => r.userId === racer.userId) + 1;
                                
                                if (currentPosition > 3) {
                                    const boostProgress = (frame - this.frameCount * 0.8) / (this.frameCount * 0.2);
                                    const boost = boostProgress * 12;
                                    progress = Math.min(progress + boost, 100);
                                    racer.currentProgress = progress;
                                }
                            }
                        }
                    }
                    
                    // ì•„ë°”íƒ€ ìœ„ì¹˜
                    const avatarX = 60 + (width - 180) * (progress / 100);
                    
                    // ìŠ¤í”¼ë“œ ë¼ì¸ íš¨ê³¼ (ë¹ ë¥´ê²Œ ì›€ì§ì¼ ë•Œ)
                    if (!finalResults && racer.speed > 3) {
                        for (let s = 0; s < 3; s++) {
                            const lineX = avatarX - 40 - (s * 15);
                            if (lineX > 50) {
                                const speedLine = new Jimp(12, 3, '#FFFFFF');
                                speedLine.opacity(0.3 - s * 0.1);
                                image.composite(speedLine, lineX, y + 20 + s * 5);
                            }
                        }
                    }
                    
                    // ì•„ë°”íƒ€ ê·¸ë¦¬ê¸° (ìºì‹œëœ ì´ë¯¸ì§€ ì‚¬ìš©)
                    const cachedAvatar = avatarCache.get(racer.userId);
                    if (cachedAvatar) {
                        // ìš°ìŠ¹ì íš¨ê³¼ (ê³¨ë“  í…Œë‘ë¦¬) - ì•„ë°”íƒ€ì™€ ì •í™•íˆ ê°™ì€ ìœ„ì¹˜
                        if (finalResults && racer.finishPosition === 1) {
                            const goldBorder = new Jimp(66, 66, '#FFD700');
                            goldBorder.circle();
                            image.composite(goldBorder, avatarX - 33, y + 7); // ì•„ë°”íƒ€(y+10)ë³´ë‹¤ 3í”½ì…€ ìœ„ë¡œ
                        }
                        
                        // ìºì‹œëœ ì•„ë°”íƒ€ ë³µì‚¬ë³¸ ì‚¬ìš© (ì›ë³¸ ë³´í˜¸)
                        const avatarCopy = cachedAvatar.clone();
                        image.composite(avatarCopy, avatarX - 30, y + 10);
                    }
                    
                    // ë ˆì´ë„ˆ ë²ˆí˜¸ í‘œì‹œ (ìœ„ì—ì„œ ì•„ë˜ ìˆœì„œ)
                    const laneNumberBg = new Jimp(50, 50, '#2C2F33');
                    const laneNumberBorder = new Jimp(54, 54, '#FFFFFF');
                    image.composite(laneNumberBorder, 15, y + 25);
                    image.composite(laneNumberBg, 17, y + 27);
                    
                    // ë ˆì´ë„ˆ ë²ˆí˜¸ í…ìŠ¤íŠ¸ (ì˜ì–´ ìˆ«ìë¡œ)
                    image.print(laneFont, 17, y + 27, {
                        text: `${i + 1}`,
                        alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER,
                        alignmentY: Jimp.VERTICAL_ALIGN_MIDDLE
                    }, 50, 50);
                    
                    // ë² íŒ…ê¸ˆ í‘œì‹œ (ì•„ë°”íƒ€ì™€ ê°™ì€ ë¼ì¸ì—)
                    const betText = `${racer.betAmount.toLocaleString()}G`;
                    image.print(smallFont, 80, y + 30, {
                        text: betText,
                        alignmentX: Jimp.HORIZONTAL_ALIGN_LEFT
                    }, 200);
                    
                    // ìˆœìœ„ í‘œì‹œ (ìµœì¢… ê²°ê³¼ì¼ ë•Œ)
                    if (finalResults && racer.finishPosition > 0) {
                        const rankText = `#${racer.finishPosition}`;
                        image.print(font, width - 100, y + 15, rankText);
                    }
                    
                    // ì§„í–‰ë¥  ë°”
                    const barBg = new Jimp(width - 120, 8, '#1a1a1a');
                    image.composite(barBg, 60, y + 85);
                    
                    const progressWidth = Math.max(1, (width - 120) * (progress / 100));
                    const barFill = new Jimp(progressWidth, 8, racer.finished ? '#00FF00' : '#00AAFF');
                    image.composite(barFill, 60, y + 85);
                }
                
                // í•˜ë‹¨ ì •ë³´ë§Œ í‘œì‹œ (ìˆœìœ„ í…ìŠ¤íŠ¸ ì œê±°)
                if (!finalResults) {
                    const totalPot = racers.reduce((sum, r) => sum + r.betAmount, 0);
                    
                    // ìƒê¸ˆ ì •ë³´ë§Œ í‘œì‹œ
                    image.print(font, 0, height - 50, {
                        text: `TOTAL PRIZE: ${totalPot.toLocaleString()}G`,
                        alignmentX: Jimp.HORIZONTAL_ALIGN_CENTER
                    }, width);
                }
                
                // ìƒìœ„ 3ëª…ì´ ì™„ì£¼í–ˆëŠ”ì§€ í™•ì¸ (3ë“±ê¹Œì§€ ë„ì°© ëŒ€ê¸°)
                const currentRanking = [...sortedRacers]
                    .map(r => ({ ...r, currentProgress: r.currentProgress || 0 }))
                    .sort((a, b) => b.currentProgress - a.currentProgress);
                
                const topThreeFinished = currentRanking.slice(0, 3).every(r => r.currentProgress >= 99.9);
                
                // ë¡œê·¸ë¡œ ìƒìœ„ 3ëª… ì§„í–‰ë¥  í™•ì¸
                if (frame % 10 === 0) {
                    const top3Progress = currentRanking.slice(0, 3).map(r => 
                        `${r.nickname}: ${r.currentProgress?.toFixed(1) || 0}%`
                    );
                    console.log(`ğŸ“Š ìƒìœ„ 3ëª… ì§„í–‰ë¥ : ${top3Progress.join(', ')}`);
                }
                
                // ìƒìœ„ 3ëª… ì™„ì£¼ í›„ 1ì´ˆ ë” ëŒ€ê¸° (ê²°ê³¼ ê°ìƒ ì‹œê°„)
                if (!finalResults && topThreeFinished && frame >= 10) {
                    if (!this.finishStartFrame) {
                        this.finishStartFrame = frame;
                        console.log('ğŸ ìƒìœ„ 3ëª… ì™„ì£¼! 1ì´ˆ ë” ì§„í–‰ í›„ ì¢…ë£Œ');
                    }
                    
                    // 1ì´ˆ ë” ì§„í–‰ (170ms Ã— 6í”„ë ˆì„ = ì•½ 1ì´ˆ)
                    if (frame >= this.finishStartFrame + 6) {
                        console.log('âœ… ê²°ê³¼ ê°ìƒ ì‹œê°„ ì™„ë£Œ - ì• ë‹ˆë©”ì´ì…˜ ì¢…ë£Œ');
                        console.log('ìµœì¢… ìˆœìœ„:', currentRanking.slice(0, 3).map(r => 
                            `${r.nickname} (${r.currentProgress?.toFixed(1)}%)`
                        ));
                        break;
                    }
                }
                
                // í”„ë ˆì„ ì¶”ê°€
                encoder.addFrame(image.bitmap.data);
            }
            
            encoder.finish();
            
            // GIF ë²„í¼ ë°˜í™˜
            const buffer = encoder.out.getData();
            const endTime = Date.now();
            const generateTime = endTime - startTime;
            const sizeMB = (buffer.length / (1024 * 1024)).toFixed(2);
            
            console.log(`âœ… GIF ìƒì„± ì™„ë£Œ! í¬ê¸°: ${buffer.length} bytes (${sizeMB}MB), ì†Œìš”ì‹œê°„: ${generateTime}ms`);
            
            // Discord íŒŒì¼ í¬ê¸° ì œí•œ ì²´í¬ (8MB)
            const MAX_FILE_SIZE = 8 * 1024 * 1024; // 8MB
            if (buffer.length > MAX_FILE_SIZE) {
                console.log(`âš ï¸ íŒŒì¼ í¬ê¸°ê°€ Discord ì œí•œ(8MB)ì„ ì´ˆê³¼í•©ë‹ˆë‹¤. í˜„ì¬: ${sizeMB}MB`);
                console.log(`ğŸ“‰ ë” ì‘ì€ GIFë¥¼ ìƒì„±í•˜ê¸° ìœ„í•´ ì„¤ì •ì„ ì¡°ì •í•´ì£¼ì„¸ìš”.`);
                
                // í¬ê¸° ì´ˆê³¼ ì‹œì—ë„ ì¼ë‹¨ ë°˜í™˜ (ì¶”í›„ ì••ì¶• ë¡œì§ ì¶”ê°€ ê°€ëŠ¥)
                return buffer;
            } else {
                console.log(`âœ… Discord íŒŒì¼ í¬ê¸° ì œí•œ ë‚´ (${sizeMB}MB < 8MB)`);
                return buffer;
            }
            
        } catch (error) {
            console.error('âŒ ë ˆì´ì‹± GIF ìƒì„± ì˜¤ë¥˜:', error);
            console.error('ì—ëŸ¬ ìŠ¤íƒ:', error.stack);
            return null;
        }
    }

    // ë ˆì´ìŠ¤ ì°¸ê°€
    async joinRace(userId, betAmount, user, avatar, channel = null) {
        // ë² íŒ… ê¸ˆì•¡ ê²€ì¦
        if (betAmount < this.minBet || betAmount > this.maxBet) {
            return { 
                success: false, 
                message: `ë² íŒ… ê¸ˆì•¡ì€ ${this.minBet.toLocaleString()}~${this.maxBet.toLocaleString()}<:currency_emoji:1377404064316522778> ë²”ìœ„ì—¬ì•¼ í•©ë‹ˆë‹¤!` 
            };
        }

        if (user.gold < betAmount) {
            return { success: false, message: 'ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!' };
        }

        // ì´ë¯¸ ì°¸ê°€ì¤‘ì¸ì§€ í™•ì¸
        if (this.waitingPlayers.has(userId)) {
            return { success: false, message: 'ì´ë¯¸ ë ˆì´ìŠ¤ì— ì°¸ê°€í•˜ì…¨ìŠµë‹ˆë‹¤!' };
        }

        // ì°¸ê°€ì ìˆ˜ ì œí•œ
        if (this.waitingPlayers.size >= this.maxPlayers) {
            return { success: false, message: `ì°¸ê°€ìê°€ ê½‰ ì°¼ìŠµë‹ˆë‹¤! (ìµœëŒ€ ${this.maxPlayers}ëª…)` };
        }

        // ê³¨ë“œ ì°¨ê° ë° ì°¸ê°€ ë“±ë¡
        user.gold -= betAmount;
        await user.save();

        const player = {
            userId,
            nickname: user.nickname,
            avatar: avatar || `https://cdn.discordapp.com/embed/avatars/${userId % 5}.png`, // ê¸°ë³¸ ì•„ë°”íƒ€
            betAmount,
            position: 0,
            speed: 0,
            lane: this.waitingPlayers.size,
            finished: false,
            finishPosition: 0
        };

        this.waitingPlayers.set(userId, player);

        // ì²« ë²ˆì§¸ ì°¸ê°€ìì¼ ë•Œ ë´‡ íƒ€ì´ë¨¸ ì‹œì‘
        if (this.waitingPlayers.size === 1 && !this.botTimer) {
            this.startBotTimer(channel);
        }

        // ìµœì†Œ ì¸ì› ì¶©ì¡±ì‹œ ë ˆì´ìŠ¤ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
        if (this.waitingPlayers.size >= this.minPlayers && !this.raceStartTimer) {
            this.startCountdown(channel);
            // ë´‡ íƒ€ì´ë¨¸ê°€ ìˆìœ¼ë©´ ì·¨ì†Œ
            if (this.botTimer) {
                clearTimeout(this.botTimer);
                this.botTimer = null;
            }
        }

        return { 
            success: true, 
            message: `${betAmount.toLocaleString()}<:currency_emoji:1377404064316522778>ë¡œ ë ˆì´ìŠ¤ì— ì°¸ê°€í–ˆìŠµë‹ˆë‹¤!`,
            currentPlayers: this.waitingPlayers.size,
            totalPot: this.getTotalPot()
        };
    }

    // ë ˆì´ìŠ¤ ë‚˜ê°€ê¸°
    async leaveRace(userId) {
        const player = this.waitingPlayers.get(userId);
        if (!player) {
            return { success: false, message: 'ë ˆì´ìŠ¤ì— ì°¸ê°€í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤!' };
        }

        // ê³¨ë“œ í™˜ë¶ˆ
        const user = await getUser(userId);
        user.gold += player.betAmount;
        await user.save();

        this.waitingPlayers.delete(userId);

        // ë ˆì¸ ì¬ì •ë ¬
        let lane = 0;
        for (const [playerId, playerData] of this.waitingPlayers) {
            playerData.lane = lane++;
        }

        // ìµœì†Œ ì¸ì› ë¯¸ë‹¬ì‹œ íƒ€ì´ë¨¸ ì·¨ì†Œ
        if (this.waitingPlayers.size < this.minPlayers && this.raceStartTimer) {
            clearTimeout(this.raceStartTimer);
            this.raceStartTimer = null;
        }

        // ì°¸ê°€ìê°€ ì—†ì–´ì§€ë©´ ë´‡ íƒ€ì´ë¨¸ ì‹œì‘
        if (this.waitingPlayers.size === 1 && !this.botTimer && !this.raceStartTimer) {
            this.startBotTimer(channel);
        } else if (this.waitingPlayers.size === 0) {
            // ëª¨ë“  ì°¸ê°€ìê°€ ë‚˜ê°€ë©´ ëª¨ë“  íƒ€ì´ë¨¸ ì·¨ì†Œ
            if (this.botTimer) {
                clearTimeout(this.botTimer);
                this.botTimer = null;
            }
        }

        return { 
            success: true, 
            message: `ë ˆì´ìŠ¤ì—ì„œ ë‚˜ê°”ìŠµë‹ˆë‹¤. ${player.betAmount.toLocaleString()}<:currency_emoji:1377404064316522778>ì´ í™˜ë¶ˆë˜ì—ˆìŠµë‹ˆë‹¤.`,
            currentPlayers: this.waitingPlayers.size,
            totalPot: this.getTotalPot()
        };
    }

    // ì´ ìƒê¸ˆ ê³„ì‚°
    getTotalPot() {
        return Array.from(this.waitingPlayers.values()).reduce((sum, p) => sum + p.betAmount, 0);
    }

    // ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
    startCountdown(channel = null) {
        this.raceStartTimer = setTimeout(async () => {
            if (this.waitingPlayers.size >= this.minPlayers) {
                await this.startRace(channel);
            }
        }, this.waitTime);
    }

    // ë´‡ íƒ€ì´ë¨¸ ì‹œì‘
    startBotTimer(channel = null) {
        this.botTimer = setTimeout(async () => {
            if (this.waitingPlayers.size > 0 && this.waitingPlayers.size < this.minPlayers) {
                await this.addBots(channel);
            }
        }, this.botWaitTime);
    }

    // ë´‡ ì¶”ê°€
    async addBots(channel = null) {
        const currentPlayerCount = this.waitingPlayers.size;
        const botsNeeded = this.minPlayers - currentPlayerCount;
        
        if (botsNeeded <= 0 || currentPlayerCount === 0) return;

        // ê¸°ì¡´ ì°¸ê°€ìë“¤ì˜ í‰ê·  ë² íŒ… ê¸ˆì•¡ ê³„ì‚°
        const existingPlayers = Array.from(this.waitingPlayers.values());
        const avgBet = Math.floor(
            existingPlayers.reduce((sum, p) => sum + p.betAmount, 0) / existingPlayers.length
        );

        // ë´‡ë“¤ ì¶”ê°€
        for (let i = 0; i < botsNeeded; i++) {
            const botId = `bot_${Date.now()}_${i}`;
            const botName = this.getRandomBotName();
            
            // í‰ê·  ë² íŒ…ì•¡ Â±20% ë²”ìœ„ì—ì„œ ë´‡ ë² íŒ… ì„¤ì •
            const variationPercent = (Math.random() - 0.5) * 0.4; // -0.2 ~ 0.2
            const botBet = Math.max(
                this.minBet,
                Math.min(
                    this.maxBet,
                    Math.floor(avgBet * (1 + variationPercent))
                )
            );

            const botPlayer = {
                userId: botId,
                nickname: `ğŸ¤– ${botName}`,
                avatar: 'https://cdn.discordapp.com/embed/avatars/0.png',
                betAmount: botBet,
                position: 0,
                speed: 0,
                lane: this.waitingPlayers.size,
                finished: false,
                finishPosition: 0,
                isBot: true
            };

            this.waitingPlayers.set(botId, botPlayer);
        }

        // ë´‡ ì¶”ê°€ ì•Œë¦¼
        if (channel) {
            const botEmbed = new EmbedBuilder()
                .setColor('#4CAF50')
                .setTitle('ğŸ¤– ë´‡ ë§¤ì¹­ ì™„ë£Œ!')
                .setDescription(`ì°¸ê°€ìê°€ ë¶€ì¡±í•˜ì—¬ **${botsNeeded}ëª…ì˜ ë´‡**ì´ ìë™ìœ¼ë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!\n\nâ° **1ë¶„ í›„ ë ˆì´ìŠ¤ê°€ ì‹œì‘ë©ë‹ˆë‹¤!**`)
                .addFields(
                    { name: 'í˜„ì¬ ì°¸ê°€ì', value: `ì´ ${this.waitingPlayers.size}ëª… (í”Œë ˆì´ì–´ ${currentPlayerCount}ëª… + ë´‡ ${botsNeeded}ëª…)`, inline: true },
                    { name: 'ğŸ’° ì´ ìƒê¸ˆí’€', value: `${this.getTotalPot().toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true }
                )
                .setFooter({ text: 'ğŸ² ë´‡ë„ ì™„ì „ ëœë¤! ëˆ„êµ¬ë‚˜ ìš°ìŠ¹ ê°€ëŠ¥í•©ë‹ˆë‹¤!' });

            await channel.send({ embeds: [botEmbed] });
        }

        // ë ˆì´ìŠ¤ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
        this.startCountdown(channel);
        this.botTimer = null;
    }

    // ëœë¤ ë´‡ ì´ë¦„ ì„ íƒ
    getRandomBotName() {
        const usedNames = Array.from(this.waitingPlayers.values())
            .filter(p => p.isBot)
            .map(p => p.nickname.replace('ğŸ¤– ', ''));
        
        const availableNames = this.botNames.filter(name => !usedNames.includes(name));
        
        if (availableNames.length === 0) {
            return `ë´‡${Math.floor(Math.random() * 1000)}`;
        }
        
        return availableNames[Math.floor(Math.random() * availableNames.length)];
    }

    // ì™„ì „ ëœë¤ ë ˆì´ìŠ¤ ì‹œë®¬ë ˆì´ì…˜
    simulateRace() {
        const players = Array.from(this.waitingPlayers.values());
        const raceFrames = [];
        
        // í”Œë ˆì´ì–´ ì´ˆê¸°í™”
        players.forEach(player => {
            player.position = 0; // ì‹œì‘ ìœ„ì¹˜
            player.speed = 0; // ì´ˆê¸° ì†ë„
            player.finished = false; // ì™„ì£¼ ì—¬ë¶€
            player.finishPosition = 0; // ìˆœìœ„
        });
        
        // 120í”„ë ˆì„ (12ì´ˆ) ë ˆì´ìŠ¤
        for (let frame = 0; frame < 120; frame++) {
            players.forEach(player => {
                if (!player.finished) {
                    // ì™„ì „ ëœë¤ ì†ë„ (ìŠ¤íƒ¯ ë¬´ê´€!)
                    player.speed = Math.random() * 4 + 1; // 1-5 ì†ë„
                    
                    // íŠ¹ë³„ ì´ë²¤íŠ¸ (ì™„ì „ ìš´ë¹¨)
                    if (Math.random() < 0.05) {
                        player.speed *= 2; // 5% ëŸ­í‚¤ ë¶€ìŠ¤í„°!
                    }
                    if (Math.random() < 0.03) {
                        player.speed *= 0.3; // 3% ì–¸ëŸ­í‚¤ ìŠ¬ë¦½!
                    }
                    
                    // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                    player.position = Math.min(player.position + player.speed * 0.8, 100);
                    
                    // ê²°ìŠ¹ì„  ì²´í¬
                    if (player.position >= 100 && !player.finished) {
                        player.finished = true;
                        // í˜„ì¬ê¹Œì§€ ì™„ì£¼í•œ í”Œë ˆì´ì–´ ìˆ˜ + 1 (ìì‹  í¬í•¨)
                        const finishedCount = players.filter(p => p.finished).length;
                        player.finishPosition = finishedCount;
                        console.log(`í”Œë ˆì´ì–´ ${player.nickname}ì´ ${player.finishPosition}ìœ„ë¡œ ì™„ì£¼í–ˆìŠµë‹ˆë‹¤!`);
                    }
                }
            });
            
            // í˜„ì¬ í”„ë ˆì„ ì €ì¥
            raceFrames.push({
                frame,
                players: players.map(p => ({
                    userId: p.userId,
                    nickname: p.nickname,
                    position: Math.round(p.position * 10) / 10,
                    speed: Math.round(p.speed * 10) / 10,
                    finished: p.finished,
                    lane: p.lane
                }))
            });
            
            // ëª¨ë“  í”Œë ˆì´ì–´ê°€ ì™„ì£¼í•˜ë©´ ì¢…ë£Œ
            if (players.every(p => p.finished)) break;
        }
        
        return raceFrames;
    }

    // ë ˆì´ìŠ¤ ì‹œì‘
    async startRace(channel = null) {
        if (this.isRacing) return;
        this.isRacing = true;

        try {
            const players = Array.from(this.waitingPlayers.values());
            const totalPot = this.getTotalPot();
            
            // ë ˆì´ìŠ¤ ì‹œì‘ ì•Œë¦¼
            if (channel) {
                const startEmbed = new EmbedBuilder()
                    .setColor('#FF6B6B')
                    .setTitle('ğŸ ë ˆì´ìŠ¤ ì¤€ë¹„ì¤‘!')
                    .setDescription(`**ì„ ìˆ˜ë“¤ì´ ê²½ê¸°ì¥ì— ì…ì¥ì¤‘...**\n\n${players.length}ëª…ì˜ ë ˆì´ì„œê°€ **${totalPot.toLocaleString()}<:currency_emoji:1377404064316522778>** ìƒê¸ˆì„ ë†“ê³  ê²½ì£¼í•©ë‹ˆë‹¤!`)
                    .addFields(
                        { name: 'ğŸƒâ€â™‚ï¸ ì°¸ê°€ì', value: players.map((p, i) => `${i + 1}ë²ˆ ${p.nickname}`).join('\n'), inline: true },
                        { name: 'ğŸ’° ë² íŒ…ê¸ˆ', value: players.map(p => `${p.betAmount.toLocaleString()}<:currency_emoji:1377404064316522778>`).join('\n'), inline: true }
                    )
                    .setFooter({ text: 'ğŸ² ì™„ì „ ìš´ë¹¨! ëˆ„ê°€ ì´ê¸¸ê¹Œìš”?' });
                
                const startMsg = await channel.send({ embeds: [startEmbed] });
                
            }

            const raceFrames = this.simulateRace();
            
            // ìˆœìœ„ ê²°ì • (ì™„ì£¼ ì‹œê°„ ê¸°ì¤€, ë¯¸ì™„ì£¼ëŠ” ì§„í–‰ë¥  ê¸°ì¤€)
            players.sort((a, b) => {
                if (a.finished && b.finished) {
                    // ë‘˜ ë‹¤ ì™„ì£¼í•œ ê²½ìš°: ì™„ì£¼ ìˆœì„œë¡œ ì •ë ¬
                    return a.finishPosition - b.finishPosition;
                } else if (a.finished && !b.finished) {
                    // aë§Œ ì™„ì£¼í•œ ê²½ìš°: aê°€ ë” ë†’ì€ ìˆœìœ„
                    return -1;
                } else if (!a.finished && b.finished) {
                    // bë§Œ ì™„ì£¼í•œ ê²½ìš°: bê°€ ë” ë†’ì€ ìˆœìœ„
                    return 1;
                } else {
                    // ë‘˜ ë‹¤ ë¯¸ì™„ì£¼í•œ ê²½ìš°: ì§„í–‰ë¥ ë¡œ ì •ë ¬ (ë†’ì€ ì§„í–‰ë¥ ì´ ë” ë†’ì€ ìˆœìœ„)
                    return b.position - a.position;
                }
            });
            
            console.log('ìµœì¢… ìˆœìœ„:');
            players.forEach((player, index) => {
                console.log(`${index + 1}ìœ„: ${player.nickname} (ì™„ì£¼: ${player.finished}, ì§„í–‰ë¥ : ${player.position}%, ì™„ì£¼ìˆœì„œ: ${player.finishPosition})`);
            });

            const winner = players[0];
            
            // ë ˆì´ì‹± GIF ìƒì„± ë° í‘œì‹œ
            if (channel) {
                try {
                    // ë ˆì´ì‹± ì• ë‹ˆë©”ì´ì…˜ GIF ìƒì„± (ì‹¤ì œ ë ˆì´ìŠ¤ ë°ì´í„° ì‚¬ìš©)
                    const raceGifBuffer = await this.createRaceGIF(players, false, raceFrames);
                    
                    if (raceGifBuffer) {
                        console.log('ğŸ“¤ GIF ì „ì†¡ ì‹œì‘...');
                        const raceAttachment = new AttachmentBuilder(raceGifBuffer, { name: 'race_animation.gif' });
                        
                        try {
                            // ì„ë² ë“œ ì—†ì´ ì§ì ‘ GIF ì „ì†¡ (ë” í¬ê²Œ ë³´ì„)
                            const sentMessage = await channel.send({ 
                                content: 'ğŸ **ë ˆì´ìŠ¤ ì§„í–‰ì¤‘!** ğŸ\nì‹¤ì‹œê°„ ë ˆì´ì‹± ì§„í–‰ ìƒí™©ì„ í™•ì¸í•˜ì„¸ìš”!',
                                files: [raceAttachment] 
                            });
                            console.log('âœ… GIF ì „ì†¡ ì„±ê³µ!');
                            
                            // ë ˆì´ìŠ¤ ì§„í–‰ ì‹œê°„ ì—°ì¥ (12ì´ˆ ëŒ€ê¸° - ëª¨ë“  ë ˆì´ì„œ ë„ì°© ë³´ì¥)
                            await new Promise(resolve => setTimeout(resolve, 12000));
                        } catch (sendError) {
                            console.error('âŒ GIF ì „ì†¡ ì‹¤íŒ¨:', sendError);
                            console.error('ì „ì†¡ ì—ëŸ¬ ì„¸ë¶€ì‚¬í•­:', sendError.message);
                        }
                    } else {
                        console.log('âš ï¸ GIF ë²„í¼ê°€ ë¹„ì–´ìˆìŒ - ì „ì†¡ ìŠ¤í‚µ');
                    }
                } catch (error) {
                    console.error('âŒ ë ˆì´ì‹± GIF ìƒì„±/ì „ì†¡ ì˜¤ë¥˜:', error);
                    console.error('ì „ì²´ ì—ëŸ¬ ìŠ¤íƒ:', error.stack);
                    
                    // GIF ì‹¤íŒ¨ ì‹œ í…ìŠ¤íŠ¸ë§Œ ì „ì†¡
                    try {
                        await channel.send('âŒ ë ˆì´ìŠ¤ ì• ë‹ˆë©”ì´ì…˜ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ê²°ê³¼ë§Œ í‘œì‹œí•©ë‹ˆë‹¤.');
                    } catch (e) {
                        console.error('í…ìŠ¤íŠ¸ ì „ì†¡ë„ ì‹¤íŒ¨:', e);
                    }
                }
            }

            // ìš°ìŠ¹ìì—ê²Œ ìƒê¸ˆ ì§€ê¸‰ (ë´‡ì´ ì´ê¸°ë©´ 2ìœ„ ì‹¤ì œ í”Œë ˆì´ì–´ê°€ ìƒê¸ˆ íšë“)
            const actualWinner = await this.awardPrize(winner, totalPot, players);
            
            // ê²°ê³¼ ë°œí‘œ
            if (channel) {
                const isWinnerBot = winner.isBot;
                const displayWinner = actualWinner || winner;
                
                let resultDescription = '';
                if (isWinnerBot && actualWinner) {
                    resultDescription = `ğŸ¤– **${winner.nickname}**ì´ 1ìœ„ë¡œ ì™„ì£¼í–ˆì§€ë§Œ,\nì‹¤ì œ ìƒê¸ˆì€ ìµœê³  ìˆœìœ„ í”Œë ˆì´ì–´ì¸ **${actualWinner.nickname}**ë‹˜ì´ íšë“í–ˆìŠµë‹ˆë‹¤!\n\nğŸ’° ìƒê¸ˆ **${totalPot.toLocaleString()}<:currency_emoji:1377404064316522778>**ì„ íšë“í–ˆìŠµë‹ˆë‹¤!`;
                } else if (isWinnerBot) {
                    resultDescription = `ğŸ¤– **${winner.nickname}**ì´ ìš°ìŠ¹í–ˆìŠµë‹ˆë‹¤!\n\nğŸ’¸ ëª¨ë“  ì°¸ê°€ìê°€ ë´‡ì´ì—ˆìœ¼ë¯€ë¡œ ìƒê¸ˆì€ ì†Œë©¸ë©ë‹ˆë‹¤.`;
                } else {
                    resultDescription = `**${winner.nickname}**ë‹˜ì´ ìš°ìŠ¹í–ˆìŠµë‹ˆë‹¤!\n\nğŸ’° ìƒê¸ˆ **${totalPot.toLocaleString()}<:currency_emoji:1377404064316522778>**ì„ íšë“í–ˆìŠµë‹ˆë‹¤!`;
                }

                // ìµœì¢… ê²°ê³¼ ì´ë¯¸ì§€ ìƒì„±
                let resultAttachment = null;
                try {
                    const resultGifBuffer = await this.createRaceGIF(players, true);
                    if (resultGifBuffer) {
                        resultAttachment = new AttachmentBuilder(resultGifBuffer, { name: 'race_result.png' });
                    }
                } catch (error) {
                    console.error('ê²°ê³¼ ì´ë¯¸ì§€ ìƒì„± ì˜¤ë¥˜:', error);
                }
                
                const resultEmbed = new EmbedBuilder()
                    .setColor('#FFD700')
                    .setTitle('ğŸ† ë ˆì´ìŠ¤ ê²°ê³¼!')
                    .setDescription(resultDescription)
                    .setFooter({ text: 'ğŸ² ë‹¤ìŒ ë ˆì´ìŠ¤ì—ë„ ë„ì „í•´ë³´ì„¸ìš”!' });
                
                if (resultAttachment) {
                    resultEmbed.setImage('attachment://race_result.png');
                }
                
                // ìˆœìœ„ í‘œì‹œ
                const rankText = players.map((p, i) => 
                    `${i + 1}ìœ„: ${p.nickname} (${p.betAmount.toLocaleString()}<:currency_emoji:1377404064316522778>)`
                ).join('\n');
                resultEmbed.addFields({ name: 'ğŸ“Š ìµœì¢… ìˆœìœ„', value: rankText, inline: false });
                
                const messageOptions = { embeds: [resultEmbed] };
                if (resultAttachment) {
                    messageOptions.files = [resultAttachment];
                }
                
                await channel.send(messageOptions);
            }

            // ë ˆì´ì‹± ë°ì´í„° ë°˜í™˜
            return {
                success: true,
                winner,
                totalPot,
                players,
                raceFrames: raceFrames.filter((_, i) => i % 4 === 0) // 30í”„ë ˆì„ìœ¼ë¡œ ì••ì¶•
            };

        } catch (error) {
            console.error('ë ˆì´ìŠ¤ ì‹œë®¬ë ˆì´ì…˜ ì˜¤ë¥˜:', error);
            return { success: false, error: 'ë ˆì´ìŠ¤ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.' };
        } finally {
            this.isRacing = false;
            this.waitingPlayers.clear();
            this.raceStartTimer = null;
        }
    }

    // ìƒê¸ˆ ì§€ê¸‰ ë° í†µê³„ ì—…ë°ì´íŠ¸
    async awardPrize(winner, totalPot, allPlayers) {
        try {
            let actualWinner = winner;
            let prizeAwarded = false;

            // ë´‡ì´ ìš°ìŠ¹í•œ ê²½ìš° ì‹¤ì œ í”Œë ˆì´ì–´ ì¤‘ ìµœê³  ìˆœìœ„ìì—ê²Œ ìƒê¸ˆ ì§€ê¸‰
            if (winner.isBot) {
                const realPlayers = allPlayers.filter(p => !p.isBot);
                if (realPlayers.length > 0) {
                    actualWinner = realPlayers[0]; // ì‹¤ì œ í”Œë ˆì´ì–´ ì¤‘ 1ìœ„
                    const winnerUser = await getUser(actualWinner.userId);
                    winnerUser.gold += totalPot;
                    await winnerUser.save();
                    prizeAwarded = true;
                }
                // ì‹¤ì œ í”Œë ˆì´ì–´ê°€ ì—†ìœ¼ë©´ ìƒê¸ˆ ì†Œë©¸
            } else {
                // ì‹¤ì œ í”Œë ˆì´ì–´ê°€ ìš°ìŠ¹í•œ ê²½ìš°
                const winnerUser = await getUser(winner.userId);
                winnerUser.gold += totalPot;
                await winnerUser.save();
                prizeAwarded = true;
            }

            // ë ˆì´ì‹± í†µê³„ ì—…ë°ì´íŠ¸ (ì‹¤ì œ í”Œë ˆì´ì–´ë§Œ)
            const realPlayers = allPlayers.filter(p => !p.isBot);
            for (const player of realPlayers) {
                const user = await getUser(player.userId);
                
                // ê¸°ë³¸ í†µê³„ ì´ˆê¸°í™”
                if (!user.racingStats) {
                    user.racingStats = {
                        totalRaces: 0,
                        wins: 0,
                        totalWinnings: 0,
                        totalSpent: 0,
                        longestWinStreak: 0,
                        currentWinStreak: 0,
                        biggestWin: 0,
                        lastRaceDate: null
                    };
                }

                user.racingStats.totalRaces += 1;
                user.racingStats.totalSpent += player.betAmount;
                user.racingStats.lastRaceDate = new Date();

                if (prizeAwarded && player.userId === actualWinner.userId) {
                    // ì‹¤ì œ ìš°ìŠ¹ì í†µê³„
                    user.racingStats.wins += 1;
                    user.racingStats.totalWinnings += totalPot;
                    user.racingStats.currentWinStreak += 1;
                    user.racingStats.longestWinStreak = Math.max(
                        user.racingStats.longestWinStreak, 
                        user.racingStats.currentWinStreak
                    );
                    user.racingStats.biggestWin = Math.max(user.racingStats.biggestWin, totalPot);
                } else {
                    // íŒ¨ë°°ì‹œ ì—°ìŠ¹ ì´ˆê¸°í™”
                    user.racingStats.currentWinStreak = 0;
                }

                await user.save();
            }

            // ì£¼ì‹ ì‹œì¥ ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±°
            recordPlayerAction('racing_event', { 
                potSize: totalPot, 
                participants: allPlayers.length 
            });

            // ì‹¤ì œ ìš°ìŠ¹ì ë°˜í™˜ (ìƒê¸ˆì„ ë°›ì€ í”Œë ˆì´ì–´)
            return prizeAwarded ? actualWinner : null;

        } catch (error) {
            console.error('ìƒê¸ˆ ì§€ê¸‰ ì˜¤ë¥˜:', error);
            return null;
        }
    }

    // í˜„ì¬ ëŒ€ê¸° ìƒíƒœ ì •ë³´
    getRaceStatus() {
        const players = Array.from(this.waitingPlayers.values());
        const totalPot = this.getTotalPot();
        const countdown = this.raceStartTimer ? this.waitTime : 0;

        return {
            isRacing: this.isRacing,
            playerCount: players.length,
            players,
            totalPot,
            countdown,
            canStart: players.length >= this.minPlayers,
            isFull: players.length >= this.maxPlayers
        };
    }

    // ë ˆì´ìŠ¤ ì´ˆê¸°í™” (ê´€ë¦¬ììš©)
    resetRace() {
        if (this.raceStartTimer) {
            clearTimeout(this.raceStartTimer);
            this.raceStartTimer = null;
        }
        if (this.botTimer) {
            clearTimeout(this.botTimer);
            this.botTimer = null;
        }
        this.isRacing = false;
        this.waitingPlayers.clear();
    }
}

// ë ˆì´ì‹± ì‹œìŠ¤í…œ ì¸ìŠ¤í„´ìŠ¤
const raceSystem = new BettingRaceSystem();

// ğŸ‰ ëª¬ìŠ¤í„° ë°°í‹€ ì•„ë ˆë‚˜ ì‹œìŠ¤í…œ í´ë˜ìŠ¤
class MonsterBattleSystem {
    constructor() {
        this.gameStats = {
            totalGames: 0,
            recentNumbers: [], // ìµœê·¼ 100ê°œ ê²°ê³¼
            hotNumbers: new Map(), // ìˆ«ìë³„ ë“±ì¥ íšŸìˆ˜
            biggestWins: [] // ìµœëŒ€ ë‹¹ì²¨ ê¸°ë¡
        };
        this.activeGames = new Map(); // userId -> ê²Œì„ ìƒíƒœ
    }

    // ëª¬ìŠ¤í„° ë°°í‹€ ì•„ë ˆë‚˜ ë©”ì¸ ë©”ë‰´
    async showMonsterBattleMenu(interaction) {
        const user = await User.findOne({ discordId: interaction.user.id });
        if (!user) {
            return interaction.reply({ content: 'âŒ  ë“±ë¡ë˜ì§€ ì•Šì€ ì‚¬ìš©ìì…ë‹ˆë‹¤.', flags: 64 });
        }

        const stats = user.oddEvenStats || {};
        const winRate = stats.totalGames > 0 ? ((stats.wins / stats.totalGames) * 100).toFixed(1) : '0.0';

        const embed = new EmbedBuilder()
            .setTitle('ğŸ‰ ëª¬ìŠ¤í„° ë°°í‹€ ì•„ë ˆë‚˜ ğŸ‰')
            .setDescription('**âš”ï¸ ë°°í‹€ ë°©ì‹:** 1~100 ë ˆë²¨ ëª¬ìŠ¤í„°ê°€ ëœë¤ ë“±ì¥! ëª¬ìŠ¤í„°ì˜ íŠ¹ì„±ì„ ì˜ˆì¸¡í•˜ì—¬ ìŠ¹ë¶€!\n' +
                '**âœ¨ ë‹¤ì¤‘ ì˜ˆì¸¡:** ì—¬ëŸ¬ íŠ¹ì„±ì— ë™ì‹œ ì˜ˆì¸¡ ê°€ëŠ¥! (ì˜ˆ: í™€ìˆ˜ë ˆë²¨+ì•½í•œëª¬ìŠ¤í„°)\n\n' +
                '**ğŸ¯ ì˜ˆì¸¡ ì˜µì…˜:**\n' +
                'âš¡ **í™€ìˆ˜ ë ˆë²¨** (1,3,5,7...) - ë³´ìƒ 1.95ë°°\n' +
                'ğŸŒ™ **ì§ìˆ˜ ë ˆë²¨** (2,4,6,8...) - ë³´ìƒ 1.95ë°°\n' +
                'ğŸ› **ì•½í•œ ëª¬ìŠ¤í„°** (1~50ë ˆë²¨) - ë³´ìƒ 1.95ë°°\n' +
                'ğŸ² **ê°•í•œ ëª¬ìŠ¤í„°** (51~100ë ˆë²¨) - ë³´ìƒ 1.95ë°°\n' +
                'ğŸ€ **ì„¸ë¸ ë°°ìˆ˜ ë ˆë²¨** (7,14,21...) - ë³´ìƒ 13.0ë°°\n' +
                'ğŸ’ **ì •í™•í•œ ë ˆë²¨ ì˜ˆì¸¡** (1~100ë ˆë²¨) - ë³´ìƒ 99.0ë°°\n\n' +
                '**âš”ï¸ ì˜ˆì‹œ:** ë ˆë²¨ 42 ì˜¤í¬ê°€ ë“±ì¥!\n' +
                'âœ… ì§ìˆ˜ ë ˆë²¨ ì ì¤‘! âœ… ì•½í•œ ëª¬ìŠ¤í„° ì ì¤‘! âœ… ì„¸ë¸ ë°°ìˆ˜ ì ì¤‘!')
            .addFields(
                { name: 'ğŸ’° í˜„ì¬ ê³¨ë“œ', value: `${user.gold.toLocaleString()}G`, inline: true },
                { name: 'ğŸ¯ ìŠ¹ë¥ ', value: `${winRate}%`, inline: true },
                { name: 'ğŸ”¥ ì—°ìŠ¹', value: `${stats.currentStreak || 0}íšŒ`, inline: true },
                { name: 'âš”ï¸ ì´ ë°°í‹€', value: `${stats.totalGames || 0}íšŒ`, inline: true },
                { name: 'ğŸ’ ìµœëŒ€ ë³´ìƒ', value: `${(stats.biggestWin || 0).toLocaleString()}G`, inline: true },
                { name: 'ğŸ“ˆ ì´ ìˆ˜ìµ', value: `${((stats.totalWinnings || 0) - (stats.totalBets || 0)).toLocaleString()}G`, inline: true }
            )
            .setColor('#FFD700');

        // ìµœê·¼ ëª¬ìŠ¤í„° ë“±ì¥ ê¸°ë¡
        if (this.gameStats.recentNumbers.length > 0) {
            const recent = this.gameStats.recentNumbers.slice(-10).reverse();
            embed.addFields({
                name: 'ğŸ‘¹ ìµœê·¼ ë“±ì¥ ëª¬ìŠ¤í„°',
                value: recent.map(level => {
                    const isOdd = level % 2 === 1;
                    const isWeak = level <= 50;
                    return `\`Lv.${level}\` ${isOdd ? 'âš¡' : 'ğŸŒ™'}${isWeak ? 'ğŸ›' : 'ğŸ²'}`;
                }).join(' '),
                inline: false
            });
        }

        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('monster_battle')
                    .setLabel('âš”ï¸ ë°°í‹€ ì°¸ê°€')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId('monster_stats')
                    .setLabel('ğŸ“Š í—Œí„° ê¸°ë¡')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId('monster_history')
                    .setLabel('ğŸ“œ ë°°í‹€ ê¸°ë¡')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId('monster_ranking')
                    .setLabel('ğŸ† í—Œí„° ë­í‚¹')
                    .setStyle(ButtonStyle.Success)
            );

        if (interaction.replied || interaction.deferred) {
            await interaction.editReply({ embeds: [embed], components: [row] });
        } else {
            await interaction.reply({ embeds: [embed], components: [row] });
        }
    }

    // ë² íŒ… ë©”ë‰´ í‘œì‹œ (ì¤‘ë³µ ë² íŒ… ì§€ì›)
    async showBettingMenu(interaction) {
        const user = await User.findOne({ discordId: interaction.user.id });
        
        if (!user) {
            await interaction.reply({ content: 'ì‚¬ìš©ì ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', flags: 64 });
            return;
        }
        
        // í˜„ì¬ ë² íŒ… ì´ˆê¸°í™” (ìƒˆë¡œìš´ ë² íŒ… ì‹œì‘)
        if (!user.oddEvenStats) {
            user.oddEvenStats = {};
        }
        if (!user.oddEvenStats.currentBets) {
            user.oddEvenStats.currentBets = [];
        }
        
        let description = `**í˜„ì¬ ê³¨ë“œ:** ${user.gold.toLocaleString()}G\n`;
        description += `**ìµœì†Œ ë² íŒ…:** ${MONSTER_BATTLE.betLimits.min.toLocaleString()}G | **ìµœëŒ€ ë² íŒ…:** ${(user.level >= 50 ? MONSTER_BATTLE.betLimits.vip_max : MONSTER_BATTLE.betLimits.max).toLocaleString()}G\n\n`;
        
        // í˜„ì¬ ë² íŒ… ëª©ë¡ í‘œì‹œ
        if (user.oddEvenStats.currentBets && user.oddEvenStats.currentBets.length > 0) {
            const totalBetAmount = user.oddEvenStats.currentBets.reduce((sum, bet) => sum + (bet.amount || 0), 0);
            description += `**ğŸ¯ í˜„ì¬ ë² íŒ… ëª©ë¡:**\n`;
            user.oddEvenStats.currentBets.forEach(bet => {
                const option = MONSTER_BATTLE.betOptions[bet.betType];
                const amount = bet.amount || 0;
                const betInfo = bet.targetNumber ? 
                    `${option?.emoji || 'ğŸ²'} ${option?.name || bet.betType} (${bet.targetNumber}) - ${amount.toLocaleString()}G` :
                    `${option?.emoji || 'ğŸ²'} ${option?.name || bet.betType} - ${amount.toLocaleString()}G`;
                description += `${betInfo}\n`;
            });
            description += `**ğŸ’° ì´ ë² íŒ…ê¸ˆ:** ${totalBetAmount.toLocaleString()}G\n\n`;
            description += `**ì¶”ê°€ ë² íŒ…í•˜ê±°ë‚˜ ê²Œì„ì„ ì‹œì‘í•˜ì„¸ìš”!**`;
        } else {
            description += `**ë² íŒ…í•  ì˜µì…˜ì„ ì„ íƒí•˜ì„¸ìš”:**\n*(ì—¬ëŸ¬ ì˜µì…˜ì— ì¤‘ë³µ ë² íŒ… ê°€ëŠ¥!)*`;
        }

        const embed = new EmbedBuilder()
            .setTitle('ğŸ² ë² íŒ… ì„ íƒ (ì¤‘ë³µ ê°€ëŠ¥)')
            .setDescription(description)
            .setColor('#FF6B6B');

        const row1 = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('bet_odd')
                    .setLabel('ğŸ”¥ í™€ (1.95x)')
                    .setStyle(ButtonStyle.Danger),
                new ButtonBuilder()
                    .setCustomId('bet_even')
                    .setLabel('â„ï¸ ì§ (1.95x)')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId('bet_small')
                    .setLabel('ğŸ”» ì†Œ (1.95x)')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId('bet_big')
                    .setLabel('ğŸ”º ëŒ€ (1.95x)')
                    .setStyle(ButtonStyle.Secondary)
            );

        const row2 = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('bet_lucky7')
                    .setLabel('ğŸ€ 7ë°°ìˆ˜ (13x)')
                    .setStyle(ButtonStyle.Success),
                new ButtonBuilder()
                    .setCustomId('bet_jackpot')
                    .setLabel('ğŸ’ ì •í™•í•œ ìˆ«ì (99x)')
                    .setStyle(ButtonStyle.Danger)
            );

        // ë² íŒ…ì´ ìˆì„ ë•Œë§Œ ê²Œì„ ì‹œì‘/ì´ˆê¸°í™” ë²„íŠ¼ ì¶”ê°€
        if (user.oddEvenStats.currentBets && user.oddEvenStats.currentBets.length > 0) {
            row2.addComponents(
                new ButtonBuilder()
                    .setCustomId('start_game')
                    .setLabel('ğŸ² ê²Œì„ ì‹œì‘!')
                    .setStyle(ButtonStyle.Success),
                new ButtonBuilder()
                    .setCustomId('clear_bets')
                    .setLabel('ğŸ—‘ï¸ ë² íŒ… ì´ˆê¸°í™”')
                    .setStyle(ButtonStyle.Danger)
            );
        }

        const row3 = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('oddeven_back')
                    .setLabel('ğŸ”™ ëŒì•„ê°€ê¸°')
                    .setStyle(ButtonStyle.Secondary)
            );

        const components = user.oddEvenStats.currentBets?.length > 0 ? [row1, row2, row3] : [row1, row2, row3];
        
        // Modal submissionì€ updateë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ reply ì‚¬ìš©
        if (interaction.isModalSubmit()) {
            await interaction.reply({ embeds: [embed], components });
        } else if (interaction.replied || interaction.deferred) {
            await interaction.editReply({ embeds: [embed], components });
        } else {
            await interaction.update({ embeds: [embed], components });
        }
    }

    // ê°œë³„ ë² íŒ… ì¶”ê°€
    async addBet(interaction, betType, betAmount, specificNumber = null) {
        const user = await User.findOne({ discordId: interaction.user.id });
        
        // ìµœì†Œ ë² íŒ… ê¸ˆì•¡ í™•ì¸
        if (betAmount < MONSTER_BATTLE.betLimits.min) {
            return interaction.reply({ 
                content: `âŒ ìµœì†Œ ë² íŒ… ê¸ˆì•¡ì€ ${MONSTER_BATTLE.betLimits.min.toLocaleString()}G ì…ë‹ˆë‹¤!`, 
                flags: 64 
            });
        }
        
        // ê³¨ë“œ í™•ì¸
        if (user.gold < betAmount) {
            return interaction.reply({ 
                content: `âŒ ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤! í˜„ì¬: ${user.gold.toLocaleString()}G`, 
                flags: 64 
            });
        }

        // ë² íŒ… í•œë„ í™•ì¸
        const maxBet = user.level >= 50 ? MONSTER_BATTLE.betLimits.vip_max : MONSTER_BATTLE.betLimits.max;
        if (betAmount > maxBet) {
            return interaction.reply({ 
                content: `âŒ ìµœëŒ€ ë² íŒ… í•œë„ë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤! ìµœëŒ€: ${maxBet.toLocaleString()}G`, 
                flags: 64 
            });
        }

        // ì¤‘ë³µ ë² íŒ… í™•ì¸ (ê°™ì€ íƒ€ì…ì˜ ë² íŒ…ì´ ì´ë¯¸ ìˆëŠ”ì§€)
        if (!user.oddEvenStats) {
            user.oddEvenStats = {};
        }
        if (!user.oddEvenStats.currentBets) {
            user.oddEvenStats.currentBets = [];
        }

        const existingBet = user.oddEvenStats.currentBets.find(bet => bet.betType === betType);
        if (existingBet) {
            return interaction.reply({ 
                content: `âŒ ì´ë¯¸ ${MONSTER_BATTLE.betOptions[betType]?.name || betType}ì— ë² íŒ…í–ˆìŠµë‹ˆë‹¤!`, 
                flags: 64 
            });
        }

        // ë² íŒ… ì¶”ê°€
        const newBet = {
            betType,
            amount: betAmount,
            targetNumber: specificNumber,
            timestamp: new Date()
        };

        user.oddEvenStats.currentBets.push(newBet);
        await user.save();

        // ë² íŒ… ë©”ë‰´ ìƒˆë¡œê³ ì¹¨
        await this.showBettingMenu(interaction);
    }

    // ì¤‘ë³µ ë² íŒ… ê²Œì„ ì‹¤í–‰
    async playMultipleBets(interaction) {
        const user = await User.findOne({ discordId: interaction.user.id });
        
        console.log('playMultipleBets - user.oddEvenStats:', user.oddEvenStats);
        console.log('playMultipleBets - currentBets:', user.oddEvenStats?.currentBets);
        
        if (!user.oddEvenStats?.currentBets || user.oddEvenStats.currentBets.length === 0) {
            return interaction.reply({ 
                content: 'âŒ ë² íŒ…ì´ ì—†ìŠµë‹ˆë‹¤!', 
                flags: 64 
            });
        }

        // ì´ ë² íŒ… ê¸ˆì•¡ ê³„ì‚°
        const totalBetAmount = user.oddEvenStats.currentBets.reduce((sum, bet) => sum + (bet.amount || 0), 0);
        
        // ê³¨ë“œ í™•ì¸
        if (user.gold < totalBetAmount) {
            return interaction.reply({ 
                content: `âŒ ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤! í•„ìš”: ${totalBetAmount.toLocaleString()}G, í˜„ì¬: ${user.gold.toLocaleString()}G`, 
                flags: 64 
            });
        }

        // ê³¨ë“œ ì°¨ê°
        user.gold -= totalBetAmount;

        // ëœë¤ ìˆ«ì ìƒì„± (1-100)
        const resultNumber = Math.floor(Math.random() * 100) + 1;
        const isOdd = resultNumber % 2 === 1;
        const isSmall = resultNumber <= 50;
        const isLucky7 = resultNumber % 7 === 0;

        // ê° ë² íŒ…ë³„ë¡œ ë‹¹ì²¨ í™•ì¸
        let totalPayout = 0;
        const betResults = [];

        for (const bet of user.oddEvenStats.currentBets) {
            let won = false;
            let multiplier = 0;

            switch (bet.betType) {
                case 'odd':
                    won = isOdd;
                    multiplier = MONSTER_BATTLE.betOptions.odd.multiplier;
                    break;
                case 'even':
                    won = !isOdd;
                    multiplier = MONSTER_BATTLE.betOptions.even.multiplier;
                    break;
                case 'small':
                    won = isSmall;
                    multiplier = MONSTER_BATTLE.betOptions.small.multiplier;
                    break;
                case 'big':
                    won = !isSmall;
                    multiplier = MONSTER_BATTLE.betOptions.big.multiplier;
                    break;
                case 'lucky7':
                    won = isLucky7;
                    multiplier = MONSTER_BATTLE.betOptions.lucky7.multiplier;
                    break;
                case 'jackpot':
                    won = resultNumber === bet.targetNumber;
                    multiplier = MONSTER_BATTLE.betOptions.jackpot.multiplier;
                    break;
            }

            const payout = won ? Math.floor(bet.amount * multiplier) : 0;
            totalPayout += payout;

            betResults.push({
                ...bet,
                won,
                payout,
                multiplier
            });
        }

        // ë‹¹ì²¨ê¸ˆ ì§€ê¸‰
        if (totalPayout > 0) {
            user.gold += totalPayout;
        }

        // í†µê³„ ì—…ë°ì´íŠ¸
        this.updateMultipleBetStats(user, betResults, resultNumber, totalBetAmount, totalPayout);
        this.updateGameStats(resultNumber, totalPayout, user.nickname);

        // ë² íŒ… ëª©ë¡ ì´ˆê¸°í™”
        user.oddEvenStats.currentBets = [];
        await user.save();

        // ê²°ê³¼ í‘œì‹œ
        await this.showMultipleBetResult(interaction, {
            user,
            resultNumber,
            betResults,
            totalBetAmount,
            totalPayout
        });
    }

    // ë‹¨ì¼ ë² íŒ… ê²Œì„ ì‹¤í–‰ (ê¸°ì¡´ í•¨ìˆ˜ - í˜¸í™˜ì„± ìœ ì§€)
    async playGame(interaction, betType, betAmount, specificNumber = null) {
        const user = await User.findOne({ discordId: interaction.user.id });
        
        // ê³¨ë“œ í™•ì¸
        if (user.gold < betAmount) {
            return interaction.reply({ 
                content: `âŒ ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤! í˜„ì¬: ${user.gold.toLocaleString()}G`, 
                flags: 64 
            });
        }

        // ë² íŒ… í•œë„ í™•ì¸
        const maxBet = user.level >= 50 ? MONSTER_BATTLE.betLimits.vip_max : MONSTER_BATTLE.betLimits.max;
        if (betAmount > maxBet) {
            return interaction.reply({ 
                content: `âŒ ìµœëŒ€ ë² íŒ… í•œë„ë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤! ìµœëŒ€: ${maxBet.toLocaleString()}G`, 
                flags: 64 
            });
        }

        // ê³¨ë“œ ì°¨ê°
        user.gold -= betAmount;

        // ëœë¤ ìˆ«ì ìƒì„± (1-100)
        const resultNumber = Math.floor(Math.random() * 100) + 1;
        const isOdd = resultNumber % 2 === 1;
        const isSmall = resultNumber <= 50;
        const isLucky7 = resultNumber % 7 === 0;

        // íŠ¹ìˆ˜ ì´ë²¤íŠ¸ í™•ì¸
        let specialEvent = null;
        for (const event of MONSTER_BATTLE.specialEvents) {
            if (Math.random() < event.probability) {
                specialEvent = event;
                break;
            }
        }

        // ë‹¹ì²¨ í™•ì¸
        let won = false;
        let multiplier = 0;

        switch (betType) {
            case 'odd':
                won = isOdd;
                multiplier = MONSTER_BATTLE.betOptions.odd.multiplier;
                break;
            case 'even':
                won = !isOdd;
                multiplier = MONSTER_BATTLE.betOptions.even.multiplier;
                break;
            case 'small':
                won = isSmall;
                multiplier = MONSTER_BATTLE.betOptions.small.multiplier;
                break;
            case 'big':
                won = !isSmall;
                multiplier = MONSTER_BATTLE.betOptions.big.multiplier;
                break;
            case 'lucky7':
                won = isLucky7;
                multiplier = MONSTER_BATTLE.betOptions.lucky7.multiplier;
                break;
            case 'jackpot':
                won = resultNumber === specificNumber;
                multiplier = MONSTER_BATTLE.betOptions.jackpot.multiplier;
                break;
        }

        // ì—°ìŠ¹ ë³´ë„ˆìŠ¤ ì ìš©
        let streakBonus = 0;
        if (won && user.oddEvenStats?.currentStreak > 0) {
            const streak = user.oddEvenStats.currentStreak;
            for (const bonus of MONSTER_BATTLE.streakBonuses) {
                if (streak >= bonus.streak) {
                    streakBonus = bonus.bonus;
                }
            }
        }

        // íŠ¹ìˆ˜ ì´ë²¤íŠ¸ íš¨ê³¼ ì ìš©
        if (specialEvent && won) {
            switch (specialEvent.effect.type) {
                case 'multiply_payout':
                    multiplier *= specialEvent.effect.value;
                    break;
                case 'chaos_result':
                    won = Math.random() < 0.5; // 50% í™•ë¥ ë¡œ ì¬ê²°ì •
                    break;
            }
        }

        // ìµœì¢… ë°°ìœ¨ ê³„ì‚°
        const finalMultiplier = multiplier * (1 + streakBonus);
        const payout = won ? Math.floor(betAmount * finalMultiplier) : 0;
        
        if (won) {
            user.gold += payout;
        }

        // í†µê³„ ì—…ë°ì´íŠ¸
        this.updateUserStats(user, betType, betAmount, won, payout, resultNumber);
        this.updateGameStats(resultNumber, payout, user.nickname);

        await user.save();

        // ê²°ê³¼ í‘œì‹œ
        await this.showGameResult(interaction, {
            user,
            betType,
            betAmount,
            resultNumber,
            won,
            payout,
            specialEvent,
            streakBonus,
            finalMultiplier
        });
    }

    // ìœ ì € í†µê³„ ì—…ë°ì´íŠ¸
    updateUserStats(user, betType, betAmount, won, payout, resultNumber) {
        if (!user.oddEvenStats) {
            user.oddEvenStats = {
                totalGames: 0,
                totalBets: 0,
                totalWinnings: 0,
                wins: 0,
                losses: 0,
                currentStreak: 0,
                longestWinStreak: 0,
                longestLossStreak: 0,
                biggestWin: 0,
                biggestLoss: 0,
                recentResults: []
            };
        }

        const stats = user.oddEvenStats;
        stats.totalGames++;
        stats.totalBets += betAmount;
        stats.lastPlayDate = new Date();

        if (won) {
            stats.wins++;
            stats.totalWinnings += payout;
            stats.currentStreak = stats.currentStreak > 0 ? stats.currentStreak + 1 : 1;
            stats.longestWinStreak = Math.max(stats.longestWinStreak, stats.currentStreak);
            stats.biggestWin = Math.max(stats.biggestWin, payout);
        } else {
            stats.losses++;
            stats.currentStreak = stats.currentStreak < 0 ? stats.currentStreak - 1 : -1;
            stats.longestLossStreak = Math.max(stats.longestLossStreak, Math.abs(stats.currentStreak));
            stats.biggestLoss = Math.max(stats.biggestLoss, betAmount);
        }

        // ìµœê·¼ ê²°ê³¼ ê¸°ë¡ (ìµœëŒ€ 10ê°œ)
        stats.recentResults.unshift({
            number: resultNumber,
            bet: betType,
            amount: betAmount,
            won: won,
            payout: payout,
            date: new Date()
        });

        if (stats.recentResults.length > 10) {
            stats.recentResults = stats.recentResults.slice(0, 10);
        }
    }

    // ì „ì²´ ê²Œì„ í†µê³„ ì—…ë°ì´íŠ¸
    updateGameStats(resultNumber, payout, nickname) {
        this.gameStats.totalGames++;
        this.gameStats.recentNumbers.push(resultNumber);
        
        // ìµœê·¼ 100ê°œë§Œ ìœ ì§€
        if (this.gameStats.recentNumbers.length > 100) {
            this.gameStats.recentNumbers.shift();
        }

        // í•« ë„˜ë²„ ì—…ë°ì´íŠ¸
        const count = this.gameStats.hotNumbers.get(resultNumber) || 0;
        this.gameStats.hotNumbers.set(resultNumber, count + 1);

        // ëŒ€ë°• ë‹¹ì²¨ ê¸°ë¡
        if (payout > 100000) {
            this.gameStats.biggestWins.push({
                amount: payout,
                user: nickname,
                date: new Date()
            });
            // ìµœëŒ€ 10ê°œë§Œ ìœ ì§€
            this.gameStats.biggestWins.sort((a, b) => b.amount - a.amount);
            if (this.gameStats.biggestWins.length > 10) {
                this.gameStats.biggestWins = this.gameStats.biggestWins.slice(0, 10);
            }
        }
    }

    // ê²Œì„ ê²°ê³¼ í‘œì‹œ
    async showGameResult(interaction, gameData) {
        const { user, betType, betAmount, resultNumber, won, payout, specialEvent, streakBonus, finalMultiplier } = gameData;
        
        const isOdd = resultNumber % 2 === 1;
        const isSmall = resultNumber <= 50;
        
        const embed = new EmbedBuilder()
            .setTitle('ğŸ² í™€ì§ ê²Œì„ ê²°ê³¼ ğŸ²')
            .setDescription(`**ê²°ê³¼ ìˆ«ì: \`${resultNumber}\`**\n${isOdd ? 'ğŸ”¥ í™€' : 'â„ï¸ ì§'} | ${isSmall ? 'ğŸ”» ì†Œ' : 'ğŸ”º ëŒ€'}`)
            .addFields(
                { name: 'ğŸ¯ ë² íŒ…', value: `${MONSTER_BATTLE.betOptions[betType]?.name || betType} - ${betAmount.toLocaleString()}G`, inline: true },
                { name: 'ğŸ“Š ê²°ê³¼', value: won ? 'ğŸ‰ ë‹¹ì²¨!' : 'ğŸ˜­ ê½!', inline: true },
                { name: 'ğŸ’° ê³¨ë“œ', value: `${user.gold.toLocaleString()}G`, inline: true }
            )
            .setColor(won ? '#00FF00' : '#FF0000');

        if (won) {
            embed.addFields(
                { name: 'ğŸ’ ë‹¹ì²¨ê¸ˆ', value: `${payout.toLocaleString()}G`, inline: true },
                { name: 'ğŸ“ˆ ë°°ìœ¨', value: `${finalMultiplier.toFixed(2)}x`, inline: true },
                { name: 'ğŸ”¥ ì—°ìŠ¹', value: `${user.oddEvenStats.currentStreak}íšŒ`, inline: true }
            );
        }

        if (specialEvent) {
            embed.addFields({
                name: `âœ¨ ${specialEvent.name}`,
                value: specialEvent.description,
                inline: false
            });
        }

        if (streakBonus > 0) {
            embed.addFields({
                name: 'ğŸ”¥ ì—°ìŠ¹ ë³´ë„ˆìŠ¤',
                value: `+${(streakBonus * 100).toFixed(0)}% ë°°ìœ¨ ì¦ê°€!`,
                inline: false
            });
        }

        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('oddeven_play_again')
                    .setLabel('ğŸ² ë‹¤ì‹œí•˜ê¸°')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId('oddeven_main')
                    .setLabel('ğŸŒ² ëª¬ìŠ¤í„° ë©”ë‰´')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId('game_page_1')
                    .setLabel('ğŸ  ê²Œì„ ë©”ì¸')
                    .setStyle(ButtonStyle.Success)
            );

        // Interaction ìƒíƒœì— ë”°ë¼ ì ì ˆíˆ ì‘ë‹µ
        if (interaction.replied || interaction.deferred) {
            await interaction.editReply({ embeds: [embed], components: [row] });
        } else {
            await interaction.update({ embeds: [embed], components: [row] });
        }
    }

    // ì¤‘ë³µ ë² íŒ… í†µê³„ ì—…ë°ì´íŠ¸
    updateMultipleBetStats(user, betResults, resultNumber, totalBetAmount, totalPayout) {
        if (!user.oddEvenStats) {
            user.oddEvenStats = {
                totalGames: 0,
                totalBets: 0,
                totalWinnings: 0,
                wins: 0,
                losses: 0,
                currentStreak: 0,
                longestWinStreak: 0,
                longestLossStreak: 0,
                biggestWin: 0,
                biggestLoss: 0,
                recentResults: []
            };
        }

        const stats = user.oddEvenStats;
        stats.totalGames++;
        stats.totalBets += totalBetAmount;
        stats.lastPlayDate = new Date();

        const hasWin = betResults.some(bet => bet.won);
        
        if (hasWin) {
            stats.wins++;
            stats.totalWinnings += totalPayout;
            stats.currentStreak = stats.currentStreak > 0 ? stats.currentStreak + 1 : 1;
            stats.longestWinStreak = Math.max(stats.longestWinStreak, stats.currentStreak);
            stats.biggestWin = Math.max(stats.biggestWin, totalPayout);
        } else {
            stats.losses++;
            stats.currentStreak = stats.currentStreak < 0 ? stats.currentStreak - 1 : -1;
            stats.longestLossStreak = Math.max(stats.longestLossStreak, Math.abs(stats.currentStreak));
            stats.biggestLoss = Math.max(stats.biggestLoss, totalBetAmount);
        }

        // ìµœê·¼ ê²°ê³¼ ê¸°ë¡ (ìµœëŒ€ 10ê°œ)
        stats.recentResults.unshift({
            number: resultNumber,
            bet: 'multiple',
            amount: totalBetAmount,
            won: hasWin,
            payout: totalPayout,
            date: new Date()
        });

        if (stats.recentResults.length > 10) {
            stats.recentResults = stats.recentResults.slice(0, 10);
        }
    }

    // ì¤‘ë³µ ë² íŒ… ê²°ê³¼ í‘œì‹œ
    async showMultipleBetResult(interaction, gameData) {
        const { user, resultNumber, betResults, totalBetAmount, totalPayout } = gameData;
        
        const isOdd = resultNumber % 2 === 1;
        const isSmall = resultNumber <= 50;
        const isLucky7 = resultNumber % 7 === 0;
        
        const embed = new EmbedBuilder()
            .setTitle('ğŸ² í™€ì§ ê²Œì„ ê²°ê³¼ (ì¤‘ë³µ ë² íŒ…) ğŸ²')
            .setDescription(`**ê²°ê³¼ ìˆ«ì: \`${resultNumber}\`**\n${isOdd ? 'ğŸ”¥ í™€' : 'â„ï¸ ì§'} | ${isSmall ? 'ğŸ”» ì†Œ' : 'ğŸ”º ëŒ€'} | ${isLucky7 ? 'ğŸ€ 7ë°°ìˆ˜' : ''}`)
            .addFields(
                { name: 'ğŸ’° ì´ ë² íŒ…ê¸ˆ', value: `${totalBetAmount.toLocaleString()}G`, inline: true },
                { name: 'ğŸ’ ì´ ë‹¹ì²¨ê¸ˆ', value: `${totalPayout.toLocaleString()}G`, inline: true },
                { name: 'ğŸ“ˆ ìˆ˜ìµ', value: `${(totalPayout - totalBetAmount).toLocaleString()}G`, inline: true }
            )
            .setColor(totalPayout > 0 ? '#00FF00' : '#FF0000');

        // ê° ë² íŒ…ë³„ ê²°ê³¼ í‘œì‹œ
        let betResultText = '';
        betResults.forEach(bet => {
            const option = MONSTER_BATTLE.betOptions[bet.betType];
            const emoji = bet.won ? 'âœ…' : 'âŒ';
            const amount = bet.amount || 0;
            const payout = bet.payout || 0;
            
            const betInfo = bet.targetNumber ? 
                `${emoji} ${option?.emoji || 'ğŸ²'} ${option?.name || bet.betType} (${bet.targetNumber}) - ${amount.toLocaleString()}G` :
                `${emoji} ${option?.emoji || 'ğŸ²'} ${option?.name || bet.betType} - ${amount.toLocaleString()}G`;
            
            if (bet.won) {
                betResultText += `${betInfo} â†’ **${payout.toLocaleString()}G ë‹¹ì²¨!**\n`;
            } else {
                betResultText += `${betInfo}\n`;
            }
        });

        embed.addFields({
            name: 'ğŸ¯ ë² íŒ… ê²°ê³¼',
            value: betResultText || 'ë² íŒ… ì—†ìŒ',
            inline: false
        });

        embed.addFields(
            { name: 'ğŸ’° í˜„ì¬ ê³¨ë“œ', value: `${user.gold.toLocaleString()}G`, inline: true },
            { name: 'ğŸ”¥ ì—°ìŠ¹', value: `${user.oddEvenStats.currentStreak || 0}íšŒ`, inline: true },
            { name: 'ğŸ¯ ìŠ¹ë¥ ', value: `${user.oddEvenStats.totalGames > 0 ? ((user.oddEvenStats.wins / user.oddEvenStats.totalGames) * 100).toFixed(1) : '0.0'}%`, inline: true }
        );

        const row = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('oddeven_bet')
                    .setLabel('ğŸ² ë‹¤ì‹œ ë² íŒ…')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId('oddeven_main')
                    .setLabel('ğŸŒ² ëª¬ìŠ¤í„° ë©”ë‰´')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId('game_page_1')
                    .setLabel('ğŸ  ê²Œì„ ë©”ì¸')
                    .setStyle(ButtonStyle.Success)
            );

        // Interaction ìƒíƒœì— ë”°ë¼ ì ì ˆíˆ ì‘ë‹µ
        if (interaction.replied || interaction.deferred) {
            await interaction.editReply({ embeds: [embed], components: [row] });
        } else {
            await interaction.update({ embeds: [embed], components: [row] });
        }
    }
}

// ğŸ„ ë…ë²„ì„¯ ê²Œì„ ì‹œìŠ¤í…œ
class MushroomGameSystem {
    constructor() {
        this.sessions = mushroomGameSessions;
    }

    // ê²Œì„ ì‹œì‘
    async startGame(interaction, user, difficulty) {
        const userId = interaction.user.id;
        
        // ì´ë¯¸ ì§„í–‰ ì¤‘ì¸ ê²Œì„ì´ë‚˜ ë§¤ì¹­ ì¤‘ì¸ì§€ í™•ì¸
        if (this.sessions.has(userId) || mushroomMatchmakingQueue.has(userId)) {
            await interaction.reply({ 
                content: 'ì´ë¯¸ ì§„í–‰ ì¤‘ì¸ ê²Œì„ì´ë‚˜ ë§¤ì¹­ì´ ìˆìŠµë‹ˆë‹¤!', 
                flags: 64 
            });
            return;
        }

        if (difficulty === 'pvp') {
            // ìœ ì €ì™€ ëŒ€ê²°: ë§¤ì¹­ ì‹œìŠ¤í…œ ì‚¬ìš©
            await this.startMatchmaking(interaction, user);
        } else {
            // í˜¼ì í”Œë ˆì´ ë˜ëŠ” ë´‡ê³¼ ëŒ€ê²°: ë°”ë¡œ ê²Œì„ ì‹œì‘
            await this.createGameSession(interaction, user, difficulty);
        }
    }

    // ë§¤ì¹­ ì‹œìŠ¤í…œ
    async startMatchmaking(interaction, user) {
        const userId = interaction.user.id;
        
        // ëŒ€ê¸° ì¤‘ì¸ í”Œë ˆì´ì–´ ì°¾ê¸°
        const waitingPlayer = Array.from(mushroomMatchmakingQueue.entries())
            .find(([id, data]) => id !== userId && data.difficulty === 'pvp');

        if (waitingPlayer) {
            // ë§¤ì¹­ ì„±ê³µ
            const [opponentId, opponentData] = waitingPlayer;
            mushroomMatchmakingQueue.delete(opponentId);

            // PvP ê²Œì„ ì„¸ì…˜ ìƒì„±
            await this.createPvPSession(interaction, user, opponentId, opponentData.user);
        } else {
            // ë§¤ì¹­ ëŒ€ê¸°ì—´ì— ì¶”ê°€
            mushroomMatchmakingQueue.set(userId, {
                timestamp: Date.now(),
                difficulty: 'pvp',
                user: user,
                interaction: interaction
            });

            const waitingEmbed = new EmbedBuilder()
                .setColor('#ffff00')
                .setTitle('ğŸ” ìƒëŒ€ë°©ì„ ì°¾ê³  ìˆìŠµë‹ˆë‹¤...')
                .setDescription(`${user.nickname}ë‹˜, ë‹¤ë¥¸ í”Œë ˆì´ì–´ë¥¼ ì°¾ê³  ìˆìŠµë‹ˆë‹¤!\n\nâ° 30ì´ˆ í›„ ë´‡ê³¼ ëŒ€ê²°ë¡œ ìë™ ì „í™˜ë©ë‹ˆë‹¤.`)
                .setThumbnail(`attachment://${MUSHROOM_GAME.effects.thinking}`);

            const cancelButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId(`mushroom_cancel_${userId}`)
                        .setLabel('âŒ ë§¤ì¹­ ì·¨ì†Œ')
                        .setStyle(ButtonStyle.Danger)
                );

            const thinkingAttachment = new AttachmentBuilder(`resource/${MUSHROOM_GAME.effects.thinking}`);

            await interaction.reply({
                embeds: [waitingEmbed],
                components: [cancelButton],
                files: [thinkingAttachment]
            });

            // 30ì´ˆ í›„ ë´‡ ë§¤ì¹­ìœ¼ë¡œ ì „í™˜
            setTimeout(async () => {
                if (mushroomMatchmakingQueue.has(userId)) {
                    mushroomMatchmakingQueue.delete(userId);
                    
                    const timeoutEmbed = new EmbedBuilder()
                        .setColor('#ff9900')
                        .setTitle('â° ë§¤ì¹­ ì‹œê°„ ì´ˆê³¼')
                        .setDescription('ìƒëŒ€ë°©ì„ ì°¾ì§€ ëª»í•´ ë´‡ê³¼ ëŒ€ê²°ë¡œ ì „í™˜ë©ë‹ˆë‹¤!');

                    await interaction.editReply({
                        embeds: [timeoutEmbed],
                        components: []
                    });

                    // 1ì´ˆ í›„ ë´‡ ê²Œì„ ì‹œì‘
                    setTimeout(async () => {
                        await this.createGameSession(interaction, user, 'bot', true);
                    }, 1000);
                }
            }, MUSHROOM_GAME.gameSettings.matchmakingTimeout);
        }
    }

    // PvP ê²Œì„ ì„¸ì…˜ ìƒì„±
    async createPvPSession(interaction, user1, user2Id, user2) {
        const sessionId = `pvp_${user1.discordId}_${user2Id}`;
        
        const session = {
            sessionId: sessionId,
            type: 'pvp',
            players: {
                [user1.discordId]: {
                    userId: user1.discordId,
                    userName: user1.nickname,
                    isAlive: true,
                    survivedRounds: 0,
                    totalReward: 0,
                    lastChoice: null
                },
                [user2Id]: {
                    userId: user2Id,
                    userName: user2.nickname,
                    isAlive: true,
                    survivedRounds: 0,
                    totalReward: 0,
                    lastChoice: null
                }
            },
            currentRound: 1,
            startTime: Date.now(),
            currentMushrooms: [],
            waitingForChoices: new Set([user1.discordId, user2Id])
        };

        this.sessions.set(user1.discordId, session);
        this.sessions.set(user2Id, session);

        // ë§¤ì¹­ ì„±ê³µ ì•Œë¦¼
        const matchEmbed = new EmbedBuilder()
            .setColor('#00ff00')
            .setTitle('âš”ï¸ ë§¤ì¹­ ì„±ê³µ!')
            .setDescription(`${user1.nickname} VS ${user2.nickname}\n\në²„ì„¯ ì‚¬ëƒ¥ ëŒ€ê²°ì´ ì‹œì‘ë©ë‹ˆë‹¤!`)
            .setImage(`attachment://${MUSHROOM_GAME.backgrounds.gameStart}`)
            .setThumbnail(`attachment://${MUSHROOM_GAME.effects.gameStart}`);

        const startButton = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId(`mushroom_pvp_start_${sessionId}`)
                    .setLabel('ğŸ„ ëŒ€ê²° ì‹œì‘!')
                    .setStyle(ButtonStyle.Primary)
            );

        const gameStartAttachment = new AttachmentBuilder(`resource/${MUSHROOM_GAME.backgrounds.gameStart}`);
        const effectAttachment = new AttachmentBuilder(`resource/${MUSHROOM_GAME.effects.gameStart}`);

        await interaction.editReply({
            embeds: [matchEmbed],
            components: [startButton],
            files: [gameStartAttachment, effectAttachment]
        });

        // ìƒëŒ€ë°©ì—ê²Œë„ ì•Œë¦¼ (DM ë˜ëŠ” ì±„ë„)
        try {
            const opponent = await client.users.fetch(user2Id);
            await opponent.send({
                embeds: [matchEmbed.setDescription(`${user2.nickname} VS ${user1.nickname}\n\në²„ì„¯ ì‚¬ëƒ¥ ëŒ€ê²°ì´ ì‹œì‘ë©ë‹ˆë‹¤!`)],
                components: [startButton],
                files: [gameStartAttachment, effectAttachment]
            });
        } catch (error) {
            console.log('ìƒëŒ€ë°© DM ì „ì†¡ ì‹¤íŒ¨:', error);
        }
    }

    // ê²Œì„ ì„¸ì…˜ ìƒì„± (ì†”ë¡œ/ë´‡)
    async createGameSession(interaction, user, difficulty, isTimeout = false) {
        const userId = interaction.user.id;

        const session = {
            userId: userId,
            userName: user.nickname,
            difficulty: difficulty,
            currentRound: 1,
            survivedRounds: 0,
            isAlive: true,
            totalReward: 0,
            startTime: Date.now(),
            bot: difficulty === 'bot' ? this.selectBot() : null,
            botAlive: difficulty === 'bot',
            currentMushrooms: []
        };

        this.sessions.set(userId, session);

        // ê²Œì„ ì‹œì‘ í™”ë©´ í‘œì‹œ
        const startEmbed = new EmbedBuilder()
            .setColor('#00ff00')
            .setTitle(MUSHROOM_GAME.messages.gameStart)
            .setDescription(`${user.nickname}ë‹˜ì˜ ë²„ì„¯ ì‚¬ëƒ¥ì´ ì‹œì‘ë©ë‹ˆë‹¤!\n\nëª¨ë“œ: ${this.getDifficultyName(difficulty)}`)
            .setImage(`attachment://${MUSHROOM_GAME.backgrounds.gameStart}`)
            .setThumbnail(`attachment://${MUSHROOM_GAME.effects.gameStart}`);

        const startButton = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId(`mushroom_start_${userId}`)
                    .setLabel('ğŸ„ íƒí—˜ ì‹œì‘!')
                    .setStyle(ButtonStyle.Primary)
            );

        const gameStartAttachment = new AttachmentBuilder(`resource/${MUSHROOM_GAME.backgrounds.gameStart}`);
        const effectAttachment = new AttachmentBuilder(`resource/${MUSHROOM_GAME.effects.gameStart}`);

        if (isTimeout) {
            await interaction.editReply({
                embeds: [startEmbed],
                components: [startButton],
                files: [gameStartAttachment, effectAttachment]
            });
        } else {
            await interaction.reply({
                embeds: [startEmbed],
                components: [startButton],
                files: [gameStartAttachment, effectAttachment]
            });
        }
    }

    // ë‚œì´ë„ ì´ë¦„ ë°˜í™˜
    getDifficultyName(difficulty) {
        const names = {
            solo: 'ğŸŒ± í˜¼ì í”Œë ˆì´',
            pvp: 'âš”ï¸ ìœ ì €ì™€ ëŒ€ê²°',
            bot: 'ğŸ¤– ë´‡ê³¼ ëŒ€ê²°'
        };
        return names[difficulty] || names.solo;
    }

    // ë´‡ ì„ íƒ
    selectBot() {
        const botTypes = Object.keys(MUSHROOM_GAME.botCharacters);
        const randomBot = botTypes[Math.floor(Math.random() * botTypes.length)];
        return {
            type: randomBot,
            ...MUSHROOM_GAME.botCharacters[randomBot],
            choiceIndex: 0
        };
    }

    // ë¼ìš´ë“œ ì‹œì‘
    async startRound(interaction, userId) {
        const session = this.sessions.get(userId);
        if (!session) return;

        const roundInfo = MUSHROOM_GAME.difficultyByRound[session.currentRound];
        
        // ë²„ì„¯ ë°°ì¹˜ ìƒì„± (6ê°œ ì¤‘ ë…ë²„ì„¯ ê°œìˆ˜ë§Œí¼ ëœë¤ ë°°ì¹˜)
        const mushrooms = this.generateMushrooms(roundInfo.poisonCount);
        session.currentMushrooms = mushrooms;

        // ë¼ìš´ë“œ ì‹œì‘ í™”ë©´
        const roundEmbed = new EmbedBuilder()
            .setColor('#9b59b6')
            .setTitle(`ğŸ„ ë¼ìš´ë“œ ${session.currentRound}`)
            .setDescription(`${roundInfo.message}\n\n${MUSHROOM_GAME.messages.selectPrompt}`)
            .setImage(`attachment://${MUSHROOM_GAME.backgrounds.mushroomSelect}`)
            .setFooter({ text: `ìƒì¡´ ë¼ìš´ë“œ: ${session.survivedRounds} | íšë“ ê³¨ë“œ: ${session.totalReward}G` });

        // ë²„ì„¯ ì„ íƒ ë²„íŠ¼ë“¤
        const mushroomButtons = [];
        for (let i = 0; i < 2; i++) {
            const row = new ActionRowBuilder();
            for (let j = 0; j < 3; j++) {
                const num = i * 3 + j + 1;
                row.addComponents(
                    new ButtonBuilder()
                        .setCustomId(`mushroom_select_${userId}_${num}`)
                        .setLabel(`${num}ï¸âƒ£ ì‹ ë¹„í•œ ë²„ì„¯`)
                        .setStyle(ButtonStyle.Secondary)
                        .setEmoji('â“')
                );
            }
            mushroomButtons.push(row);
        }

        const backgroundAttachment = new AttachmentBuilder(`resource/${MUSHROOM_GAME.backgrounds.mushroomSelect}`);

        await interaction.update({
            embeds: [roundEmbed],
            components: mushroomButtons,
            files: [backgroundAttachment]
        });

        // ë´‡ ëŒ€ê²° ëª¨ë“œì¸ ê²½ìš° ë´‡ ì„ íƒ ì²˜ë¦¬
        if (session.difficulty === 'bot' && session.bot && session.botAlive) {
            setTimeout(() => this.processBotChoice(interaction, userId), MUSHROOM_GAME.gameSettings.botThinkingTime);
        }
    }

    // ë²„ì„¯ ìƒì„±
    generateMushrooms(poisonCount) {
        const mushrooms = [];
        const types = Object.keys(MUSHROOM_GAME.mushroomTypes);
        
        // 6ê°œ ìœ„ì¹˜ ì¤‘ ë…ë²„ì„¯ ìœ„ì¹˜ ì„ íƒ
        const poisonPositions = new Set();
        while (poisonPositions.size < poisonCount) {
            poisonPositions.add(Math.floor(Math.random() * 6));
        }

        // ë²„ì„¯ ë°°ì¹˜
        for (let i = 0; i < 6; i++) {
            const randomType = types[Math.floor(Math.random() * types.length)];
            mushrooms.push({
                type: randomType,
                isPoisonous: poisonPositions.has(i),
                position: i + 1
            });
        }

        return mushrooms;
    }

    // ë²„ì„¯ ì„ íƒ ì²˜ë¦¬
    async processMushroomSelection(interaction, userId, position) {
        const session = this.sessions.get(userId);
        if (!session || !session.isAlive) return;

        const selectedMushroom = session.currentMushrooms[position - 1];
        const mushroomType = MUSHROOM_GAME.mushroomTypes[selectedMushroom.type];

        let resultEmbed;
        let resultAttachment;
        let effectAttachment;

        if (selectedMushroom.isPoisonous) {
            // ë…ë²„ì„¯ ì„ íƒ
            session.isAlive = false;
            
            resultEmbed = new EmbedBuilder()
                .setColor('#ff0000')
                .setTitle(MUSHROOM_GAME.messages.poisonSelected)
                .setDescription(`${mushroomType.emoji} **${mushroomType.name}**\n\n${mushroomType.poisonDesc}`)
                .setImage(`attachment://${mushroomType.poisonGif}`)
                .setThumbnail(`attachment://${MUSHROOM_GAME.effects.poisonDeath}`)
                .addFields(
                    { name: 'ğŸ† ìµœì¢… ì„±ê³¼', value: `ìƒì¡´ ë¼ìš´ë“œ: ${session.survivedRounds}\níšë“ ê³¨ë“œ: ${session.totalReward}G`, inline: true }
                );

            resultAttachment = new AttachmentBuilder(`resource/${mushroomType.poisonGif}`);
            effectAttachment = new AttachmentBuilder(`resource/${MUSHROOM_GAME.effects.poisonDeath}`);
        } else {
            // ì•ˆì „í•œ ë²„ì„¯ ì„ íƒ
            session.survivedRounds++;
            const roundReward = MUSHROOM_GAME.gameSettings.baseReward + (session.currentRound - 1) * MUSHROOM_GAME.gameSettings.survivalBonus;
            session.totalReward += roundReward;

            resultEmbed = new EmbedBuilder()
                .setColor('#00ff00')
                .setTitle(MUSHROOM_GAME.messages.safeSelected)
                .setDescription(`${mushroomType.emoji} **${mushroomType.name}**\n\n${mushroomType.safeDesc}`)
                .setImage(`attachment://${mushroomType.safeGif}`)
                .setThumbnail(`attachment://${MUSHROOM_GAME.effects.safeSparkle}`)
                .addFields(
                    { name: 'ğŸ’° íšë“ ê³¨ë“œ', value: `+${roundReward}G`, inline: true },
                    { name: 'ğŸ“Š í˜„ì¬ ìƒíƒœ', value: `ë¼ìš´ë“œ ${session.currentRound} í†µê³¼!`, inline: true }
                );

            resultAttachment = new AttachmentBuilder(`resource/${mushroomType.safeGif}`);
            effectAttachment = new AttachmentBuilder(`resource/${MUSHROOM_GAME.effects.safeSparkle}`);
        }

        // ë‹¤ìŒ ì•¡ì…˜ ë²„íŠ¼
        const nextActions = new ActionRowBuilder();
        
        if (session.isAlive && session.currentRound < MUSHROOM_GAME.gameSettings.maxRounds) {
            session.currentRound++;
            nextActions.addComponents(
                new ButtonBuilder()
                    .setCustomId(`mushroom_continue_${userId}`)
                    .setLabel('ğŸ„ ë‹¤ìŒ ë¼ìš´ë“œ')
                    .setStyle(ButtonStyle.Primary)
            );
        }

        nextActions.addComponents(
            new ButtonBuilder()
                .setCustomId(`mushroom_end_${userId}`)
                .setLabel('ğŸ ê²Œì„ ì¢…ë£Œ')
                .setStyle(ButtonStyle.Danger)
        );

        await interaction.update({
            embeds: [resultEmbed],
            components: [nextActions],
            files: [resultAttachment, effectAttachment]
        });

        // ê²Œì„ ì™„ë£Œ ì²´í¬
        if (session.isAlive && session.currentRound > MUSHROOM_GAME.gameSettings.maxRounds) {
            await this.completeGame(interaction, userId, true);
        } else if (!session.isAlive) {
            // íŒ¨ë°° ì‹œì—ë„ ë²„íŠ¼ í‘œì‹œ
            await this.saveGameResult(userId);
            
            // ê²Œì„ ì¢…ë£Œ í›„ ë²„íŠ¼ ì¶”ê°€
            const endButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('mushroom_play_again')
                        .setLabel('ğŸ„ í•œíŒ ë”í•˜ê¸°')
                        .setStyle(ButtonStyle.Success),
                    new ButtonBuilder()
                        .setCustomId('game_main_menu')
                        .setLabel('ğŸ  ë©”ì¸ ë©”ë‰´ë¡œ')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            // ì ì‹œ í›„ ë²„íŠ¼ í‘œì‹œ
            setTimeout(async () => {
                await interaction.editReply({
                    components: [endButtons]
                });
            }, 1000);
        }
    }

    // ë´‡ ì„ íƒ ì²˜ë¦¬
    async processBotChoice(interaction, userId) {
        const session = this.sessions.get(userId);
        if (!session || !session.bot || !session.botAlive) return;

        let choice;
        const bot = session.bot;

        switch (bot.strategy) {
            case 'sequential':
                choice = bot.pattern[bot.choiceIndex % bot.pattern.length];
                bot.choiceIndex++;
                break;
            case 'random':
                choice = Math.floor(Math.random() * 6) + 1;
                break;
            case 'safe_guess':
                // í†µê³„ì ìœ¼ë¡œ ê°€ì¥ ì•ˆì „í•œ ìœ„ì¹˜ ì„ íƒ (ì¤‘ê°„ ë²ˆí˜¸ ì„ í˜¸)
                choice = [3, 4, 2, 5, 1, 6][Math.floor(Math.random() * 6)];
                break;
            case 'dangerous_guess':
                // ê·¹ë‹¨ì ì¸ ë²ˆí˜¸ ì„ í˜¸
                choice = [1, 6, 1, 6, 2, 5][Math.floor(Math.random() * 6)];
                break;
            default:
                choice = Math.floor(Math.random() * 6) + 1;
        }

        const selectedMushroom = session.currentMushrooms[choice - 1];
        
        if (selectedMushroom.isPoisonous) {
            session.botAlive = false;
        }

        // ë´‡ ì„ íƒ ê²°ê³¼ í‘œì‹œ (í˜„ì¬ embedì— ì¶”ê°€)
        const channel = interaction.channel;
        await channel.send({
            content: `${bot.emoji} **${bot.name}**ì´(ê°€) ${choice}ë²ˆ ë²„ì„¯ì„ ì„ íƒí–ˆìŠµë‹ˆë‹¤!${selectedMushroom.isPoisonous ? ' ğŸ’€ ë…ë²„ì„¯ì´ì—ˆìŠµë‹ˆë‹¤!' : ' âœ¨ ì•ˆì „í–ˆìŠµë‹ˆë‹¤!'}`
        });
    }

    // ê²Œì„ ì™„ë£Œ
    async completeGame(interaction, userId, perfectClear = false) {
        const session = this.sessions.get(userId);
        if (!session) return;

        // ì™„ë²½ í´ë¦¬ì–´ ë³´ë„ˆìŠ¤
        if (perfectClear) {
            session.totalReward += MUSHROOM_GAME.gameSettings.perfectBonus;
        }

        const user = await User.findOne({ discordId: userId });
        if (user) {
            user.gold += session.totalReward;
            await user.save();
        }

        const victoryEmbed = new EmbedBuilder()
            .setColor('#ffd700')
            .setTitle(perfectClear ? MUSHROOM_GAME.messages.perfectVictory : MUSHROOM_GAME.messages.survivalVictory.replace('{rounds}', session.survivedRounds))
            .setDescription(`ğŸ‰ ì¶•í•˜í•©ë‹ˆë‹¤! ${session.userName}ë‹˜!`)
            .setImage(`attachment://${MUSHROOM_GAME.backgrounds.victory}`)
            .setThumbnail(`attachment://${MUSHROOM_GAME.effects.victory}`)
            .addFields(
                { name: 'ğŸ† ìƒì¡´ ë¼ìš´ë“œ', value: `${session.survivedRounds}/${MUSHROOM_GAME.gameSettings.maxRounds}`, inline: true },
                { name: 'ğŸ’° ì´ íšë“ ê³¨ë“œ', value: `${session.totalReward}G`, inline: true },
                { name: 'â±ï¸ í”Œë ˆì´ ì‹œê°„', value: `${Math.floor((Date.now() - session.startTime) / 1000)}ì´ˆ`, inline: true }
            );

        if (session.difficulty === 'bot' && session.bot) {
            victoryEmbed.addFields({
                name: 'ğŸ¤– ë´‡ ëŒ€ê²° ê²°ê³¼',
                value: session.botAlive ? `${session.bot.emoji} ${session.bot.name} ìƒì¡´! ë¬´ìŠ¹ë¶€!` : `${session.bot.emoji} ${session.bot.name} íƒˆë½! ìŠ¹ë¦¬!`,
                inline: false
            });
        }

        const backgroundAttachment = new AttachmentBuilder(`resource/${MUSHROOM_GAME.backgrounds.victory}`);
        const effectAttachment = new AttachmentBuilder(`resource/${MUSHROOM_GAME.effects.victory}`);

        // ê²Œì„ ì¢…ë£Œ í›„ ë²„íŠ¼ ì¶”ê°€
        const endButtons = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('mushroom_play_again')
                    .setLabel('ğŸ„ í•œíŒ ë”í•˜ê¸°')
                    .setStyle(ButtonStyle.Success),
                new ButtonBuilder()
                    .setCustomId('game_main_menu')
                    .setLabel('ğŸ  ë©”ì¸ ë©”ë‰´ë¡œ')
                    .setStyle(ButtonStyle.Secondary)
            );

        await interaction.editReply({
            embeds: [victoryEmbed],
            components: [endButtons],
            files: [backgroundAttachment, effectAttachment]
        });

        this.sessions.delete(userId);
    }

    // ê²Œì„ ê²°ê³¼ ì €ì¥
    async saveGameResult(userId) {
        const session = this.sessions.get(userId);
        if (!session) return;

        const user = await User.findOne({ discordId: userId });
        if (user && session.totalReward > 0) {
            user.gold += session.totalReward;
            await user.save();
        }

        this.sessions.delete(userId);
    }

    // ê²Œì„ ì¢…ë£Œ
    async endGame(interaction, userId) {
        const session = this.sessions.get(userId);
        if (!session) {
            await interaction.reply({ content: 'ì§„í–‰ ì¤‘ì¸ ê²Œì„ì´ ì—†ìŠµë‹ˆë‹¤.', flags: 64 });
            return;
        }

        await this.saveGameResult(userId);

        const endEmbed = new EmbedBuilder()
            .setColor('#808080')
            .setTitle(MUSHROOM_GAME.messages.gameOver)
            .setDescription(`${session.userName}ë‹˜ì˜ ë²„ì„¯ ì‚¬ëƒ¥ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.`)
            .addFields(
                { name: 'ğŸ† ìµœì¢… ì„±ê³¼', value: `ìƒì¡´ ë¼ìš´ë“œ: ${session.survivedRounds}\níšë“ ê³¨ë“œ: ${session.totalReward}G`, inline: false }
            );

        // ê²Œì„ ì¢…ë£Œ í›„ ë²„íŠ¼ ì¶”ê°€
        const endButtons = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('mushroom_play_again')
                    .setLabel('ğŸ„ í•œíŒ ë”í•˜ê¸°')
                    .setStyle(ButtonStyle.Success),
                new ButtonBuilder()
                    .setCustomId('game_main_menu')
                    .setLabel('ğŸ  ë©”ì¸ ë©”ë‰´ë¡œ')
                    .setStyle(ButtonStyle.Secondary)
            );

        if (interaction.replied || interaction.deferred) {
            await interaction.editReply({
                embeds: [endEmbed],
                components: [endButtons]
            });
        } else {
            await interaction.update({
                embeds: [endEmbed],
                components: [endButtons]
            });
        }
    }
}

// ëª¬ìŠ¤í„° ë°°í‹€ ì•„ë ˆë‚˜ ì‹œìŠ¤í…œ ì¸ìŠ¤í„´ìŠ¤
const monsterBattle = new MonsterBattleSystem();
const oddEvenGame = monsterBattle;

// ë…ë²„ì„¯ ê²Œì„ ì‹œìŠ¤í…œ ì¸ìŠ¤í„´ìŠ¤
const mushroomGame = new MushroomGameSystem();

// ì¥ë¹„ ì•„ì´í…œ ì¡°íšŒ í•¨ìˆ˜ (PVPì—ì„œ ì‚¬ìš©)
function getEquippedItem(user, equipmentType) {
    const slotIndex = user.equipment[equipmentType];
    
    // ObjectIdë‚˜ ì˜ëª»ëœ ë°ì´í„° íƒ€ì…ì¸ ê²½ìš° null ë°˜í™˜
    if (slotIndex === -1 || slotIndex === null || slotIndex === undefined || typeof slotIndex === 'object') {
        return null;
    }
    
    // inventorySlotìœ¼ë¡œ ì•„ì´í…œ ì°¾ê¸°
    const item = user.inventory.find(item => item.inventorySlot === slotIndex);
    
    // ì•„ì´í…œì„ ì°¾ì•˜ì§€ë§Œ íƒ€ì…ì´ ë§ì§€ ì•ŠëŠ” ê²½ìš° ë°ì´í„° ì •ë¦¬
    if (item && item.type !== equipmentType) {
        console.log(`[ì¥ë¹„ ì˜¤ë¥˜] ${user.nickname}ì˜ ${equipmentType} ìŠ¬ë¡¯ì— ì˜ëª»ëœ íƒ€ì…ì˜ ì•„ì´í…œ: ${item.type}`);
        user.equipment[equipmentType] = -1;
        item.equipped = false;
        return null;
    }
    
    return item;
}

// PVP ì‹œìŠ¤í…œ í´ë˜ìŠ¤
class PVPSystem {
    constructor() {
        this.matchmakingQueue = new Map(); // userId -> {rating, timestamp, preference}
        this.activeMatches = new Map(); // matchId -> match data
        this.botUsers = new Map(); // ë´‡ ìœ ì € ë°ì´í„° ìºì‹œ
        this.tierRanges = {
            'Bronze': { min: 0, max: 1199 },
            'Silver': { min: 1200, max: 1399 },
            'Gold': { min: 1400, max: 1599 },
            'Platinum': { min: 1600, max: 1799 },
            'Master': { min: 1800, max: 1999 },
            'Grandmaster': { min: 2000, max: 2299 },
            'Challenger': { min: 2300, max: 9999 }
        };
        this.initializeBotUsers();
    }

    // ë´‡ ìœ ì € ë°ì´í„° ì´ˆê¸°í™”
    async initializeBotUsers() {
        const botProfiles = [
            { name: 'ê°•í™”ì™•', rating: 1500, tier: 'Gold' },
            { name: 'ê²€ì„±', rating: 1800, tier: 'Master' },
            { name: 'ë§ˆê²€ì‚¬', rating: 1350, tier: 'Silver' },
            { name: 'ì „ì„¤ì˜ê¸°ì‚¬', rating: 2100, tier: 'Grandmaster' },
            { name: 'ì´ˆë³´ëƒ¥ì´', rating: 900, tier: 'Bronze' },
            { name: 'ì‚¬ëƒ¥ê¾¼', rating: 1600, tier: 'Platinum' },
            { name: 'ë§ˆë²•ì‚¬', rating: 1400, tier: 'Gold' },
            { name: 'ì•”ì‚´ì', rating: 1750, tier: 'Master' }
        ];

        for (const bot of botProfiles) {
            this.botUsers.set(bot.name, {
                nickname: bot.name,
                rating: bot.rating,
                tier: bot.tier,
                level: Math.floor(bot.rating / 50) + 1,
                stats: this.generateBotStats(bot.rating),
                equipment: this.generateBotEquipment(bot.rating)
            });
        }
    }

    // ë´‡ ìŠ¤íƒ¯ ìƒì„±
    generateBotStats(rating) {
        const baseStats = Math.floor(rating / 100) + 10;
        return {
            strength: baseStats + Math.floor(Math.random() * 5),
            agility: baseStats + Math.floor(Math.random() * 5),
            intelligence: baseStats + Math.floor(Math.random() * 5),
            vitality: baseStats + Math.floor(Math.random() * 5),
            luck: baseStats + Math.floor(Math.random() * 5)
        };
    }

    // ë´‡ ì¥ë¹„ ìƒì„±
    generateBotEquipment(rating) {
        const level = Math.floor(rating / 100);
        return {
            weapon: {
                name: `${level}ì„± ì „ì„¤ ë¬´ê¸°`,
                enhanceLevel: Math.min(level, 30),
                stats: { attack: level * 10, defense: 0, dodge: 0, luck: 0 }
            },
            armor: {
                name: `${level}ì„± ì „ì„¤ ê°‘ì˜·`,
                enhanceLevel: Math.min(level, 30),
                stats: { attack: 0, defense: level * 8, dodge: 0, luck: 0 }
            }
        };
    }

    // í‹°ì¼“ ì¬ìƒì„±
    async regenerateTickets(user) {
        const now = new Date();
        const lastRegen = user.pvp.lastTicketRegen || now;
        const hoursPassed = Math.floor((now - lastRegen) / (1000 * 60 * 60));
        
        if (hoursPassed > 0 && user.pvp.duelTickets < 20) {
            const newTickets = Math.min(20, user.pvp.duelTickets + hoursPassed);
            user.pvp.duelTickets = newTickets;
            user.pvp.lastTicketRegen = now;
            await user.save();
        }
        
        return user.pvp.duelTickets;
    }

    // ë§¤ì¹˜ë©”ì´í‚¹ í ì°¸ê°€
    async joinQueue(userId, user, channel) {
        // í‹°ì¼“ ì¬ìƒì„±
        await this.regenerateTickets(user);
        
        // í‹°ì¼“ í™•ì¸
        if (user.pvp.duelTickets <= 0) {
            return { 
                success: false, 
                message: 'ê²°íˆ¬ê¶Œì´ ë¶€ì¡±í•©ë‹ˆë‹¤! 1ì‹œê°„ë§ˆë‹¤ 1ì¥ì”© ì¬ìƒì„±ë©ë‹ˆë‹¤.' 
            };
        }

        // ì´ë¯¸ íì— ìˆëŠ”ì§€ í™•ì¸
        if (this.matchmakingQueue.has(userId)) {
            return { 
                success: false, 
                message: 'ì´ë¯¸ ë§¤ì¹˜ë©”ì´í‚¹ íì— ì°¸ê°€ì¤‘ì…ë‹ˆë‹¤!' 
            };
        }

        const playerData = {
            userId,
            user,
            rating: user.pvp.rating,
            tier: this.getTierByRating(user.pvp.rating),
            timestamp: Date.now(),
            channel,
            isBot: false
        };

        this.matchmakingQueue.set(userId, playerData);

        // ì¦‰ì‹œ ë§¤ì¹˜ ì‹œë„ (ì´ˆê¸° ë²”ìœ„: 200)
        const opponent = this.findOpponent(playerData);
        if (opponent) {
            // ì¦‰ì‹œ ë§¤ì¹­ ì„±ì‚¬ ì•Œë¦¼
            const ratingDiff = Math.abs(playerData.rating - opponent.rating);
            
            if (channel) {
                try {
                    const instantMatchEmbed = new EmbedBuilder()
                        .setColor('#27ae60')
                        .setTitle('âš¡ ì¦‰ì‹œ ë§¤ì¹­ ì„±ì‚¬!')
                        .setDescription(`**${opponent.user.nickname}** ë‹˜ê³¼ ë°”ë¡œ ë§¤ì¹­ë˜ì—ˆìŠµë‹ˆë‹¤!`)
                        .addFields(
                            { name: 'ğŸ‘¤ ìƒëŒ€ í”Œë ˆì´ì–´', value: `${opponent.user.nickname} (${opponent.rating}ì )`, inline: true },
                            { name: 'ğŸ“Š ë ˆì´íŒ… ì°¨ì´', value: `Â±${ratingDiff}ì `, inline: true },
                            { name: 'âš”ï¸ ì „íˆ¬ ì‹œì‘', value: 'ìµœê³ ì˜ ë§¤ì¹­ì´ ì„±ì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!', inline: true }
                        );
                    
                    await channel.send({ embeds: [instantMatchEmbed] });
                    
                    // ìƒëŒ€ë°© ì±„ë„ì—ë„ ì•Œë¦¼
                    if (opponent.channel && opponent.channel !== channel) {
                        await opponent.channel.send({ embeds: [instantMatchEmbed] });
                    }
                } catch (error) {
                    console.error('ì¦‰ì‹œ ë§¤ì¹­ ì„±ê³µ ì•Œë¦¼ ì „ì†¡ ì˜¤ë¥˜:', error);
                }
            }
            
            return await this.createMatch(playerData, opponent);
        }

        // ë§¤ì¹­ ì§„í–‰ ìƒí™© ì—…ë°ì´íŠ¸
        const updateMatchmakingProgress = async () => {
            if (!this.matchmakingQueue.has(userId)) return;
            
            const currentPlayer = this.matchmakingQueue.get(userId);
            const waitTime = Date.now() - currentPlayer.timestamp;
            const waitSeconds = Math.floor(waitTime / 1000);
            
            // ë§¤ì¹­ ë²”ìœ„ ê³„ì‚° (15ì´ˆë§ˆë‹¤ 100ì”© ì¦ê°€, ìµœëŒ€ 2000)
            const baseRange = 200;
            const expandedRange = Math.min(2000, baseRange + Math.floor(waitTime / 15000) * 100);
            
            // ìƒëŒ€ ì°¾ê¸° ì‹œë„
            const opponent = this.findOpponentWithRange(currentPlayer, expandedRange);
            if (opponent) {
                // ì‹¤ì œ í”Œë ˆì´ì–´ ë§¤ì¹­ ì„±ì‚¬ ì•Œë¦¼
                const ratingDiff = Math.abs(currentPlayer.rating - opponent.rating);
                
                if (channel) {
                    try {
                        const playerMatchEmbed = new EmbedBuilder()
                            .setColor('#e74c3c')
                            .setTitle('ğŸ”¥ ì‹¤ì œ í”Œë ˆì´ì–´ ë§¤ì¹­ ì„±ì‚¬!')
                            .setDescription(`**${opponent.user.nickname}** ë‹˜ê³¼ ë§¤ì¹­ë˜ì—ˆìŠµë‹ˆë‹¤!`)
                            .addFields(
                                { name: 'ğŸ‘¤ ìƒëŒ€ í”Œë ˆì´ì–´', value: `${opponent.user.nickname} (${opponent.rating}ì )`, inline: true },
                                { name: 'ğŸ“Š ë ˆì´íŒ… ì°¨ì´', value: `Â±${ratingDiff}ì `, inline: true },
                                { name: 'âš”ï¸ ì „íˆ¬ ì‹œì‘', value: 'ì—´ë¤ ì „íˆ¬ê°€ ì‹œì‘ë©ë‹ˆë‹¤!', inline: true }
                            );
                        
                        await channel.send({ embeds: [playerMatchEmbed] });
                        
                        // ìƒëŒ€ë°© ì±„ë„ì—ë„ ì•Œë¦¼
                        if (opponent.channel && opponent.channel !== channel) {
                            await opponent.channel.send({ embeds: [playerMatchEmbed] });
                        }
                    } catch (error) {
                        console.error('í”Œë ˆì´ì–´ ë§¤ì¹­ ì„±ê³µ ì•Œë¦¼ ì „ì†¡ ì˜¤ë¥˜:', error);
                    }
                }
                
                await this.createMatch(currentPlayer, opponent);
                return;
            }
            
            // 10ì´ˆ í›„ì—ë„ ë§¤ì¹­ì´ ì•ˆë˜ë©´ ë´‡ ë§¤ì¹­ (í…ŒìŠ¤íŠ¸ìš©)
            if (waitTime >= 10000) {
                // ë´‡ ë§¤ì¹­ ì‹œì‘ ì•Œë¦¼
                if (channel) {
                    try {
                        const botMatchEmbed = new EmbedBuilder()
                            .setColor('#FFA500')
                            .setTitle('ğŸ¤– ë´‡ ë§¤ì¹­ ì‹œì‘')
                            .setDescription(`10ì´ˆ ëŒ€ê¸° í›„ ì ì ˆí•œ ì‹¤ë ¥ì˜ ë´‡ê³¼ ë§¤ì¹­ë©ë‹ˆë‹¤!`)
                            .addFields(
                                { name: 'â±ï¸ ëŒ€ê¸° ì‹œê°„', value: `${waitSeconds}ì´ˆ`, inline: true },
                                { name: 'ğŸ¯ ìµœì¢… ë§¤ì¹­ ë²”ìœ„', value: `Â±${expandedRange}ì `, inline: true }
                            );
                        
                        await channel.send({ embeds: [botMatchEmbed] });
                    } catch (error) {
                        console.error('ë´‡ ë§¤ì¹­ ì•Œë¦¼ ì „ì†¡ ì˜¤ë¥˜:', error);
                    }
                }
                
                this.createBotMatch(userId);
                return;
            }
            
            // 15ì´ˆë§ˆë‹¤ ì§„í–‰ ìƒí™© ì•Œë¦¼
            if (waitSeconds % 15 === 0 && waitSeconds > 0) {
                if (channel) {
                    try {
                        const progressEmbed = new EmbedBuilder()
                            .setColor('#3498db')
                            .setTitle('ğŸ” ë§¤ì¹­ ì§„í–‰ ì¤‘...')
                            .setDescription(`ë” ë„“ì€ ë²”ìœ„ì—ì„œ ìƒëŒ€ë¥¼ ì°¾ê³  ìˆìŠµë‹ˆë‹¤!`)
                            .addFields(
                                { name: 'â±ï¸ ëŒ€ê¸° ì‹œê°„', value: `${waitSeconds}ì´ˆ`, inline: true },
                                { name: 'ğŸ¯ í˜„ì¬ ë§¤ì¹­ ë²”ìœ„', value: `Â±${expandedRange}ì `, inline: true },
                                { name: 'â³ ë´‡ ë§¤ì¹­ê¹Œì§€', value: `${10 - waitSeconds}ì´ˆ`, inline: true }
                            );
                        
                        await channel.send({ embeds: [progressEmbed] });
                    } catch (error) {
                        console.error('ë§¤ì¹­ ì§„í–‰ ì•Œë¦¼ ì „ì†¡ ì˜¤ë¥˜:', error);
                    }
                }
            }
            
            // 5ì´ˆ í›„ ë‹¤ì‹œ í™•ì¸
            setTimeout(updateMatchmakingProgress, 5000);
        };

        // 5ì´ˆ í›„ë¶€í„° ë§¤ì¹­ ìƒí™© í™•ì¸ ì‹œì‘
        setTimeout(updateMatchmakingProgress, 5000);

        return {
            success: true,
            message: 'ë§¤ì¹˜ë©”ì´í‚¹ì„ ì‹œì‘í•©ë‹ˆë‹¤! 15ì´ˆë§ˆë‹¤ ë§¤ì¹­ ë²”ìœ„ê°€ í™•ëŒ€ë˜ë©°, 10ì´ˆ í›„ì—” ë´‡ê³¼ ë§¤ì¹­ë©ë‹ˆë‹¤.',
            tickets: user.pvp.duelTickets
        };
    }

    // ìƒëŒ€ ì°¾ê¸° (ê¸°ë³¸ ë²”ìœ„ 200)
    findOpponent(player) {
        return this.findOpponentWithRange(player, 200);
    }

    // ì§€ì •ëœ ë²”ìœ„ë¡œ ìƒëŒ€ ì°¾ê¸°
    findOpponentWithRange(player, maxRatingDiff) {
        let bestOpponent = null;
        let smallestDiff = Infinity;
        
        for (const [opponentId, opponent] of this.matchmakingQueue) {
            if (opponentId === player.userId) continue;
            
            const ratingDiff = Math.abs(player.rating - opponent.rating);
            if (ratingDiff <= maxRatingDiff && ratingDiff < smallestDiff) {
                bestOpponent = opponent;
                smallestDiff = ratingDiff;
            }
        }
        
        if (bestOpponent) {
            this.matchmakingQueue.delete(bestOpponent.userId);
            return bestOpponent;
        }
        
        return null;
    }

    // ë´‡ ë§¤ì¹˜ ìƒì„±
    async createBotMatch(userId) {
        const player = this.matchmakingQueue.get(userId);
        if (!player) return;

        const playerRating = player.rating;
        let botCandidates = Array.from(this.botUsers.values());
        
        // 1ì°¨: í”Œë ˆì´ì–´ ë ˆì´íŒ… Â±300 ë²”ìœ„ ë‚´ ë´‡ ì°¾ê¸°
        let suitableBots = botCandidates.filter(bot => 
            Math.abs(bot.rating - playerRating) <= 300
        );
        
        // 2ì°¨: 300 ë²”ìœ„ì— ì—†ìœ¼ë©´ Â±500 ë²”ìœ„ë¡œ í™•ëŒ€
        if (suitableBots.length === 0) {
            suitableBots = botCandidates.filter(bot => 
                Math.abs(bot.rating - playerRating) <= 500
            );
        }
        
        // 3ì°¨: ê·¸ë˜ë„ ì—†ìœ¼ë©´ ì „ì²´ ë´‡ ì¤‘ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ë´‡ ì„ íƒ
        if (suitableBots.length === 0) {
            suitableBots = botCandidates.sort((a, b) => 
                Math.abs(a.rating - playerRating) - Math.abs(b.rating - playerRating)
            ).slice(0, 3); // ìƒìœ„ 3ê°œ ì¤‘ ëœë¤
        }

        // ìµœì¢…ì ìœ¼ë¡œ ë´‡ì´ ì—†ìœ¼ë©´ ì‹œìŠ¤í…œ ì˜¤ë¥˜ (ì´ë¡ ì ìœ¼ë¡œ ë¶ˆê°€ëŠ¥)
        if (suitableBots.length === 0) {
            this.matchmakingQueue.delete(userId);
            if (player.channel) {
                try {
                    await player.channel.send('âŒ ë§¤ì¹­ ì‹œìŠ¤í…œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
                } catch (error) {
                    console.error('ë§¤ì¹­ ì˜¤ë¥˜ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨:', error);
                }
            }
            return;
        }

        const botOpponent = suitableBots[Math.floor(Math.random() * suitableBots.length)];
        const ratingDiff = Math.abs(botOpponent.rating - playerRating);
        
        const botData = {
            userId: 'bot_' + botOpponent.nickname,
            user: botOpponent,
            rating: botOpponent.rating,
            tier: botOpponent.tier,
            isBot: true
        };

        this.matchmakingQueue.delete(userId);
        
        // ë´‡ ë§¤ì¹­ ì•Œë¦¼ (ë ˆì´íŒ… ì°¨ì´ ì •ë³´ í¬í•¨)
        if (player.channel) {
            try {
                const matchFoundEmbed = new EmbedBuilder()
                    .setColor('#27ae60')
                    .setTitle('ğŸ¯ ë§¤ì¹˜ ì„±ì‚¬!')
                    .setDescription(`**${botOpponent.nickname}** ë´‡ê³¼ ë§¤ì¹­ë˜ì—ˆìŠµë‹ˆë‹¤!`)
                    .addFields(
                        { name: 'ğŸ¤– ìƒëŒ€ ë´‡', value: `${botOpponent.nickname} (${botOpponent.rating}ì )`, inline: true },
                        { name: 'ğŸ“Š ë ˆì´íŒ… ì°¨ì´', value: `Â±${ratingDiff}ì `, inline: true },
                        { name: 'âš”ï¸ ì „íˆ¬ ì‹œì‘', value: 'ê³§ ë°°í‹€ì´ ì‹œì‘í•©ë‹ˆë‹¤!', inline: true }
                    );
                
                await player.channel.send({ embeds: [matchFoundEmbed] });
            } catch (error) {
                console.error('ë´‡ ë§¤ì¹­ ì„±ê³µ ì•Œë¦¼ ì „ì†¡ ì˜¤ë¥˜:', error);
            }
        }
        
        await this.createMatch(player, botData);
    }

    // ë§¤ì¹˜ ìƒì„±
    async createMatch(player1, player2) {
        const matchId = Date.now().toString();
        
        // í‹°ì¼“ ì†Œëª¨
        if (!player1.isBot) {
            player1.user.pvp.duelTickets -= 1;
            await player1.user.save();
        }
        if (!player2.isBot) {
            player2.user.pvp.duelTickets -= 1;
            await player2.user.save();
        }

        // í”Œë ˆì´ì–´ ìŠ¤íƒ¯ ê³„ì‚°
        const p1Stats = this.calculateCombatStats(player1);
        const p2Stats = this.calculateCombatStats(player2);
        
        const match = {
            matchId: matchId,
            player1,
            player2,
            status: 'preparing',
            startTime: Date.now(),
            round: 0,
            battleLog: [],
            pendingActions: new Map(),
            player1HP: p1Stats.maxHp,
            player2HP: p2Stats.maxHp
        };

        this.activeMatches.set(matchId, match);

        // íœë“¤ëŸ¼ ë°°í‹€ ì‹œì‘
        await this.startPendulumBattle(match);
        
        return { 
            success: true, 
            message: 'ë§¤ì¹˜ê°€ ì„±ì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!',
            matchId 
        };
    }

    // ì „íˆ¬ ì‹œë®¬ë ˆì´ì…˜
    async simulateBattle(player1, player2) {
        const p1Stats = this.calculateCombatStats(player1);
        const p2Stats = this.calculateCombatStats(player2);

        const battles = [];
        let p1Hp = p1Stats.maxHp;
        let p2Hp = p2Stats.maxHp;
        let turn = 1;

        while (p1Hp > 0 && p2Hp > 0 && turn <= 20) {
            const round = {};
            
            // í”Œë ˆì´ì–´ 1 ê³µê²©
            if (Math.random() < p1Stats.accuracy) {
                let damage = Math.floor(p1Stats.attack * (0.8 + Math.random() * 0.4));
                const critChance = p1Stats.critRate;
                const isCrit = Math.random() < critChance;
                if (isCrit) damage *= 2;
                
                p2Hp = Math.max(0, p2Hp - Math.max(1, damage - p2Stats.defense));
                round.p1Action = {
                    damage,
                    isCrit,
                    remainingHp: p2Hp
                };
            } else {
                round.p1Action = { miss: true };
            }

            // í”Œë ˆì´ì–´ 2 ê³µê²© (ìƒì¡´ì‹œ)
            if (p2Hp > 0) {
                if (Math.random() < p2Stats.accuracy) {
                    let damage = Math.floor(p2Stats.attack * (0.8 + Math.random() * 0.4));
                    const critChance = p2Stats.critRate;
                    const isCrit = Math.random() < critChance;
                    if (isCrit) damage *= 2;
                    
                    p1Hp = Math.max(0, p1Hp - Math.max(1, damage - p1Stats.defense));
                    round.p2Action = {
                        damage,
                        isCrit,
                        remainingHp: p1Hp
                    };
                } else {
                    round.p2Action = { miss: true };
                }
            }

            battles.push(round);
            turn++;
        }

        const winner = p1Hp > p2Hp ? 'player1' : 'player2';
        
        return {
            winner,
            battles,
            finalHp: { p1: p1Hp, p2: p2Hp },
            totalTurns: turn - 1
        };
    }

    // ì „íˆ¬ë ¥ ê³„ì‚°
    calculateCombatStats(player) {
        const user = player.user;
        let baseStats;
        
        if (player.isBot) {
            baseStats = user.stats;
        } else {
            baseStats = user.stats;
        }

        // ì¥ë¹„ ìŠ¤íƒ¯ ê³„ì‚°
        let equipmentBonus = { attack: 0, defense: 0, dodge: 0, luck: 0 };
        const weapon = getEquippedItem(user, 'weapon');
        const armor = getEquippedItem(user, 'armor');
        
        if (weapon && weapon.stats) {
            equipmentBonus.attack += weapon.stats.attack?.[0] || 0;
        }
        if (armor && armor.stats) {
            equipmentBonus.defense += armor.stats.defense?.[0] || 0;
        }

        const totalStats = {
            strength: baseStats.strength + Math.floor(equipmentBonus.attack / 10),
            agility: baseStats.agility + Math.floor(equipmentBonus.dodge / 10),
            intelligence: baseStats.intelligence,
            vitality: baseStats.vitality + Math.floor(equipmentBonus.defense / 10),
            luck: baseStats.luck + Math.floor(equipmentBonus.luck / 10)
        };

        return {
            attack: totalStats.strength * 2 + equipmentBonus.attack,
            defense: totalStats.vitality + equipmentBonus.defense,
            maxHp: totalStats.vitality * 10 + (user.level || 1) * 50,
            accuracy: Math.min(0.95, 0.7 + (totalStats.agility / 1000)),
            critRate: Math.min(0.3, 0.05 + (totalStats.luck / 1000)),
            dodge: Math.min(0.2, totalStats.agility / 1000)
        };
    }

    // ë§¤ì¹˜ ê²°ê³¼ ì²˜ë¦¬
    async processMatchResult(match, battleResult) {
        const winner = battleResult.winner === 'player1' ? match.player1 : match.player2;
        const loser = battleResult.winner === 'player1' ? match.player2 : match.player1;

        // ë ˆì´íŒ… ê³„ì‚°
        const { winnerNewRating, loserNewRating, ratingChange } = this.calculateRatingChange(
            winner.rating, 
            loser.rating, 
            battleResult.winner === 'player1'
        );

        // ê²°ê³¼ ì €ì¥ (ë´‡ì´ ì•„ë‹Œ ê²½ìš°ë§Œ)
        if (!winner.isBot) {
            await this.updatePlayerStats(winner.user, true, ratingChange, loser.user.nickname || loser.user.name);
        }
        if (!loser.isBot) {
            await this.updatePlayerStats(loser.user, false, -ratingChange, winner.user.nickname || winner.user.name);
        }

        // ê²°ê³¼ ë©”ì‹œì§€ ì „ì†¡
        await this.sendBattleResult(match, battleResult, winner, loser, ratingChange);
        
        // ë§¤ì¹˜ ì •ë¦¬
        this.activeMatches.delete(match.id);
    }

    // ë ˆì´íŒ… ë³€í™” ê³„ì‚°
    calculateRatingChange(winnerRating, loserRating, player1Won) {
        const K = 32; // K-factor
        const expectedWin = 1 / (1 + Math.pow(10, (loserRating - winnerRating) / 400));
        const ratingChange = Math.round(K * (1 - expectedWin));
        
        return {
            winnerNewRating: winnerRating + ratingChange,
            loserNewRating: loserRating - ratingChange,
            ratingChange
        };
    }

    // í”Œë ˆì´ì–´ í†µê³„ ì—…ë°ì´íŠ¸
    async updatePlayerStats(user, isWin, ratingChange, opponentName) {
        user.pvp.rating += ratingChange;
        user.pvp.tier = this.getTierByRating(user.pvp.rating);
        user.pvp.totalDuels += 1;
        
        if (isWin) {
            user.pvp.wins += 1;
            user.pvp.winStreak += 1;
            user.pvp.maxWinStreak = Math.max(user.pvp.maxWinStreak, user.pvp.winStreak);
        } else {
            user.pvp.losses += 1;
            user.pvp.winStreak = 0;
        }

        user.pvp.highestRating = Math.max(user.pvp.highestRating, user.pvp.rating);
        user.pvp.lastMatchTime = new Date();

        // ë§¤ì¹˜ íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸ (ìµœê·¼ 10ê²½ê¸°)
        user.pvp.matchHistory.unshift({
            opponent: opponentName,
            opponentRating: user.pvp.rating - ratingChange,
            result: isWin ? 'win' : 'lose',
            ratingChange: ratingChange,
            date: new Date()
        });

        if (user.pvp.matchHistory.length > 10) {
            user.pvp.matchHistory = user.pvp.matchHistory.slice(0, 10);
        }

        await user.save();
    }

    // ë ˆì´íŒ…ìœ¼ë¡œ í‹°ì–´ ê³„ì‚°
    getTierByRating(rating) {
        for (const [tier, range] of Object.entries(this.tierRanges)) {
            if (rating >= range.min && rating <= range.max) {
                return tier;
            }
        }
        return 'Bronze';
    }

    // ì „íˆ¬ ê²°ê³¼ ì „ì†¡
    async sendBattleResult(match, battleResult, winner, loser, ratingChange) {
        const channel = match.player1.channel || match.player2.channel;
        if (!channel) return;

        const p1Name = match.player1.user.nickname || match.player1.user.name || 'í”Œë ˆì´ì–´1';
        const p2Name = match.player2.user.nickname || match.player2.user.name || 'í”Œë ˆì´ì–´2';
        
        const winnerName = winner === match.player1 ? p1Name : p2Name;
        const loserName = loser === match.player1 ? p1Name : p2Name;

        // ì „íˆ¬ ê³¼ì • í…ìŠ¤íŠ¸ ìƒì„± (íœë“¤ëŸ¼ ë°°í‹€ í˜•ì‹)
        let battleLog = '';
        if (battleResult.battles && battleResult.battles.length > 0) {
            battleResult.battles.forEach((round, index) => {
                battleLog += `**Round ${round.round || index + 1}**\n`;
                
                // íœë“¤ëŸ¼ ë°°í‹€ í˜•ì‹
                if (round.p1Damage !== undefined && round.p2Damage !== undefined) {
                    battleLog += `${p1Name}: ${round.p1Damage} í”¼í•´ ì…í˜\n`;
                    battleLog += `${p2Name}: ${round.p2Damage} í”¼í•´ ì…í˜\n`;
                }
                // ê¸°ì¡´ ì‹œë®¬ë ˆì´ì…˜ í˜•ì‹ (í˜¸í™˜ì„±)
                else if (round.p1Action) {
                    if (round.p1Action.miss) {
                        battleLog += `${p1Name}: ê³µê²© ì‹¤íŒ¨!\n`;
                    } else {
                        const critText = round.p1Action.isCrit ? ' **í¬ë¦¬í‹°ì»¬!**' : '';
                        battleLog += `${p1Name}: ${round.p1Action.damage} í”¼í•´${critText}\n`;
                    }
                    
                    if (round.p2Action) {
                        if (round.p2Action.miss) {
                            battleLog += `${p2Name}: ê³µê²© ì‹¤íŒ¨!\n`;
                        } else {
                            const critText = round.p2Action.isCrit ? ' **í¬ë¦¬í‹°ì»¬!**' : '';
                            battleLog += `${p2Name}: ${round.p2Action.damage} í”¼í•´${critText}\n`;
                        }
                    }
                }
                battleLog += '\n';
            });
        }

        const resultEmbed = new EmbedBuilder()
            .setTitle('âš”ï¸ PVP ê²°íˆ¬ ê²°ê³¼')
            .setColor(winner === match.player1 ? 0x00ff00 : 0xff0000)
            .addFields(
                {
                    name: 'ğŸ† ìŠ¹ì',
                    value: `${winnerName}\në ˆì´íŒ…: ${winner.rating} (+${ratingChange})`,
                    inline: true
                },
                {
                    name: 'ğŸ’” íŒ¨ì',
                    value: `${loserName}\në ˆì´íŒ…: ${loser.rating} (-${ratingChange})`,
                    inline: true
                },
                {
                    name: 'âš”ï¸ ì „íˆ¬ ê³¼ì •',
                    value: battleLog.length > 1024 ? battleLog.substring(0, 1021) + '...' : battleLog,
                    inline: false
                }
            )
            .setFooter({ text: `ì´ ${battleResult.totalTurns}í„´ ì§„í–‰` })
            .setTimestamp();

        await channel.send({ embeds: [resultEmbed] });
    }

    // í ë– ë‚˜ê¸°
    leaveQueue(userId) {
        if (this.matchmakingQueue.has(userId)) {
            this.matchmakingQueue.delete(userId);
            return { success: true, message: 'ë§¤ì¹˜ë©”ì´í‚¹ íì—ì„œ ë‚˜ì™”ìŠµë‹ˆë‹¤.' };
        }
        return { success: false, message: 'ë§¤ì¹˜ë©”ì´í‚¹ íì— ì°¸ê°€í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.' };
    }

    // PVP ì •ë³´ ì¡°íšŒ
    async getPVPInfo(user) {
        await this.regenerateTickets(user);
        
        const tierEmoji = {
            'Bronze': 'ğŸ¥‰',
            'Silver': 'ğŸ¥ˆ', 
            'Gold': 'ğŸ¥‡',
            'Platinum': 'ğŸ’',
            'Master': 'ğŸŒŸ',
            'Grandmaster': 'ğŸ‘‘',
            'Challenger': 'ğŸ†'
        };

        const winRate = user.pvp.totalDuels > 0 ? 
            ((user.pvp.wins / user.pvp.totalDuels) * 100).toFixed(1) : 0;

        return {
            rating: user.pvp.rating,
            tier: user.pvp.tier,
            tierEmoji: tierEmoji[user.pvp.tier] || 'ğŸ¥‰',
            duelTickets: user.pvp.duelTickets,
            totalDuels: user.pvp.totalDuels,
            wins: user.pvp.wins,
            losses: user.pvp.losses,
            winRate,
            winStreak: user.pvp.winStreak,
            maxWinStreak: user.pvp.maxWinStreak,
            highestRating: user.pvp.highestRating,
            matchHistory: user.pvp.matchHistory || []
        };
    }
    
    // íœë“¤ëŸ¼ ë°°í‹€ ì‹œìŠ¤í…œ
    async startPendulumBattle(match) {
        match.round = 1;
        match.battleLog = [];
        match.pendingActions = new Map();
        await this.showBattleRound(match);
    }
    
    async showBattleRound(match) {
        const { player1, player2 } = match;
        const p1Stats = this.calculateCombatStats(player1);
        const p2Stats = this.calculateCombatStats(player2);
        
        // HP ë°” ìƒì„±
        const createHPBar = (current, max) => {
            const percentage = Math.max(0, Math.floor((current / max) * 10));
            const filled = 'ğŸŸ©'.repeat(percentage);
            const empty = 'â¬œ'.repeat(10 - percentage);
            return `${filled}${empty} ${current}/${max}`;
        };
        
        // í”Œë ˆì´ì–´ ì •ë³´ ê°€ì ¸ì˜¤ê¸° (ë´‡ ëŒ€ì‘)
        const getPlayerName = (player) => {
            if (player.isBot) {
                return player.user.nickname || 'ë´‡';
            }
            return player.user.nickname || 'í”Œë ˆì´ì–´';
        };
        
        const getPlayerRating = (player) => {
            if (player.isBot) {
                return player.rating || player.user.rating || 1000;
            }
            return player.user.pvp?.rating || 1000;
        };
        
        const battleEmbed = new EmbedBuilder()
            .setColor('#ff6b6b')
            .setTitle(`âš”ï¸ ì „íˆ¬ ë ˆì´ë“œ - Round ${match.round}`)
            .setDescription('ğŸ¯ **ê³µê²© íƒ€ì´ë°ì„ ì„ íƒí•˜ì„¸ìš”!** (10ì´ˆ ì œí•œ)\nâ€¢ ìƒëŒ€ì™€ ê°™ì€ ìœ„ì¹˜ â†’ ë°©ì–´ ì„±ê³µ! (ëŒ€ë¯¸ì§€ 70% ê°ì†Œ)\nâ€¢ ìƒëŒ€ì™€ ë‹¤ë¥¸ ìœ„ì¹˜ â†’ ê³µê²© ì„±ê³µ! (í’€ ë°ë¯¸ì§€)')
            .addFields(
                { 
                    name: `âš”ï¸ ${getPlayerName(player1)}`,
                    value: `${createHPBar(match.player1HP, p1Stats.maxHp)}\nğŸ”¥ ì „íˆ¬ë ¥: ${p1Stats.attack}\nğŸ›¡ï¸ ë°©ì–´ë ¥: ${p1Stats.defense}\nğŸ† ë ˆì´íŒ…: ${getPlayerRating(player1)}`,
                    inline: true
                },
                { 
                    name: 'â€‹', 
                    value: 'â€‹', 
                    inline: true 
                },
                { 
                    name: `âš”ï¸ ${getPlayerName(player2)}`,
                    value: `${createHPBar(match.player2HP, p2Stats.maxHp)}\nğŸ”¥ ì „íˆ¬ë ¥: ${p2Stats.attack}\nğŸ›¡ï¸ ë°©ì–´ë ¥: ${p2Stats.defense}\nğŸ† ë ˆì´íŒ…: ${getPlayerRating(player2)}`,
                    inline: true
                }
            );
        
        const actionRow = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId(`pvp_pendulum_${match.matchId}_high`)
                    .setLabel('ë³„ë˜¥ë² ê¸°')
                    .setEmoji('ğŸŒŸ')
                    .setStyle(ButtonStyle.Primary),
                new ButtonBuilder()
                    .setCustomId(`pvp_pendulum_${match.matchId}_middle`)
                    .setLabel('ìŠˆê°€ìŠ¤íŒ…')
                    .setEmoji('ğŸ¬')
                    .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                    .setCustomId(`pvp_pendulum_${match.matchId}_low`)
                    .setLabel('ë²„ì„¯íŒ¡')
                    .setEmoji('ğŸ„')
                    .setStyle(ButtonStyle.Danger)
            );
        
        // ë‘ í”Œë ˆì´ì–´ ëª¨ë‘ì—ê²Œ ë©”ì‹œì§€ ì „ì†¡
        const channels = [];
        if (!player1.isBot && player1.channel) channels.push(player1.channel);
        if (!player2.isBot && player2.channel) channels.push(player2.channel);
        
        for (const channel of channels) {
            try {
                await channel.send({ 
                    embeds: [battleEmbed], 
                    components: [actionRow] 
                });
            } catch (error) {
                console.error('ë°°í‹€ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨:', error);
            }
        }
        
        // ë´‡ì¸ ê²½ìš° ìë™ ì„ íƒ
        if (player1.isBot) {
            setTimeout(() => this.makeBotChoice(match, 'player1'), Math.random() * 5000 + 2000);
        }
        if (player2.isBot) {
            setTimeout(() => this.makeBotChoice(match, 'player2'), Math.random() * 5000 + 2000);
        }
        
        // 10ì´ˆ íƒ€ì´ë¨¸ ì„¤ì • (ì¤‘ë³µ ë°©ì§€ë¥¼ ìœ„í•´ ê¸°ì¡´ íƒ€ì´ë¨¸ ì·¨ì†Œ)
        if (match.roundTimer) {
            clearTimeout(match.roundTimer);
        }
        match.roundTimer = setTimeout(() => this.resolveRound(match), 10000);
    }
    
    makeBotChoice(match, playerKey) {
        const positions = ['high', 'middle', 'low'];
        const choice = positions[Math.floor(Math.random() * positions.length)];
        match.pendingActions.set(playerKey, choice);
    }
    
    async handlePendulumChoice(interaction, matchId, position) {
        const match = this.activeMatches.get(matchId);
        if (!match) {
            await interaction.reply({ content: 'ë§¤ì¹˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
            return;
        }
        
        const userId = interaction.user.id;
        let playerKey;
        
        // ë””ë²„ê¹…ìš© ë¡œê·¸
        console.log(`íœë“¤ëŸ¼ ì„ íƒ - User ID: ${userId}`);
        console.log(`Player1 ì „ì²´ ë°ì´í„°:`, JSON.stringify({
            userId: match.player1.userId,
            isBot: match.player1.isBot,
            discordId: match.player1.user?.discordId,
            nickname: match.player1.user?.nickname
        }));
        console.log(`Player2 ì „ì²´ ë°ì´í„°:`, JSON.stringify({
            userId: match.player2.userId,
            isBot: match.player2.isBot,
            discordId: match.player2.user?.discordId,
            nickname: match.player2.user?.nickname
        }));
        
        // userIdë¡œ ë¹„êµ (ë´‡ì´ ì•„ë‹Œ ê²½ìš°)
        if (!match.player1.isBot && match.player1.userId === userId) {
            playerKey = 'player1';
        } else if (!match.player2.isBot && match.player2.userId === userId) {
            playerKey = 'player2';
        } else {
            console.log(`ë§¤ì¹˜ ì°¸ê°€ì í™•ì¸ ì‹¤íŒ¨ - ìš”ì²­ userId: ${userId}`);
            await interaction.reply({ content: 'ì´ ëŒ€ê²°ì˜ ì°¸ê°€ìê°€ ì•„ë‹™ë‹ˆë‹¤!', flags: 64 });
            return;
        }
        
        if (match.pendingActions.has(playerKey)) {
            await interaction.reply({ content: 'ì´ë¯¸ ê³µê²© íƒ€ì´ë°ì„ ì„ íƒí–ˆìŠµë‹ˆë‹¤!', flags: 64 });
            return;
        }
        
        match.pendingActions.set(playerKey, position);
        
        const attackNames = {
            'high': 'ğŸŒŸ ë³„ë˜¥ë² ê¸°',
            'middle': 'ğŸ¬ ìŠˆê°€ìŠ¤íŒ…',
            'low': 'ğŸ„ ë²„ì„¯íŒ¡'
        };
        
        await interaction.reply({ 
            content: `âš”ï¸ **${attackNames[position]}** ì¤€ë¹„ ì™„ë£Œ! ë°˜ì§~âœ¨`, 
            flags: 64 
        });
        
        // ë‘ í”Œë ˆì´ì–´ ëª¨ë‘ ì„ íƒí–ˆìœ¼ë©´ ì¦‰ì‹œ ë¼ìš´ë“œ ì¢…ë£Œ
        if (match.pendingActions.size === 2) {
            clearTimeout(match.roundTimer);
            await this.resolveRound(match);
        }
    }
    
    async resolveRound(match) {
        const { player1, player2 } = match;
        const p1Stats = this.calculateCombatStats(player1);
        const p2Stats = this.calculateCombatStats(player2);
        
        const p1Choice = match.pendingActions.get('player1') || 'middle';
        const p2Choice = match.pendingActions.get('player2') || 'middle';
        
        // í”Œë ˆì´ì–´ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
        const getPlayerName = (player) => {
            if (player.isBot) return player.user.nickname || 'ë´‡';
            return player.user.nickname || 'í”Œë ˆì´ì–´';
        };
        
        // ê³µê²© ì´ë¦„ ë³€í™˜
        const getAttackName = (choice) => {
            switch(choice) {
                case 'high': return 'ë³„ë˜¥ë² ê¸° âœ¨';
                case 'middle': return 'ìŠˆê°€ìŠ¤íŒ… ğŸ­';
                case 'low': return 'ë²„ì„¯íŒ¡ ğŸ„';
                default: return 'ê¸°ë³¸ ê³µê²©';
            }
        };
        
        // PVP ê°•í™” ë³´ë„ˆìŠ¤ ì ìš©
        const getEnhancementBonus = (player, position) => {
            if (player.isBot) return 0;
            const enhancement = player.user.pvp?.attackEnhancement?.[position] || 0;
            return enhancement; // ê°•í™”ë‹¹ +1 ë°ë¯¸ì§€
        };
        
        const p1Enhancement = getEnhancementBonus(player1, p1Choice);
        const p2Enhancement = getEnhancementBonus(player2, p2Choice);
        
        let p1ActualDamage = 0;
        let p2ActualDamage = 0;
        let battleDescription = '';
        
        if (p1Choice === p2Choice) {
            // ê°™ì€ ìœ„ì¹˜ - ë°©ì–´ ì„±ê³µ (30% ë°ë¯¸ì§€)
            const p1RawDamage = Math.floor((p1Stats.attack + p1Enhancement) * 0.3);
            const p2RawDamage = Math.floor((p2Stats.attack + p2Enhancement) * 0.3);
            p1ActualDamage = Math.max(1, p1RawDamage - p2Stats.defense);
            p2ActualDamage = Math.max(1, p2RawDamage - p1Stats.defense);
            
            battleDescription = `ğŸ›¡ï¸ **ë™ì‹œ ê³µê²©!** ë‘ ì „ì‚¬ ëª¨ë‘ ${getAttackName(p1Choice)}ë¥¼ ì‹œì „!\n\n`;
            battleDescription += `âš”ï¸ **${getPlayerName(player1)}**ì˜ ê³µê²©!\n`;
            battleDescription += `â€¢ ê¸°ë³¸ ë°ë¯¸ì§€: ${p1RawDamage} â†’ ë°©ì–´ ì„±ê³µ! (70% ì°¨ë‹¨)\n`;
            battleDescription += `â€¢ **${getPlayerName(player2)}**ê°€ ${p1ActualDamage} ë°ë¯¸ì§€ ë°›ìŒ!\n\n`;
            battleDescription += `âš”ï¸ **${getPlayerName(player2)}**ì˜ ë°˜ê²©!\n`;
            battleDescription += `â€¢ ê¸°ë³¸ ë°ë¯¸ì§€: ${p2RawDamage} â†’ ë°©ì–´ ì„±ê³µ! (70% ì°¨ë‹¨)\n`;
            battleDescription += `â€¢ **${getPlayerName(player1)}**ê°€ ${p2ActualDamage} ë°ë¯¸ì§€ ë°›ìŒ!`;
        } else {
            // ë‹¤ë¥¸ ìœ„ì¹˜ - í’€ ë°ë¯¸ì§€
            p1ActualDamage = Math.max(1, (p1Stats.attack + p1Enhancement) - p2Stats.defense);
            p2ActualDamage = Math.max(1, (p2Stats.attack + p2Enhancement) - p1Stats.defense);
            
            battleDescription = `ğŸ’¥ **í¬ë¡œìŠ¤ ì¹´ìš´í„°!** ì„œë¡œ ë‹¤ë¥¸ ê³µê²© íŒ¨í„´!\n\n`;
            battleDescription += `âš”ï¸ **${getPlayerName(player1)}**ì˜ ${getAttackName(p1Choice)}!\n`;
            battleDescription += `â€¢ ê³µê²©ë ¥: ${p1Stats.attack}${p1Enhancement > 0 ? ` (+${p1Enhancement}ê°•)` : ''} - ë°©ì–´ë ¥: ${p2Stats.defense}\n`;
            battleDescription += `â€¢ ğŸ’¢ **${getPlayerName(player2)}**ì—ê²Œ ${p1ActualDamage} ë°ë¯¸ì§€!\n\n`;
            battleDescription += `âš”ï¸ **${getPlayerName(player2)}**ì˜ ${getAttackName(p2Choice)}!\n`;
            battleDescription += `â€¢ ê³µê²©ë ¥: ${p2Stats.attack}${p2Enhancement > 0 ? ` (+${p2Enhancement}ê°•)` : ''} - ë°©ì–´ë ¥: ${p1Stats.defense}\n`;
            battleDescription += `â€¢ ğŸ’¢ **${getPlayerName(player1)}**ì—ê²Œ ${p2ActualDamage} ë°ë¯¸ì§€!`;
        }
        
        // ë°ë¯¸ì§€ ì ìš©
        match.player2HP = Math.max(0, match.player2HP - p1ActualDamage);
        match.player1HP = Math.max(0, match.player1HP - p2ActualDamage);
        
        // HP ë°” ìƒì„±
        const createHPBar = (current, max) => {
            const percentage = Math.max(0, Math.floor((current / max) * 10));
            const filled = 'ğŸŸ©'.repeat(percentage);
            const empty = 'â¬œ'.repeat(10 - percentage);
            return `${filled}${empty} ${current}/${max}`;
        };
        
        // ì „íˆ¬ ê²°ê³¼ ì„ë² ë“œ
        const resultEmbed = new EmbedBuilder()
            .setColor(p1Choice === p2Choice ? '#FFA500' : '#FF0000')
            .setTitle(`âš”ï¸ Round ${match.round} ê²°ê³¼`)
            .setDescription(battleDescription)
            .addFields(
                {
                    name: `${getPlayerName(player1)} ìƒíƒœ`,
                    value: createHPBar(match.player1HP, p1Stats.maxHp),
                    inline: true
                },
                {
                    name: `${getPlayerName(player2)} ìƒíƒœ`,
                    value: createHPBar(match.player2HP, p2Stats.maxHp),
                    inline: true
                }
            )
            .setTimestamp();
        
        // ëª¨ë“  ì±„ë„ì— ê²°ê³¼ ì „ì†¡
        const channels = [];
        if (!player1.isBot && player1.channel) channels.push(player1.channel);
        if (!player2.isBot && player2.channel) channels.push(player2.channel);
        
        for (const channel of channels) {
            try {
                await channel.send({ embeds: [resultEmbed] });
            } catch (error) {
                console.error('ì „íˆ¬ ê²°ê³¼ ì „ì†¡ ì‹¤íŒ¨:', error);
            }
        }
        
        match.battleLog.push({
            round: match.round,
            p1Choice,
            p2Choice,
            p1Damage: p1ActualDamage,
            p2Damage: p2ActualDamage,
            result: battleDescription
        });
        
        // ì „íˆ¬ ì¢…ë£Œ ì²´í¬
        if (match.player1HP <= 0 || match.player2HP <= 0 || match.round >= 10) {
            // 2ì´ˆ í›„ ìµœì¢… ê²°ê³¼ í‘œì‹œ
            setTimeout(() => this.endPendulumBattle(match), 2000);
        } else {
            // ë‹¤ìŒ ë¼ìš´ë“œ (3ì´ˆ ëŒ€ê¸°)
            match.round++;
            match.pendingActions.clear();
            setTimeout(() => this.showBattleRound(match), 3000);
        }
    }
    
    async endPendulumBattle(match) {
        const winner = match.player1HP > match.player2HP ? 'player1' : 'player2';
        const battleResult = {
            winner,
            battles: match.battleLog,
            finalHp: { p1: match.player1HP, p2: match.player2HP },
            totalTurns: match.round
        };
        
        await this.processMatchResult(match, battleResult);
    }
}

const pvpSystem = new PVPSystem();

// ì˜ë¢° ì‹œìŠ¤í…œ í•¨ìˆ˜ë“¤
function getRandomQuest() {
    const allClients = [
        ...QUEST_CLIENTS.villagers,
        ...QUEST_CLIENTS.merchants,
        ...QUEST_CLIENTS.scammers,
        ...QUEST_CLIENTS.travelers
    ];
    return allClients[Math.floor(Math.random() * allClients.length)];
}

function calculateQuestReward(userLevel, questType) {
    if (questType === 'scam') {
        return null; // ì‚¬ê¸° ì˜ë¢°ëŠ” ë³´ìƒ ì—†ìŒ
    }
    
    // ë ˆë²¨ì— ë¹„ë¡€í•œ ë³´ìƒ (100ë ˆë²¨ì„ ê¸°ì¤€ìœ¼ë¡œ 100~1000 ê³¨ë“œ)
    const baseReward = Math.floor(Math.random() * 900) + 100; // 100~1000 ê³¨ë“œ
    const levelMultiplier = userLevel / 100; // ë ˆë²¨ ë°°ìœ¨
    const finalReward = Math.floor(baseReward * (0.5 + levelMultiplier)); // ìµœì†Œ 50% ë³´ì¥
    
    return {
        gold: finalReward,
        exp: Math.floor(finalReward / 10) // ê³¨ë“œì˜ 10% ê²½í—˜ì¹˜
    };
}

function addQuestCooldown(userId) {
    if (!global.questCooldowns) {
        global.questCooldowns = new Map();
    }
    global.questCooldowns.set(userId, Date.now() + (30 * 60 * 1000)); // 30ë¶„ ì¿¨íƒ€ì„
}

function checkQuestCooldown(userId) {
    if (!global.questCooldowns) {
        global.questCooldowns = new Map();
    }
    const cooldownEnd = global.questCooldowns.get(userId);
    if (!cooldownEnd) return false;
    
    const timeLeft = cooldownEnd - Date.now();
    return timeLeft > 0 ? Math.ceil(timeLeft / (60 * 1000)) : false; // ë‚¨ì€ ë¶„ ìˆ˜ ë°˜í™˜
}

// ğŸ”® ì—ë„ˆì§€ ì¡°ê° ìœµí•© ì‹œìŠ¤í…œ ìƒìˆ˜
const ENERGY_FRAGMENT_SYSTEM = {
    MINE_COST: 500, // ì±„êµ´ ë¹„ìš©
    MINE_COOLDOWN: 2 * 60 * 1000, // 2ë¶„ ì¿¨íƒ€ì„
    DAILY_FUSION_LIMIT: 20, // ì¼ì¼ ìœµí•© ì œí•œ
    
    // ë‹¨ê³„ë³„ ì´ë¦„ê³¼ ì´ëª¨ì§€
    TIER_NAMES: {
        '1-10': { name: 'ê¸°ì´ˆ ì—ë„ˆì§€ ì¡°ê°', emoji: 'ğŸ”¸' },
        '11-25': { name: 'ë§ˆë²• ì—ë„ˆì§€ ì¡°ê°', emoji: 'ğŸ’ ' },
        '26-50': { name: 'í¬ë¦¬ìŠ¤íƒˆ ì—ë„ˆì§€ ì¡°ê°', emoji: 'ğŸ’' },
        '51-75': { name: 'ë³„ë¹› ì—ë„ˆì§€ ì¡°ê°', emoji: 'â­' },
        '76-99': { name: 'ì°½ì¡° ì—ë„ˆì§€ ì¡°ê°', emoji: 'ğŸŒŒ' },
        '100': { name: 'ê¶ê·¹ì˜ ì°½ì¡°ì„', emoji: 'âœ¨' }
    },
    
    // ì„±ê³µ í™•ë¥ 
    SUCCESS_RATES: {
        '1-25': 85,
        '26-50': 80,
        '51-75': 75,
        '76-99': 70,
        '99-100': 50
    },
    
    // ì‹¤íŒ¨ ì‹œ í•˜ë½ ë²”ìœ„
    FAIL_DROP: { min: 10, max: 30 },
    CRITICAL_FAIL_CHANCE: 1, // ëŒ€ì‹¤íŒ¨ í™•ë¥  1%
    
    // ì‚¬ëƒ¥í„° ë“œë¡­ë¥ 
    HUNTING_DROP_CHANCE: 0.1, // 0.1%
    
    // ì‹¤íŒ¨ ìŠ¤íƒ
    FAILURE_STACK_CHANCE: 50, // ì‹¤íŒ¨ ì‹œ 50% í™•ë¥ ë¡œ ìŠ¤íƒ
    FAILURE_STACK_REQUIRED: 10, // 10ìŠ¤íƒ ì‹œ ì„±ê³µ í™•ì •
    
    // ì£¼ì‹ ì˜í–¥ë„
    STOCK_IMPACT: {
        '1-10': { company: 'í¬ë¦¬ìŠ¤íƒˆ ì±„êµ´ê³µì‚¬', success: 5, fail: -3 },
        '11-25': { company: 'ë§ˆë²• ì—°êµ¬ì›', success: 8, fail: -4 },
        '26-50': { company: 'ìˆ˜ì • ê°€ê³µì—…ì²´', success: 12, fail: -5 },
        '51-75': { company: 'ë³„ë¹› ì—°êµ¬ì†Œ', success: 15, fail: -6 },
        '76-99': { company: 'ì°½ì¡° ê¸°ìˆ ì›', success: 20, fail: -8 },
        '100': { company: 'ì „ì²´ì‹œì¥', success: 50, fail: -25 }
    }
};

// ì—ë„ˆì§€ ì¡°ê° ê´€ë ¨ í—¬í¼ í•¨ìˆ˜ë“¤
function getFragmentTier(level) {
    if (level >= 1 && level <= 10) return '1-10';
    if (level >= 11 && level <= 25) return '11-25';
    if (level >= 26 && level <= 50) return '26-50';
    if (level >= 51 && level <= 75) return '51-75';
    if (level >= 76 && level <= 99) return '76-99';
    if (level === 100) return '100';
    return null;
}

function getFragmentInfo(level) {
    const tier = getFragmentTier(level);
    return ENERGY_FRAGMENT_SYSTEM.TIER_NAMES[tier] || { name: 'ì•Œ ìˆ˜ ì—†ëŠ” ì¡°ê°', emoji: 'â“' };
}

function getSuccessRate(level) {
    if (level >= 1 && level <= 25) return ENERGY_FRAGMENT_SYSTEM.SUCCESS_RATES['1-25'];
    if (level >= 26 && level <= 50) return ENERGY_FRAGMENT_SYSTEM.SUCCESS_RATES['26-50'];
    if (level >= 51 && level <= 75) return ENERGY_FRAGMENT_SYSTEM.SUCCESS_RATES['51-75'];
    if (level >= 76 && level <= 99) return ENERGY_FRAGMENT_SYSTEM.SUCCESS_RATES['76-99'];
    if (level === 99) return ENERGY_FRAGMENT_SYSTEM.SUCCESS_RATES['99-100'];
    return 70;
}

function calculateFusionCost(level) {
    return level * 1000; // í˜„ì¬ ë‹¨ê³„ Ã— 1000ê³¨ë“œ
}

function calculateCombatPowerFromFragment(level) {
    // ì „íˆ¬ë ¥ = (ë‹¨ê³„ ^ 1.5) Ã— 100
    return Math.floor(Math.pow(level, 1.5) * 100);
}

// ğŸª ì•„ì´í…œ ê²½ë§¤ì¥ ì‹œìŠ¤í…œ í•¨ìˆ˜ë“¤
// ì‹œì¥ ê°€ê²© ê³„ì‚° í•¨ìˆ˜
function calculateItemMarketPrice(itemName, rarity, basePrice) {
    const now = Date.now();
    
    // ì‹œì¥ ì´ë²¤íŠ¸ ì—…ë°ì´íŠ¸ (6ì‹œê°„ë§ˆë‹¤)
    if (now - lastMarketUpdate > 6 * 60 * 60 * 1000) {
        updateMarketEvent();
        lastMarketUpdate = now;
    }
    
    // ê¸°ë³¸ ê°€ê²©ì— í¬ê·€ë„ ë°°ìˆ˜ ì ìš©
    const rarityMultipliers = {
        'ì¼ë°˜': 1.0,
        'ê³ ê¸‰': 1.5,
        'ë ˆì–´': 2.5,
        'ì—í”½': 4.0,
        'ë ˆì „ë“œë¦¬': 8.0,
        'ì‹ í™”': 15.0
    };
    
    let marketPrice = basePrice * (rarityMultipliers[rarity] || 1.0);
    
    // ì‹œì¥ ì´ë²¤íŠ¸ ì˜í–¥ ì ìš©
    if (currentMarketEvent) {
        const { effect } = currentMarketEvent;
        const itemType = getItemType(itemName);
        
        if (effect.items.includes('all') || effect.items.includes(itemType)) {
            switch (effect.type) {
                case 'supply_increase':
                    marketPrice *= (1 / effect.value); // ê³µê¸‰ ì¦ê°€ -> ê°€ê²© í•˜ë½
                    break;
                case 'demand_increase':
                    marketPrice *= effect.value; // ìˆ˜ìš” ì¦ê°€ -> ê°€ê²© ìƒìŠ¹
                    break;
                case 'price_spike':
                    marketPrice *= effect.value; // ê°€ê²© ê¸‰ë“±
                    break;
                case 'market_crash':
                    marketPrice *= effect.value; // ì‹œì¥ í­ë½
                    break;
                case 'price_boost':
                    marketPrice *= effect.value; // ê°€ê²© ë¶€ìŠ¤íŠ¸
                    break;
            }
        }
    }
    
    // ëœë¤ ë³€ë™ì„± ì ìš© (Â±15%)
    const volatility = 0.15;
    const randomFactor = 1 + (Math.random() - 0.5) * 2 * volatility;
    marketPrice *= randomFactor;
    
    return Math.floor(marketPrice);
}

// ì‹œì¥ ì´ë²¤íŠ¸ ì—…ë°ì´íŠ¸
function updateMarketEvent() {
    if (Math.random() < 0.3) { // 30% í™•ë¥ ë¡œ ì´ë²¤íŠ¸ ë°œìƒ
        const randomEvent = ITEM_MARKET.dailyEvents[Math.floor(Math.random() * ITEM_MARKET.dailyEvents.length)];
        currentMarketEvent = {
            ...randomEvent,
            startTime: Date.now(),
            duration: 6 * 60 * 60 * 1000 // 6ì‹œê°„ ì§€ì†
        };
        
        // ì´ë²¤íŠ¸ ì•Œë¦¼ (ì„œë²„ ì „ì²´ì— ê³µì§€)
        AUCTION_HOUSE.events.push({
            type: 'market_event',
            message: `ğŸŒŸ **${currentMarketEvent.name}** ì´ë²¤íŠ¸ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤!`,
            timestamp: Date.now()
        });
    } else {
        currentMarketEvent = null;
    }
}

// ì•„ì´í…œ íƒ€ì… ë¶„ë¥˜
function getItemType(itemName) {
    if (itemName.includes('ì£¼ë¬¸ì„œ')) return 'scrolls';
    if (itemName.includes('í¬ì…˜') || itemName.includes('ë¬¼ì•½') || itemName.includes('ê°€ë£¨') || itemName.includes('ì—˜ë¦­ì„œ')) return 'consumables';
    if (itemName.includes('ì¡°ê°') || itemName.includes('ì½”ì–´') || itemName.includes('ìˆ˜ì•¡') || itemName.includes('ì›ì„')) return 'currency';
    return 'rare';
}

// ê²½ë§¤ì¥ ì•„ì´í…œ ë“±ë¡
function addAuctionListing(seller, item, startPrice, buyNowPrice, duration = 24) {
    const listingId = `auction_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const listing = {
        id: listingId,
        sellerId: seller.discordId,
        sellerName: seller.nickname,
        item: item,
        startPrice: startPrice,
        currentPrice: startPrice,
        buyNowPrice: buyNowPrice,
        highestBidder: null,
        highestBidderName: null,
        bids: [],
        startTime: Date.now(),
        endTime: Date.now() + (duration * 60 * 60 * 1000),
        status: 'active'
    };
    
    AUCTION_HOUSE.listings.set(listingId, listing);
    saveGameData(); // ë°ì´í„° ìë™ ì €ì¥
    return listingId;
}

// ì…ì°° ì²˜ë¦¬
function placeBid(bidder, listingId, bidAmount) {
    const listing = AUCTION_HOUSE.listings.get(listingId);
    if (!listing || listing.status !== 'active') {
        return { success: false, message: 'ê²½ë§¤ê°€ ì¡´ì¬í•˜ì§€ ì•Šê±°ë‚˜ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.' };
    }
    
    if (Date.now() > listing.endTime) {
        return { success: false, message: 'ê²½ë§¤ê°€ ì´ë¯¸ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.' };
    }
    
    if (bidAmount <= listing.currentPrice) {
        return { success: false, message: `í˜„ì¬ ì…ì°°ê°€(${listing.currentPrice.toLocaleString()}G)ë³´ë‹¤ ë†’ê²Œ ì…ì°°í•´ì£¼ì„¸ìš”.` };
    }
    
    if (bidder.discordId === listing.sellerId) {
        return { success: false, message: 'ìì‹ ì´ ë“±ë¡í•œ ê²½ë§¤ì—ëŠ” ì…ì°°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.' };
    }
    
    if (bidder.gold < bidAmount) {
        return { success: false, message: 'ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.' };
    }
    
    // ì´ì „ ìµœê³  ì…ì°°ìì—ê²Œ ê³¨ë“œ ë°˜í™˜
    if (listing.highestBidder) {
        // ì‹¤ì œ êµ¬í˜„ì‹œì—ëŠ” User.findOneìœ¼ë¡œ ì´ì „ ì…ì°°ì ì°¾ì•„ì„œ ê³¨ë“œ ë°˜í™˜
    }
    
    // ìƒˆë¡œìš´ ì…ì°° ì •ë³´ ì—…ë°ì´íŠ¸
    listing.currentPrice = bidAmount;
    listing.highestBidder = bidder.discordId;
    listing.highestBidderName = bidder.nickname;
    listing.bids.push({
        bidderId: bidder.discordId,
        bidderName: bidder.nickname,
        amount: bidAmount,
        timestamp: Date.now()
    });
    
    // ì…ì°°ì ê³¨ë“œ ì°¨ê° (ì„ì‹œ ë³´ê´€)
    bidder.gold -= bidAmount;
    
    saveGameData(); // ë°ì´í„° ìë™ ì €ì¥
    return { success: true, message: 'ì…ì°°ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!' };
}

// ì‹œì„¸ ì¡°íšŒ í•¨ìˆ˜ (ì£¼ì‹ ì°¨íŠ¸ì™€ ìœ ì‚¬)
function getItemPriceChart(itemName) {
    const history = AUCTION_HOUSE.priceHistory.get(itemName) || [];
    if (history.length === 0) {
        return { message: 'í•´ë‹¹ ì•„ì´í…œì˜ ê±°ë˜ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.' };
    }
    
    const latest = history[history.length - 1];
    const previous = history.length > 1 ? history[history.length - 2] : latest;
    const change = ((latest.price - previous.price) / previous.price * 100);
    
    return {
        itemName,
        currentPrice: latest.price,
        change: change,
        volume: latest.volume || 0,
        history: history.slice(-30) // ìµœê·¼ 30ê°œ ê¸°ë¡
    };
}

// ğŸ² ëœë¤ ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ í•¨ìˆ˜ë“¤
// ë‚ ì”¨ ì‹œìŠ¤í…œ ì—…ë°ì´íŠ¸ (6ì‹œê°„ë§ˆë‹¤)
function updateWeather() {
    const weatherList = RANDOM_EVENTS.weatherEffects;
    currentWeather = weatherList[Math.floor(Math.random() * weatherList.length)];
    saveGameData(); // ë°ì´í„° ìë™ ì €ì¥
    return currentWeather;
}

// ì¼ì¼ ìš´ì„¸ ì—…ë°ì´íŠ¸ (24ì‹œê°„ë§ˆë‹¤)
function updateDailyFortune() {
    const fortunes = RANDOM_EVENTS.dailyFortune;
    dailyFortune = fortunes[Math.floor(Math.random() * fortunes.length)];
    return dailyFortune;
}

// ëœë¤ ì¸ì¹´ìš´í„° ì²´í¬
function checkRandomEncounter() {
    for (const encounter of RANDOM_EVENTS.randomEncounters) {
        if (Math.random() * 100 < encounter.rarity) {
            return encounter;
        }
    }
    return null;
}

// ì‹ ë¹„í•œ ìƒì ì—´ê¸°
function openMysteryBox(boxType, user) {
    const box = RANDOM_EVENTS.mysteryBoxes.find(b => b.name === boxType);
    if (!box) return { success: false, message: 'ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ìƒìì…ë‹ˆë‹¤.' };
    
    if (user.gold < box.price) {
        return { success: false, message: 'ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.' };
    }
    
    // ê°€ì¤‘ì¹˜ ê¸°ë°˜ ëœë¤ ì„ íƒ
    const totalWeight = box.rewards.reduce((sum, reward) => sum + reward.weight, 0);
    const random = Math.random() * totalWeight;
    let currentWeight = 0;
    
    for (const reward of box.rewards) {
        currentWeight += reward.weight;
        if (random <= currentWeight) {
            // ê³¨ë“œ ì°¨ê°
            user.gold -= box.price;
            
            // ë³´ìƒ ì§€ê¸‰
            let rewardText = '';
            if (reward.item === 'ê³¨ë“œ' || reward.item === 'ëŒ€ëŸ‰ ê³¨ë“œ') {
                const amount = Array.isArray(reward.amount) ? 
                    Math.floor(Math.random() * (reward.amount[1] - reward.amount[0] + 1)) + reward.amount[0] :
                    reward.amount;
                user.gold += amount;
                rewardText = `${amount.toLocaleString()}G`;
            } else if (reward.item === 'ê²½í—˜ì¹˜') {
                const amount = Array.isArray(reward.amount) ? 
                    Math.floor(Math.random() * (reward.amount[1] - reward.amount[0] + 1)) + reward.amount[0] :
                    reward.amount;
                user.exp += amount;
                rewardText = `${amount.toLocaleString()} EXP`;
            } else if (reward.item === 'ìŠ¤íƒ¯ í¬ì¸íŠ¸') {
                const amount = Array.isArray(reward.amount) ? 
                    Math.floor(Math.random() * (reward.amount[1] - reward.amount[0] + 1)) + reward.amount[0] :
                    reward.amount;
                user.statPoints += amount;
                rewardText = `ìŠ¤íƒ¯ í¬ì¸íŠ¸ ${amount}ê°œ`;
            } else if (reward.item === 'ë³´í˜¸ê¶Œ') {
                const amount = Array.isArray(reward.amount) ? 
                    Math.floor(Math.random() * (reward.amount[1] - reward.amount[0] + 1)) + reward.amount[0] :
                    reward.amount;
                user.protectionScrolls += amount;
                rewardText = `ë³´í˜¸ê¶Œ ${amount}ê°œ`;
            } else {
                rewardText = reward.item;
            }
            
            return { 
                success: true, 
                reward: reward.item,
                rewardText: rewardText,
                message: `ğŸ **${rewardText}**ë¥¼ íšë“í–ˆìŠµë‹ˆë‹¤!`
            };
        }
    }
    
    return { success: false, message: 'ìƒì ì—´ê¸°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.' };
}

// í˜„ì¬ í™œì„± íš¨ê³¼ë“¤ ì ìš©
function getActiveEffects() {
    let effects = {};
    
    // ë‚ ì”¨ íš¨ê³¼
    if (currentWeather) {
        Object.assign(effects, currentWeather.effect);
    }
    
    // ì¼ì¼ ìš´ì„¸ íš¨ê³¼
    if (dailyFortune) {
        Object.assign(effects, dailyFortune.effect);
    }
    
    return effects;
}

// ğŸ“¦ ìƒˆë¡œìš´ ì¸ë²¤í† ë¦¬ ì‹œìŠ¤í…œ í•¨ìˆ˜ë“¤
function getAvailableInventorySlot(user) {
    const usedSlots = user.inventory.map(item => item.inventorySlot).filter(slot => slot !== null && slot !== undefined);
    for (let i = 0; i < user.maxInventorySlots; i++) {
        if (!usedSlots.includes(i)) {
            return i;
        }
    }
    return -1; // ìŠ¬ë¡¯ ë¶€ì¡±
}

// ì¸ë²¤í† ë¦¬ ë°ì´í„° ë¬´ê²°ì„± ê²€ì‚¬ ë° ë³µêµ¬
function validateAndFixInventory(user) {
    let needsFix = false;
    
    // 1. inventorySlot ì¤‘ë³µ ì œê±° ë° ì¬í• ë‹¹
    const slotMap = new Map();
    const itemsToReassign = [];
    
    user.inventory.forEach((item, index) => {
        if (item.inventorySlot === null || item.inventorySlot === undefined) {
            itemsToReassign.push(item);
            needsFix = true;
        } else if (slotMap.has(item.inventorySlot)) {
            // ì¤‘ë³µëœ ìŠ¬ë¡¯ ë°œê²¬
            itemsToReassign.push(item);
            needsFix = true;
        } else {
            slotMap.set(item.inventorySlot, item);
        }
    });
    
    // ì¤‘ë³µë˜ê±°ë‚˜ ì—†ëŠ” ìŠ¬ë¡¯ì„ ê°€ì§„ ì•„ì´í…œë“¤ì— ìƒˆ ìŠ¬ë¡¯ í• ë‹¹
    itemsToReassign.forEach(item => {
        const newSlot = getAvailableInventorySlot(user);
        if (newSlot !== -1) {
            item.inventorySlot = newSlot;
            console.log(`[ì¸ë²¤í† ë¦¬ ë³µêµ¬] ${item.name}ì— ìƒˆ ìŠ¬ë¡¯ ${newSlot} í• ë‹¹`);
        }
    });
    
    // 2. equipment ìŠ¬ë¡¯ ê²€ì¦
    const equipmentSlots = ['weapon', 'armor', 'helmet', 'gloves', 'boots', 'accessory'];
    equipmentSlots.forEach(slot => {
        const slotIndex = user.equipment[slot];
        
        if (slotIndex !== -1 && slotIndex !== null && slotIndex !== undefined) {
            const item = user.inventory.find(i => i.inventorySlot === slotIndex);
            
            if (!item) {
                // ì¥ì°©ëœ ìŠ¬ë¡¯ì— ì•„ì´í…œì´ ì—†ìŒ
                console.log(`[ì¥ë¹„ ë³µêµ¬] ${user.nickname}ì˜ ${slot} ìŠ¬ë¡¯ ì´ˆê¸°í™”: ${slotIndex} -> -1`);
                user.equipment[slot] = -1;
                needsFix = true;
            } else if (item.type !== slot) {
                // ì˜ëª»ëœ íƒ€ì…ì˜ ì•„ì´í…œì´ ì¥ì°©ë¨
                console.log(`[ì¥ë¹„ ë³µêµ¬] ${user.nickname}ì˜ ${slot} ìŠ¬ë¡¯ì— ì˜ëª»ëœ íƒ€ì…: ${item.type}`);
                user.equipment[slot] = -1;
                item.equipped = false;
                needsFix = true;
            } else if (!item.equipped) {
                // equipped ìƒíƒœ ë™ê¸°í™”
                item.equipped = true;
                needsFix = true;
            }
        }
    });
    
    // 3. equipped ìƒíƒœì™€ equipment ìŠ¬ë¡¯ ë™ê¸°í™”
    user.inventory.forEach(item => {
        if (item.equipped) {
            const slot = item.type;
            if (equipmentSlots.includes(slot)) {
                if (user.equipment[slot] !== item.inventorySlot) {
                    console.log(`[ì¥ë¹„ ë™ê¸°í™”] ${item.name}ì˜ ì¥ì°© ìƒíƒœ ë™ê¸°í™”`);
                    user.equipment[slot] = item.inventorySlot;
                    needsFix = true;
                }
            } else {
                // ì¥ì°© ë¶ˆê°€ëŠ¥í•œ ì•„ì´í…œì´ equipped ìƒíƒœ
                item.equipped = false;
                needsFix = true;
            }
        }
    });
    
    return needsFix;
}

function addItemToInventory(user, itemData) {
    const slot = getAvailableInventorySlot(user);
    if (slot === -1) {
        return { success: false, message: 'ì¸ë²¤í† ë¦¬ê°€ ê°€ë“ ì°¼ìŠµë‹ˆë‹¤!' };
    }
    
    const newItem = {
        ...itemData,
        inventorySlot: slot,
        equipped: false
    };
    
    user.inventory.push(newItem);
    return { success: true, slot: slot };
}

function equipItem(user, inventorySlot, equipmentType) {
    // inventorySlotì„ ìˆ«ìë¡œ ë³€í™˜
    const slotNumber = typeof inventorySlot === 'string' ? parseInt(inventorySlot) : inventorySlot;
    
    const item = user.inventory.find(item => item.inventorySlot === slotNumber);
    if (!item) {
        console.log(`[ì¥ë¹„ ì˜¤ë¥˜] inventorySlot ${slotNumber}ì— ì•„ì´í…œì„ ì°¾ì„ ìˆ˜ ì—†ìŒ`);
        return { success: false, message: 'ì•„ì´í…œì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!' };
    }
    
    // ì•„ì´í…œ íƒ€ì… í™•ì¸
    if (item.type !== equipmentType) {
        return { success: false, message: `ì´ ì•„ì´í…œì€ ${equipmentType} ìŠ¬ë¡¯ì— ì¥ì°©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤!` };
    }
    
    // ë ˆë²¨ ì²´í¬
    if (user.level < item.level) {
        return { success: false, message: `ë ˆë²¨ì´ ë¶€ì¡±í•©ë‹ˆë‹¤! (í•„ìš”: Lv.${item.level})` };
    }
    
    // ì´ì „ ì¥ë¹„ í•´ì œ
    const previousSlot = user.equipment[equipmentType];
    if (previousSlot !== -1 && previousSlot !== null && previousSlot !== undefined) {
        const previousItem = user.inventory.find(item => item.inventorySlot === previousSlot);
        if (previousItem) {
            previousItem.equipped = false;
        }
    }
    
    // ìƒˆ ì¥ë¹„ ì¥ì°©
    user.equipment[equipmentType] = slotNumber;
    item.equipped = true;
    
    console.log(`[ì¥ë¹„ ì¥ì°©] ${user.nickname}ê°€ ${item.name}ì„(ë¥¼) ${equipmentType} ìŠ¬ë¡¯ì— ì¥ì°©`);
    
    return { success: true, message: 'ì¥ë¹„ë¥¼ ì°©ìš©í–ˆìŠµë‹ˆë‹¤!' };
}

function unequipItem(user, equipmentType) {
    const slotIndex = user.equipment[equipmentType];
    if (slotIndex === -1 || slotIndex === null || slotIndex === undefined) {
        return { success: false, message: 'ì°©ìš©ëœ ì¥ë¹„ê°€ ì—†ìŠµë‹ˆë‹¤!' };
    }
    
    const item = user.inventory.find(item => item.inventorySlot === slotIndex);
    if (item) {
        item.equipped = false;
        console.log(`[ì¥ë¹„ í•´ì œ] ${user.nickname}ê°€ ${item.name}ì„(ë¥¼) í•´ì œ`);
    } else {
        console.log(`[ì¥ë¹„ ì˜¤ë¥˜] ${user.nickname}ì˜ ${equipmentType} ìŠ¬ë¡¯ ${slotIndex}ì— ì•„ì´í…œì´ ì—†ìŒ`);
    }
    
    user.equipment[equipmentType] = -1;
    return { success: true, message: 'ì¥ë¹„ë¥¼ í•´ì œí–ˆìŠµë‹ˆë‹¤!' };
}

function sellEquippedItem(user, equipmentType) {
    const item = getEquippedItem(user, equipmentType);
    if (!item) return { success: false, message: 'ì°©ìš©ëœ ì¥ë¹„ê°€ ì—†ìŠµë‹ˆë‹¤!' };
    
    // íŒë§¤ê°€ê²© ê³„ì‚°: ê¸°ë³¸ê°€ê²© 70% Ã— ê°•í™”ë ˆë²¨
    const basePrice = Math.floor(item.price * 0.7);
    const enhanceMultiplier = item.enhanceLevel > 0 ? (1 + item.enhanceLevel * 0.1) : 1;
    const sellPrice = Math.floor(basePrice * enhanceMultiplier);
    
    // ì¥ë¹„ í•´ì œ ë° ì¸ë²¤í† ë¦¬ì—ì„œ ì œê±°
    user.equipment[equipmentType] = -1;
    user.inventory = user.inventory.filter(invItem => invItem.inventorySlot !== item.inventorySlot);
    user.gold += sellPrice;
    
    return { success: true, sellPrice: sellPrice, itemName: item.name };
}

// ì— ë¸”ëŸ¼ ì‹œìŠ¤í…œ ë°ì´í„°
const EMBLEMS = {
    warrior: {
        name: 'ì „ì‚¬',
        emoji: 'âš”ï¸',
        emblems: [
            { name: 'ì´ˆë³´ì „ì‚¬', price: 10000, level: 20, roleName: 'ì´ˆë³´ì „ì‚¬' },
            { name: 'íŠ¼íŠ¼í•œ ê¸°ì‚¬', price: 50000, level: 35, roleName: 'íŠ¼íŠ¼í•œ ê¸°ì‚¬' },
            { name: 'ìš©ë§¹í•œ ê²€ì‚¬', price: 150000, level: 50, roleName: 'ìš©ë§¹í•œ ê²€ì‚¬' },
            { name: 'ë§¹ë ¹í•œ ì „ì‚¬', price: 400000, level: 65, roleName: 'ë§¹ë ¹í•œ ì „ì‚¬' },
            { name: 'ì „ì„¤ì˜ ê¸°ì‚¬', price: 1000000, level: 80, roleName: 'ì „ì„¤ì˜ ê¸°ì‚¬' }
        ]
    },
    archer: {
        name: 'ê¶ìˆ˜',
        emoji: 'ğŸ¹',
        emblems: [
            { name: 'ë§ˆì„ì‚¬ëƒ¥ê¾¼', price: 10000, level: 20, roleName: 'ë§ˆì„ì‚¬ëƒ¥ê¾¼' },
            { name: 'ìˆ²ì˜ ê¶ìˆ˜', price: 50000, level: 35, roleName: 'ìˆ²ì˜ ê¶ìˆ˜' },
            { name: 'ë°”ëŒ ì‚¬ìˆ˜', price: 150000, level: 50, roleName: 'ë°”ëŒ ì‚¬ìˆ˜' },
            { name: 'ì •í™•í•œ ì‚¬ê²©ìˆ˜', price: 400000, level: 65, roleName: 'ì •í™•í•œ ì‚¬ê²©ìˆ˜' },
            { name: 'ì „ì„¤ì˜ ëª…ê¶', price: 1000000, level: 80, roleName: 'ì „ì„¤ì˜ ëª…ê¶' }
        ]
    },
    spellsword: {
        name: 'ë§ˆê²€ì‚¬',
        emoji: 'ğŸ”®',
        emblems: [
            { name: 'ë§ˆë²• í•™ë„', price: 10000, level: 20, roleName: 'ë§ˆë²• í•™ë„' },
            { name: 'ë§ˆë²• ê²€ì‚¬', price: 50000, level: 35, roleName: 'ë§ˆë²• ê²€ì‚¬' },
            { name: 'í˜„ëª…í•œ ê¸°ì‚¬', price: 150000, level: 50, roleName: 'í˜„ëª…í•œ ê¸°ì‚¬' },
            { name: 'ë§ˆë„ ê²€ì‚¬', price: 400000, level: 65, roleName: 'ë§ˆë„ ê²€ì‚¬' },
            { name: 'ì „ì„¤ì˜ ë§ˆê²€ì‚¬', price: 1000000, level: 80, roleName: 'ì „ì„¤ì˜ ë§ˆê²€ì‚¬' }
        ]
    },
    rogue: {
        name: 'ë„ì ',
        emoji: 'ğŸ—¡ï¸',
        emblems: [
            { name: 'ë– ëŒì´ ë„ì ', price: 10000, level: 20, roleName: 'ë– ëŒì´ ë„ì ' },
            { name: 'ìš´ ì¢‹ì€ ë„ë‘‘', price: 50000, level: 35, roleName: 'ìš´ ì¢‹ì€ ë„ë‘‘' },
            { name: 'í–‰ìš´ì˜ ë‹Œì', price: 150000, level: 50, roleName: 'í–‰ìš´ì˜ ë‹Œì' },
            { name: 'ë³µ ë§ì€ ë„ì ', price: 400000, level: 65, roleName: 'ë³µ ë§ì€ ë„ì ' },
            { name: 'ì „ì„¤ì˜ í–‰ìš´ì•„', price: 1000000, level: 80, roleName: 'ì „ì„¤ì˜ í–‰ìš´ì•„' }
        ]
    }
};

// ì— ë¸”ëŸ¼ ì±„ë„ ID
const EMBLEM_CHANNEL_ID = '1381614153399140412';

// ìœ ì € ì¹­í˜¸ ê°€ì ¸ì˜¤ê¸° í•¨ìˆ˜
function getUserTitle(user) {
    if (user.emblem) {
        return user.emblem; // ì— ë¸”ëŸ¼ì´ ìˆìœ¼ë©´ ì— ë¸”ëŸ¼ì„ ì¹­í˜¸ë¡œ ì‚¬ìš©
    }
    return 'ëª¨í—˜ê°€'; // ì— ë¸”ëŸ¼ì´ ì—†ìœ¼ë©´ ê¸°ë³¸ ì¹­í˜¸
}

// ì¥ë¹„ ì¹´í…Œê³ ë¦¬ ì´ë¦„ ê°€ì ¸ì˜¤ê¸° í•¨ìˆ˜
function getCategoryName(category) {
    const names = {
        weapon: 'ë¬´ê¸°',
        armor: 'ê°‘ì˜·',
        helmet: 'í—¬ë©§',
        gloves: 'ì¥ê°‘',
        boots: 'ë¶€ì¸ ',
        accessory: 'ì•¡ì„¸ì„œë¦¬'
    };
    return names[category] || category;
}

// ì¥ë¹„ ì¹´í…Œê³ ë¦¬ ì´ëª¨ì§€ ê°€ì ¸ì˜¤ê¸° í•¨ìˆ˜
function getCategoryEmoji(category) {
    const emojis = {
        weapon: 'âš”ï¸',
        armor: 'ğŸ›¡ï¸',
        helmet: 'â›‘ï¸',
        gloves: 'ğŸ§¤',
        boots: 'ğŸ‘¢',
        accessory: 'ğŸ’'
    };
    return emojis[category] || 'âš™ï¸';
}

// ë´‡ ì„¤ì •
const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent,
        GatewayIntentBits.GuildMessageReactions
    ]
});

// ë´‡ í† í° (í™˜ê²½ë³€ìˆ˜ì—ì„œ ê°€ì ¸ì˜¤ê±°ë‚˜ ì§ì ‘ ì…ë ¥)
const TOKEN = process.env.BOT_TOKEN || 'YOUR_BOT_TOKEN_HERE';
const CLIENT_ID = process.env.CLIENT_ID || 'YOUR_CLIENT_ID_HERE';
const DEV_CHANNEL_IDS = ['1380684353998426122', '1371885860143890564', '1381614153399140412'];
const GAME_CHANNEL_ID = process.env.GAME_CHANNEL_ID;
const DEV_MODE = process.env.DEV_MODE === 'true';
const DEVELOPER_ID = process.env.DEVELOPER_ID;
const POPULAR_KING_ROLE_NAME = 'ğŸ‘‘ ì¸ê¸°ì™•';

// í´ë¡œì¦ˆë² íƒ€ ì„¤ì •
const BETA_MODE = process.env.BETA_MODE === 'true';
const BETA_CHANNEL_IDS = process.env.BETA_CHANNEL_IDS ? process.env.BETA_CHANNEL_IDS.split(',').map(id => id.trim()) : [];
const BETA_USER_IDS = process.env.BETA_USER_IDS ? process.env.BETA_USER_IDS.split(',').map(id => id.trim()) : [];

// ë² íƒ€ í…ŒìŠ¤í„° í™•ì¸ í•¨ìˆ˜
function isBetaTester(userId) {
    return BETA_USER_IDS.includes(userId) || isAdmin(userId);
}

// ë² íƒ€ ì±„ë„ í™•ì¸ í•¨ìˆ˜
function isBetaChannel(channelId) {
    return BETA_CHANNEL_IDS.includes(channelId) || DEV_CHANNEL_IDS.includes(channelId);
}

// ê°œë°œì ì²´í¬ í•¨ìˆ˜
function isDeveloper(userId) {
    return DEVELOPER_ID && userId === DEVELOPER_ID;
}

// ê²½í—˜ì¹˜ ë°” ìƒì„± í•¨ìˆ˜
function generateExpBar(currentExp, maxExp, barLength = 20) {
    const percentage = Math.min(currentExp / maxExp, 1);
    const filledLength = Math.floor(percentage * barLength);
    const emptyLength = barLength - filledLength;
    
    const filledChar = 'â–ˆ';
    const emptyChar = 'â–‘';
    
    const bar = 'â–ˆ'.repeat(filledLength) + 'â–‘'.repeat(emptyLength);
    const percentText = (percentage * 100).toFixed(1);
    
    return `â”” \`${bar}\` ${percentText}%`;
}

// ëœë¤ ì•„ì´í…œ ëŠ¥ë ¥ì¹˜ ìƒì„± í•¨ìˆ˜
function generateRandomStats(statRanges) {
    const randomStats = {};
    for (const [statName, range] of Object.entries(statRanges)) {
        if (range[0] === range[1]) {
            // ê³ ì •ê°’ì¸ ê²½ìš°
            randomStats[statName] = range[0];
        } else {
            // ë²”ìœ„ì—ì„œ ëœë¤ ìƒì„±
            randomStats[statName] = Math.floor(Math.random() * (range[1] - range[0] + 1)) + range[0];
        }
    }
    return randomStats;
}

// ëœë¤ ì¶”ê°€ ì˜µì…˜ ìƒì„± í•¨ìˆ˜
function generateRandomOptions(rarity) {
    const options = [];
    const optionChances = {
        'ì¼ë°˜': { chance: 20, maxOptions: 1 },
        'ê³ ê¸‰': { chance: 40, maxOptions: 2 },
        'í¬ê·€': { chance: 60, maxOptions: 2 },
        'ì˜ì›…': { chance: 80, maxOptions: 3 },
        'ì „ì„¤': { chance: 100, maxOptions: 3 }
    };
    
    const optionPool = [
        { name: 'ì¶”ê°€ ê³µê²©ë ¥', type: 'attack', value: [1, 5] },
        { name: 'ì¶”ê°€ ë°©ì–´ë ¥', type: 'defense', value: [1, 5] },
        { name: 'ì¶”ê°€ íšŒí”¼ìœ¨', type: 'dodge', value: [1, 3] },
        { name: 'ì¶”ê°€ í–‰ìš´', type: 'luck', value: [1, 3] },
        { name: 'ê³¨ë“œ íšë“ëŸ‰', type: 'goldBonus', value: [5, 15] },
        { name: 'ê²½í—˜ì¹˜ íšë“ëŸ‰', type: 'expBonus', value: [5, 15] },
        { name: 'ì²´ë ¥ íšŒë³µ', type: 'hpRegen', value: [1, 3] },
        { name: 'ì¹˜ëª…íƒ€ í™•ë¥ ', type: 'critChance', value: [1, 5] },
        { name: 'ì¹˜ëª…íƒ€ í”¼í•´', type: 'critDamage', value: [10, 30] }
    ];
    
    const rarityConfig = optionChances[rarity] || optionChances['ì¼ë°˜'];
    
    // ì¶”ê°€ ì˜µì…˜ì´ ë¶™ì„ì§€ í™•ë¥  ê³„ì‚°
    if (Math.random() * 100 > rarityConfig.chance) {
        return options;
    }
    
    // ì˜µì…˜ ê°œìˆ˜ ê²°ì •
    const numOptions = Math.floor(Math.random() * rarityConfig.maxOptions) + 1;
    const selectedOptions = new Set();
    
    for (let i = 0; i < numOptions && i < optionPool.length; i++) {
        let option;
        do {
            option = optionPool[Math.floor(Math.random() * optionPool.length)];
        } while (selectedOptions.has(option.type));
        
        selectedOptions.add(option.type);
        
        const value = Math.floor(Math.random() * (option.value[1] - option.value[0] + 1)) + option.value[0];
        options.push({
            name: option.name,
            type: option.type,
            value: value,
            displayValue: option.type.includes('Bonus') || option.type.includes('Damage') ? `+${value}%` : `+${value}`
        });
    }
    
    return options;
}

// ê°•í™” í™•ë¥ í‘œ (0-30ê°•)
const ENHANCEMENT_RATES = {
    0: { success: 95, fail: 5, destroy: 0 },
    1: { success: 90, fail: 10, destroy: 0 },
    2: { success: 85, fail: 15, destroy: 0 },
    3: { success: 85, fail: 15, destroy: 0 },
    4: { success: 80, fail: 20, destroy: 0 },
    5: { success: 75, fail: 25, destroy: 0 },
    6: { success: 70, fail: 30, destroy: 0 },
    7: { success: 65, fail: 35, destroy: 0 },
    8: { success: 60, fail: 40, destroy: 0 },
    9: { success: 55, fail: 45, destroy: 0 },
    10: { success: 50, fail: 50, destroy: 0 },
    11: { success: 45, fail: 55, destroy: 0 },
    12: { success: 40, fail: 60, destroy: 0 },
    13: { success: 35, fail: 65, destroy: 0 },
    14: { success: 30, fail: 70, destroy: 0 },
    15: { success: 30, fail: 67.9, destroy: 2.1 },
    16: { success: 30, fail: 67.9, destroy: 2.1 },
    17: { success: 15, fail: 78.2, destroy: 6.8 },
    18: { success: 15, fail: 78.2, destroy: 6.8 },
    19: { success: 15, fail: 76.5, destroy: 8.5 },
    20: { success: 30, fail: 59.5, destroy: 10.5 },
    21: { success: 15, fail: 72.25, destroy: 12.75 },
    22: { success: 15, fail: 68, destroy: 17 },
    23: { success: 10, fail: 72, destroy: 18 },
    24: { success: 10, fail: 72, destroy: 18 },
    25: { success: 10, fail: 72, destroy: 18 },
    26: { success: 7, fail: 74.4, destroy: 18.6 },
    27: { success: 5, fail: 76, destroy: 19 },
    28: { success: 3, fail: 77.6, destroy: 19.4 },
    29: { success: 1, fail: 79.2, destroy: 19.8 },
    30: { success: 0, fail: 0, destroy: 0 } // 30ê°•ì€ ìµœëŒ€
};

// ë©”ì´í”ŒìŠ¤í† ë¦¬ ì •í™•í•œ ê°•í™” ë¹„ìš© ê³„ìˆ˜í‘œ
const COST_COEFFICIENTS = {
    0: 36, 1: 36, 2: 36, 3: 36, 4: 36, 5: 36, 6: 36, 7: 36, 8: 36, 9: 36, 10: 36,
    11: 571, 12: 314, 13: 157, 14: 107, 15: 200, 16: 200, 17: 150, 18: 70, 19: 45,
    20: 200, 21: 125, 22: 200, 23: 200, 24: 200, 25: 200, 26: 200, 27: 200, 28: 200, 29: 200
};

// ì•„ì´í…œ ë ˆë²¨ë³„ ì„¤ì • (ëª¨ë“  ìƒì  ì•„ì´í…œ í¬í•¨)
const ITEM_LEVELS = {
    'ê¸°ë³¸ ê²€': 1,
    'ê¸°ë³¸ ê°‘ì˜·': 1,
    'ì²´ë ¥ í¬ì…˜': 1,
    'ë§ˆë‚˜ í¬ì…˜': 1,
    'ê°•ì²  ê²€': 10,
    'ê½ƒì ì„¸íŠ¸': 1,
    'ë³„ë¹› ì„¸íŠ¸': 20,
    'ë“œë˜ê³¤ ì„¸íŠ¸': 40,
    'ì‹œê³µ ì„¸íŠ¸': 60,
    'ê°•í™”ì™• ì„¸íŠ¸': 80
};

// ê°•í™” ë¹„ìš© ê³„ì‚° í•¨ìˆ˜ (Discord ë´‡ì— ë§ê²Œ ì¡°ì •ëœ ê³¨ë“œ ê²½ì œ)
function calculateEnhanceCost(itemLevel, currentStar) {
    if (currentStar >= 30) return 0; // 30ê°•ì€ ìµœëŒ€
    
    const L = itemLevel;
    const S = currentStar;
    const coefficient = COST_COEFFICIENTS[S] || 200;
    
    // ê¸°ë³¸ ê³µì‹: 100 + L Ã— 3^(S+1) Ã— ê³„ìˆ˜
    // Discord ë´‡ ê²½ì œì— ë§ê²Œ 1/10000 ìŠ¤ì¼€ì¼ë¡œ ì¡°ì •
    const baseCost = 100 + L * Math.pow(3, S + 1) * coefficient;
    const adjustedCost = Math.floor(baseCost / 10000);
    
    // ìµœì†Œ ë¹„ìš© ë³´ì¥ ë° ì‹­ì˜ ìë¦¬ ë°˜ì˜¬ë¦¼
    const finalCost = Math.max(100, adjustedCost);
    return Math.round(finalCost / 10) * 10;
}

// ê°•í™” ì„±ê³µë¥  ê³„ì‚° í•¨ìˆ˜
function calculateSuccessRate(currentStar) {
    // ENHANCEMENT_RATES í…Œì´ë¸”ì—ì„œ í™•ë¥  ê°€ì ¸ì˜¤ê¸°
    if (ENHANCEMENT_RATES[currentStar]) {
        return ENHANCEMENT_RATES[currentStar].success / 100; // ë°±ë¶„ìœ¨ì„ ì†Œìˆ˜ë¡œ ë³€í™˜
    }
    return 0.01; // ê¸°ë³¸ê°’
}

// ê°•í™” ìŠ¤íƒ¯ ë³´ë„ˆìŠ¤ ê³„ì‚° í•¨ìˆ˜
function calculateEnhancementBonus(itemLevel, enhanceLevel) {
    if (enhanceLevel <= 0) return { attack: 0, defense: 0 };
    
    // ê°•í™” ê³µì‹: ë ˆë²¨/20 + ê°•í™”ë‹¹ ê³ ì • ë³´ë„ˆìŠ¤
    const baseBonus = Math.floor(itemLevel / 20) + 1;
    
    let attack = 0;
    let defense = 0;
    
    // 1-5ê°•: ê¸°ë³¸ ë³´ë„ˆìŠ¤
    for (let i = 1; i <= Math.min(enhanceLevel, 5); i++) {
        attack += baseBonus;
        defense += baseBonus;
    }
    
    // 6-10ê°•: ë³´ë„ˆìŠ¤ ì¦ê°€
    for (let i = 6; i <= Math.min(enhanceLevel, 10); i++) {
        attack += baseBonus + 1;
        defense += baseBonus + 1;
    }
    
    // 11-15ê°•: ë” í° ë³´ë„ˆìŠ¤
    for (let i = 11; i <= Math.min(enhanceLevel, 15); i++) {
        attack += baseBonus + 2;
        defense += baseBonus + 2;
    }
    
    // 16-25ê°•: ìµœê³  ë³´ë„ˆìŠ¤
    for (let i = 16; i <= Math.min(enhanceLevel, 25); i++) {
        attack += baseBonus + 3;
        defense += baseBonus + 3;
    }
    
    // 26-30ê°•: ê·¹í•œ ë³´ë„ˆìŠ¤
    for (let i = 26; i <= Math.min(enhanceLevel, 30); i++) {
        attack += baseBonus + 5;
        defense += baseBonus + 5;
    }
    
    return { attack, defense };
}

// ì§‘ì¤‘ë ¥ í™•ë¥  ì¡°ì • í•¨ìˆ˜
function applyFocus(rates) {
    const newSuccess = Math.min(100, rates.success * 1.05);
    const remaining = 100 - newSuccess;
    const failRatio = rates.fail / (rates.fail + rates.destroy);
    
    return {
        success: newSuccess,
        fail: remaining * failRatio,
        destroy: remaining * (1 - failRatio)
    };
}

// ì¶•ë³µë°›ì€ë‚  í™•ë¥  ì¡°ì • í•¨ìˆ˜ (15~22ê°•ë§Œ)
function applyBlessedDay(rates, enhanceLevel) {
    if (enhanceLevel < 15 || enhanceLevel > 22) return rates;
    
    const newDestroy = rates.destroy * 0.7;
    const newFail = rates.fail + (rates.destroy - newDestroy);
    
    return {
        success: rates.success,
        fail: newFail,
        destroy: newDestroy
    };
}

// ê°•í™” ì‹œë„ í•¨ìˆ˜
function attemptEnhance(rates, isFocusMode = false, isBlessedDay = false, enhanceLevel = 0) {
    let finalRates = { ...rates };
    
    if (isFocusMode) {
        finalRates = applyFocus(finalRates);
    }
    
    if (isBlessedDay) {
        finalRates = applyBlessedDay(finalRates, enhanceLevel);
    }
    
    const random = Math.random() * 100;
    
    if (random <= finalRates.success) {
        return 'success';
    } else if (random <= finalRates.success + finalRates.fail) {
        return 'fail';
    } else {
        return 'destroy';
    }
}

// ë³´í˜¸ê¶Œì„ ì‚¬ìš©í•œ ê°•í™” ì‹œë„ í•¨ìˆ˜
function attemptEnhanceWithProtection(rates, isFocusMode = false, isBlessedDay = false, enhanceLevel = 0, useProtection = false) {
    const baseResult = attemptEnhance(rates, isFocusMode, isBlessedDay, enhanceLevel);
    
    // ë³´í˜¸ê¶Œ ì‚¬ìš© ì‹œ íŒŒê´´ ê²°ê³¼ë¥¼ ì‹¤íŒ¨ë¡œ ë³€ê²½
    if (useProtection && baseResult === 'destroy') {
        return 'fail';
    }
    
    return baseResult;
}

// ìµœê³  ê°•í™” ì¥ë¹„ ì°¾ê¸° í•¨ìˆ˜
async function getTopEnhancedUser() {
    try {
        const users = await User.find({ registered: true });
        let topUser = null;
        let maxEnhance = -1;
        let topItem = null;

        for (const user of users) {
            // ì°©ìš© ì¥ë¹„ í™•ì¸
            for (const [slot, equipment] of Object.entries(user.equipment)) {
                if (equipment && equipment.enhanceLevel > maxEnhance) {
                    maxEnhance = equipment.enhanceLevel;
                    topUser = user;
                    topItem = equipment;
                }
            }
        }

        return { user: topUser, item: topItem, enhanceLevel: maxEnhance };
    } catch (error) {
        console.error('ìµœê³  ê°•í™” ìœ ì € ì¡°íšŒ ì˜¤ë¥˜:', error);
        return null;
    }
}

// ê°•í™”ì™• ì—­í•  ì—…ë°ì´íŠ¸ í•¨ìˆ˜
async function updateEnhanceKingRole(guild) {
    try {
        const ENHANCE_KING_ROLE_NAME = 'ê°•í™”ì™•';
        
        // ê°•í™”ì™• ì—­í•  ì°¾ê¸° ë˜ëŠ” ìƒì„±
        let enhanceKingRole = guild.roles.cache.find(role => role.name === ENHANCE_KING_ROLE_NAME);
        
        if (!enhanceKingRole) {
            enhanceKingRole = await guild.roles.create({
                name: ENHANCE_KING_ROLE_NAME,
                color: '#FF6B00', // ì£¼í™©ìƒ‰
                hoist: true,
                reason: 'ê°•í™”ì™• ì‹œìŠ¤í…œ ìë™ ìƒì„±'
            });
        }
        
        // í˜„ì¬ ê°•í™”ì™• ì°¾ê¸°
        const currentKing = guild.members.cache.find(member => 
            member.roles.cache.has(enhanceKingRole.id)
        );
        
        // ìµœê³  ê°•í™” ìœ ì € ì°¾ê¸°
        const topData = await getTopEnhancedUser();
        
        if (!topData || !topData.user) return;
        
        const newKing = guild.members.cache.get(topData.user.discordId);
        
        if (!newKing) return;
        
        // í˜„ì¬ ì™•ì´ ìƒˆë¡œìš´ ì™•ê³¼ ë‹¤ë¥´ë©´ ì—­í•  ë³€ê²½
        if (!currentKing || currentKing.id !== newKing.id) {
            // ê¸°ì¡´ ì™•ì—ì„œ ì—­í•  ì œê±°
            if (currentKing) {
                await currentKing.roles.remove(enhanceKingRole);
            }
            
            // ìƒˆë¡œìš´ ì™•ì—ê²Œ ì—­í•  ë¶€ì—¬
            await newKing.roles.add(enhanceKingRole);
        }
        
    } catch (error) {
        console.error('ê°•í™”ì™• ì—­í•  ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:', error);
    }
}

// í†µí•© ì „íˆ¬ë ¥ ê³„ì‚° í•¨ìˆ˜
function calculateCombatPower(user) {
    let basePower = 0;
    
    // 1. ê¸°ë³¸ ìŠ¤íƒ¯ ì „íˆ¬ë ¥
    basePower = user.stats.strength * 2 + 
                user.stats.agility * 1.5 + 
                user.stats.intelligence * 1.5 + 
                user.stats.vitality * 2 + 
                user.stats.luck * 1;
    
    // 2. ì— ë¸”ëŸ¼ ë³´ë„ˆìŠ¤
    if (user.emblem) {
        const emblemLevel = getEmblemLevel(user.emblem);
        const emblemBonus = emblemLevel * 50; // ì— ë¸”ëŸ¼ ë‹¨ê³„ë‹¹ 50 ì „íˆ¬ë ¥
        basePower += emblemBonus;
    }
    
    // 3. ì¥ë¹„ ì „íˆ¬ë ¥
    let equipmentPower = 0;
    const equipmentSlots = ['weapon', 'armor', 'helmet', 'gloves', 'boots', 'accessory'];
    
    equipmentSlots.forEach(slot => {
        const item = getEquippedItem(user, slot);
        if (item) {
            // ì¥ë¹„ ê¸°ë³¸ ìŠ¤íƒ¯
            if (item.stats) {
                const attack = Array.isArray(item.stats.attack) ? 
                    (item.stats.attack[0] + item.stats.attack[1]) / 2 : 
                    (item.stats.attack || 0);
                const defense = Array.isArray(item.stats.defense) ? 
                    (item.stats.defense[0] + item.stats.defense[1]) / 2 : 
                    (item.stats.defense || 0);
                const dodge = item.stats.dodge || 0;
                const luck = item.stats.luck || 0;
                
                equipmentPower += attack + defense + dodge + luck;
            }
            
            // ê°•í™” ë³´ë„ˆìŠ¤
            if (item.enhanceLevel > 0) {
                equipmentPower += item.enhanceLevel * 10; // ê°•í™”ë‹¹ 10 ì „íˆ¬ë ¥
            }
        }
    });
    
    // 4. PVP ê°•í™” ì „íˆ¬ë ¥
    let pvpPower = 0;
    if (user.pvp?.attackEnhancement) {
        pvpPower = (user.pvp.attackEnhancement.high || 0) * 5 +
                   (user.pvp.attackEnhancement.middle || 0) * 5 +
                   (user.pvp.attackEnhancement.low || 0) * 5;
    }
    
    // 5. ì—ë„ˆì§€ ì¡°ê° ì „íˆ¬ë ¥
    let fragmentPower = 0;
    if (user.energyFragments?.highestLevel) {
        fragmentPower = calculateCombatPowerFromFragment(user.energyFragments.highestLevel);
    }
    
    // 6. ë ˆë²¨ ë³´ë„ˆìŠ¤
    const levelBonus = user.level * 10;
    
    // 7. ìš´ë™ ì‹œìŠ¤í…œ ë³´ë„ˆìŠ¤
    let fitnessPower = 0;
    if (user.fitness?.stats) {
        fitnessPower = (user.fitness.stats.strength || 0) * 2 +
                       (user.fitness.stats.stamina || 0) * 2 +
                       (user.fitness.stats.flexibility || 0) * 1 +
                       (user.fitness.stats.agility || 0) * 1 +
                       (user.fitness.stats.mental || 0) * 1;
    }
    
    // ì´ ì „íˆ¬ë ¥ ê³„ì‚°
    const totalPower = Math.floor(
        basePower + 
        equipmentPower + 
        pvpPower + 
        fragmentPower + 
        levelBonus + 
        fitnessPower
    );
    
    return totalPower;
}

// ì— ë¸”ëŸ¼ ë‹¨ê³„ í™•ì¸ í•¨ìˆ˜
function getEmblemLevel(emblemName) {
    for (const [categoryKey, categoryData] of Object.entries(EMBLEMS)) {
        const emblemIndex = categoryData.emblems.findIndex(emblem => emblem.name === emblemName);
        if (emblemIndex !== -1) {
            return emblemIndex + 1; // 1ë‹¨ê³„ë¶€í„° ì‹œì‘
        }
    }
    return 1; // ê¸°ë³¸ê°’
}

// ì— ë¸”ëŸ¼ ê³„ì—´ í™•ì¸ í•¨ìˆ˜
function getEmblemType(emblemName) {
    for (const [categoryKey, categoryData] of Object.entries(EMBLEMS)) {
        const hasEmblem = categoryData.emblems.some(emblem => emblem.name === emblemName);
        if (hasEmblem) {
            return categoryKey;
        }
    }
    return null;
}

// ëª¬ìŠ¤í„° ì „íˆ¬ë ¥ ê³„ì‚° í•¨ìˆ˜
function calculateMonsterPower(monster, level) {
    return Math.floor(monster.stats.atk + monster.stats.def + (level * 3));
}

// í”¼ë¡œë„ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
function updateFatigue(user) {
    if (!user.fitness) return;
    
    const now = Date.now();
    const lastExercise = user.fitness.lastExercise || now;
    const timeDiff = now - lastExercise;
    const hoursRested = timeDiff / (1000 * 60 * 60);
    
    // ì‹œê°„ë‹¹ í”¼ë¡œë„ íšŒë³µ
    const recovery = Math.floor(hoursRested * EXERCISE_SYSTEM.fatigue.recoveryRate);
    user.fitness.fatigue = Math.max(0, user.fitness.fatigue - recovery);
}

// ì˜¤ëŠ˜ ìš´ë™ ì‹œê°„ ê³„ì‚° í•¨ìˆ˜
function getTodayExerciseTime(user) {
    if (!user.fitness || !user.fitness.exerciseHistory) return 0;
    
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    return user.fitness.exerciseHistory
        .filter(record => new Date(record.date) >= today)
        .reduce((total, record) => total + record.duration, 0);
}

// ìœ ì € ì´ˆê¸°í™”/ì¡°íšŒ í•¨ìˆ˜
async function getUser(discordId) {
    try {
        let user = await User.findOne({ discordId });
        if (!user) {
            user = new User({ discordId });
            await user.save();
            console.log(`ìƒˆ ìœ ì € ìƒì„±: ${discordId}`);
        }
        
        // ì¸ë²¤í† ë¦¬ ë°ì´í„° ë¬´ê²°ì„± ê²€ì‚¬ ë° ë³µêµ¬
        const needsInventoryFix = validateAndFixInventory(user);
        
        // ì¥ë¹„ ë°ì´í„° ë¬´ê²°ì„± í™•ì¸ ë° ë³µêµ¬
        if (user.equipment) {
            let needsSave = needsInventoryFix;
            const equipmentSlots = ['weapon', 'armor', 'helmet', 'gloves', 'boots', 'accessory'];
            
            // ì¥ë¹„ ìŠ¬ë¡¯ ì´ˆê¸°í™” í™•ì¸
            equipmentSlots.forEach(slot => {
                if (user.equipment[slot] === undefined) {
                    user.equipment[slot] = -1;
                    needsSave = true;
                }
                
                // ObjectIdë‚˜ ì´ìƒí•œ ê°’ì´ë©´ -1ë¡œ ì´ˆê¸°í™”
                if (user.equipment[slot] && typeof user.equipment[slot] !== 'number') {
                    console.log(`[ì¥ë¹„ ë³µêµ¬] ${user.nickname}ì˜ ${slot} ìŠ¬ë¡¯ ë³µêµ¬: ${user.equipment[slot]} -> -1`);
                    user.equipment[slot] = -1;
                    needsSave = true;
                }
                
                // ì¥ì°©ëœ ìŠ¬ë¡¯ ë²ˆí˜¸ê°€ ìˆë‹¤ë©´ í•´ë‹¹ ì•„ì´í…œì˜ equipped ìƒíƒœ í™•ì¸
                if (user.equipment[slot] !== -1) {
                    const equippedItem = user.inventory.find(item => item.inventorySlot === user.equipment[slot]);
                    if (equippedItem && !equippedItem.equipped) {
                        equippedItem.equipped = true;
                        needsSave = true;
                        console.log(`[ì¥ë¹„ ë³µêµ¬] ${user.nickname}ì˜ ${equippedItem.name} equipped ìƒíƒœ ë³µêµ¬`);
                    } else if (!equippedItem && user.equipment[slot] !== -1) {
                        // ì¥ì°©ëœ ì•„ì´í…œì„ ì°¾ì„ ìˆ˜ ì—†ìœ¼ë©´ ìŠ¬ë¡¯ ì´ˆê¸°í™”
                        console.log(`[ì¥ë¹„ ë³µêµ¬] ${user.nickname}ì˜ ${slot} ìŠ¬ë¡¯ì— í•´ë‹¹í•˜ëŠ” ì•„ì´í…œì´ ì—†ìŒ: ${user.equipment[slot]} -> -1`);
                        user.equipment[slot] = -1;
                        needsSave = true;
                    }
                }
            });
            
            // ì¸ë²¤í† ë¦¬ì˜ equipped ìƒíƒœì™€ equipment ìŠ¬ë¡¯ ë™ê¸°í™”
            user.inventory.forEach(item => {
                // inventorySlotì´ ì—†ëŠ” ì•„ì´í…œì— ìë™ í• ë‹¹
                if (item.inventorySlot === undefined || item.inventorySlot === null) {
                    const availableSlot = getAvailableInventorySlot(user);
                    if (availableSlot !== -1) {
                        item.inventorySlot = availableSlot;
                        needsSave = true;
                        console.log(`[ì¸ë²¤í† ë¦¬ ë³µêµ¬] ${item.name}ì— inventorySlot ${availableSlot} í• ë‹¹`);
                    }
                }
                
                if (item.equipped) {
                    const slot = item.type;
                    if (user.equipment[slot] !== item.inventorySlot) {
                        console.log(`[ì¥ë¹„ ë™ê¸°í™”] ${user.nickname}ì˜ ${item.name} ì¥ì°© ìƒíƒœ ë™ê¸°í™”`);
                        user.equipment[slot] = item.inventorySlot;
                        needsSave = true;
                    }
                }
            });
            
            // ê°•í™” ë°ì´í„° ë¬´ê²°ì„± í™•ì¸
            user.inventory.forEach(item => {
                if (item.enhanceLevel === undefined) {
                    item.enhanceLevel = 0;
                    needsSave = true;
                }
                if (!item.stats) {
                    item.stats = { attack: 0, defense: 0, dodge: 0, luck: 0 };
                    needsSave = true;
                }
            });
            
            if (needsSave) {
                await user.save();
                console.log(`[ì¥ë¹„ ë³µêµ¬] ${user.nickname}ì˜ ì¥ë¹„ ë°ì´í„° ë³µêµ¬ ì™„ë£Œ`);
            }
        }
        
        // ì¶œì„ ë°ì´í„° ë¬´ê²°ì„± í™•ì¸
        if (user.lastDaily === null || user.lastDaily === undefined) {
            user.lastDaily = null;
        }
        if (!Array.isArray(user.weeklyAttendance)) {
            user.weeklyAttendance = [false, false, false, false, false, false, false];
        }
        if (!user.weekStart) {
            const now = new Date();
            const weekStart = new Date(now);
            weekStart.setDate(now.getDate() - now.getDay());
            weekStart.setHours(0, 0, 0, 0);
            user.weekStart = weekStart;
        }
        
        return user;
    } catch (error) {
        console.error('ìœ ì € ì¡°íšŒ/ìƒì„± ì˜¤ë¥˜:', error);
        return null;
    }
}

// ê°œë³„ ë§ˆì´ê·¸ë ˆì´ì…˜ í•¨ìˆ˜ ì œê±° (ì¼ê´„ ì •ë¦¬ë¡œ ëŒ€ì²´)

// ê¸°ì¡´ ObjectId ì¥ë¹„ ë°ì´í„° ì •ë¦¬ í•¨ìˆ˜
async function cleanupEquipmentData() {
    try {
        const result = await User.updateMany(
            {}, 
            {
                $set: {
                    'equipment.weapon': -1,
                    'equipment.armor': -1,
                    'equipment.helmet': -1,
                    'equipment.gloves': -1,
                    'equipment.boots': -1,
                    'equipment.accessory': -1
                }
            }
        );
        console.log(`âœ… ${result.modifiedCount}ëª…ì˜ ìœ ì € ì¥ë¹„ ë°ì´í„°ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.`);
    } catch (error) {
        console.error('ì¥ë¹„ ë°ì´í„° ì •ë¦¬ ì‹¤íŒ¨:', error);
    }
}

// ìœ ë¬¼ ë°ì´í„° ìˆ˜ì • í•¨ìˆ˜
async function fixArtifactData() {
    try {
        // baseValueì™€ currentPriceê°€ ì—†ëŠ” ìœ ë¬¼ì„ ê°€ì§„ ìœ ì € ì°¾ê¸°
        const users = await User.find({ 'artifacts.0': { $exists: true } });
        let fixedCount = 0;
        
        for (const user of users) {
            let needUpdate = false;
            
            for (const artifact of user.artifacts) {
                if (!artifact.baseValue || !artifact.currentPrice) {
                    // valueê°€ ìˆìœ¼ë©´ ê·¸ ê°’ì„ ì‚¬ìš©, ì—†ìœ¼ë©´ 1000 ê¸°ë³¸ê°’
                    const baseValue = artifact.value || 1000;
                    artifact.baseValue = baseValue;
                    artifact.currentPrice = baseValue;
                    needUpdate = true;
                }
            }
            
            if (needUpdate) {
                await user.save();
                fixedCount++;
            }
        }
        
        console.log(`âœ… ${fixedCount}ëª…ì˜ ìœ ì € ìœ ë¬¼ ë°ì´í„°ê°€ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.`);
    } catch (error) {
        console.error('ìœ ë¬¼ ë°ì´í„° ìˆ˜ì • ì‹¤íŒ¨:', error);
    }
}

// ë ˆë²¨ì—… ì²˜ë¦¬ í•¨ìˆ˜
function processLevelUp(user) {
    let leveledUp = false;
    let levelsGained = 0;
    const oldLevel = user.level;
    
    while (user.exp >= user.level * 100) {
        user.exp -= user.level * 100;
        user.level += 1;
        levelsGained += 1;
        leveledUp = true;
        
        // ë ˆë²¨ì—… ì‹œ ìŠ¤íƒ¯í¬ì¸íŠ¸ ì§€ê¸‰ (ë ˆë²¨ë‹¹ 5í¬ì¸íŠ¸)
        user.statPoints += 5;

        // ìƒˆë¡œìš´ ì‚¬ëƒ¥í„° í•´ê¸ˆ ì²´í¬
        const newUnlockArea = huntingAreas.find(area => 
            area.unlockLevel === user.level && !user.unlockedAreas.includes(area.id)
        );
        if (newUnlockArea) {
            user.unlockedAreas.push(newUnlockArea.id);
        }
    }
    
    return { leveledUp, levelsGained, oldLevel };
}

// ì¸ê¸°ë„ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
async function updatePopularity(messageAuthorId, emoji, value, messageId, guild) {
    try {
        const user = await getUser(messageAuthorId);
        if (!user || !user.registered) return { success: false, message: 'ë“±ë¡ë˜ì§€ ì•Šì€ ì‚¬ìš©ìì…ë‹ˆë‹¤.' };
        
        // ê°™ì€ ë©”ì‹œì§€ì— ëŒ€í•œ ì´ì „ ë°˜ì‘ í™•ì¸
        const existingReaction = user.popularityHistory.find(h => h.messageId === messageId && h.emoji === emoji);
        if (existingReaction) {
            return { success: false, message: 'ì´ë¯¸ ë°˜ì‘í•œ ë©”ì‹œì§€ì…ë‹ˆë‹¤.' };
        }
        
        // ì¼ì¼ ì œí•œ ë¦¬ì…‹ í™•ì¸
        const today = new Date().toDateString();
        if (user.lastPopularityReset !== today) {
            user.dailyPopularityGain = 0;
            user.dailyPopularityLoss = 0;
            user.lastPopularityReset = today;
        }
        
        // ì¼ì¼ ì œí•œ í™•ì¸
        if (value > 0 && user.dailyPopularityGain >= 10) {
            return { success: false, message: 'ì˜¤ëŠ˜ ë°›ì„ ìˆ˜ ìˆëŠ” ì¸ê¸°ë„ ìƒìŠ¹ì¹˜ë¥¼ ëª¨ë‘ ë°›ì•˜ìŠµë‹ˆë‹¤. (+10)' };
        }
        if (value < 0 && user.dailyPopularityLoss <= -10) {
            return { success: false, message: 'ì˜¤ëŠ˜ ë°›ì„ ìˆ˜ ìˆëŠ” ì¸ê¸°ë„ í•˜ë½ì¹˜ë¥¼ ëª¨ë‘ ë°›ì•˜ìŠµë‹ˆë‹¤. (-10)' };
        }
        
        // ì‹¤ì œë¡œ ì ìš©í•  ê°’ ê³„ì‚°
        let actualChange = value;
        if (value > 0) {
            actualChange = Math.min(value, 10 - user.dailyPopularityGain);
            user.dailyPopularityGain += actualChange;
        } else {
            actualChange = Math.max(value, -10 - user.dailyPopularityLoss);
            user.dailyPopularityLoss += actualChange;
        }
        
        if (actualChange === 0) {
            return { success: false, message: `ì˜¤ëŠ˜ì˜ ì¸ê¸°ë„ ${value > 0 ? 'ìƒìŠ¹' : 'í•˜ë½'} í•œë„ì— ë„ë‹¬í–ˆìŠµë‹ˆë‹¤.` };
        }
        
        // ì¸ê¸°ë„ ì—…ë°ì´íŠ¸
        user.popularity += actualChange;
        user.lastPopularityUpdate = new Date();
        user.popularityHistory.push({
            messageId,
            emoji,
            value: actualChange,
            date: new Date()
        });
        
        await user.save();
        
        // ì¸ê¸°ì™• ì—­í•  ì—…ë°ì´íŠ¸
        await updatePopularKingRole(guild);
        
        const dailyStatus = value > 0 
            ? `(ì˜¤ëŠ˜ +${user.dailyPopularityGain}/10)`
            : `(ì˜¤ëŠ˜ ${user.dailyPopularityLoss}/10)`;
        
        return { 
            success: true, 
            newPopularity: user.popularity,
            change: actualChange,
            message: `ì¸ê¸°ë„ê°€ ${actualChange > 0 ? '+' : ''}${actualChange}ë˜ì–´ ${user.popularity}ê°€ ë˜ì—ˆìŠµë‹ˆë‹¤. ${dailyStatus}`
        };
    } catch (error) {
        console.error('ì¸ê¸°ë„ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:', error);
        return { success: false, message: 'ì¸ê¸°ë„ ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.' };
    }
}

// ì¸ê¸°ì™• ì—­í•  ì—…ë°ì´íŠ¸ í•¨ìˆ˜
async function updatePopularKingRole(guild) {
    try {
        // ì¸ê¸°ì™• ì—­í•  ì°¾ê¸° ë˜ëŠ” ìƒì„±
        let popularKingRole = guild.roles.cache.find(role => role.name === POPULAR_KING_ROLE_NAME);
        
        if (!popularKingRole) {
            popularKingRole = await guild.roles.create({
                name: POPULAR_KING_ROLE_NAME,
                color: '#FFD700',
                hoist: true,
                reason: 'ì¸ê¸°ì™• ì‹œìŠ¤í…œ ìë™ ìƒì„±'
            });
        }
        
        // í˜„ì¬ ì¸ê¸°ì™• ì°¾ê¸°
        const currentKing = guild.members.cache.find(member => 
            member.roles.cache.has(popularKingRole.id)
        );
        
        // ê°€ì¥ ë†’ì€ ì¸ê¸°ë„ë¥¼ ê°€ì§„ ìœ ì € ì°¾ê¸°
        const topUser = await User.findOne({ registered: true })
            .sort({ popularity: -1 })
            .limit(1);
        
        if (!topUser || topUser.popularity <= 0) {
            // ì¸ê¸°ë„ê°€ ì–‘ìˆ˜ì¸ ì‚¬ëŒì´ ì—†ìœ¼ë©´ ì—­í•  íšŒìˆ˜
            if (currentKing) {
                await currentKing.roles.remove(popularKingRole);
            }
            return;
        }
        
        // ìƒˆë¡œìš´ ì¸ê¸°ì™•ì´ í•„ìš”í•œ ê²½ìš°
        if (!currentKing || currentKing.id !== topUser.discordId) {
            // ê¸°ì¡´ ì¸ê¸°ì™• ì—­í•  íšŒìˆ˜
            if (currentKing) {
                await currentKing.roles.remove(popularKingRole);
            }
            
            // ìƒˆë¡œìš´ ì¸ê¸°ì™•ì—ê²Œ ì—­í•  ë¶€ì—¬
            const newKing = await guild.members.fetch(topUser.discordId);
            if (newKing) {
                await newKing.roles.add(popularKingRole);
                
                // ì±„ë„ì— ì•Œë¦¼ (ì„ íƒì‚¬í•­)
                const channel = guild.channels.cache.get(GAME_CHANNEL_ID);
                if (channel) {
                    const embed = new EmbedBuilder()
                        .setColor('#FFD700')
                        .setTitle('ğŸ‘‘ ìƒˆë¡œìš´ ì¸ê¸°ì™• íƒ„ìƒ!')
                        .setDescription(`**${topUser.nickname}**ë‹˜ì´ ì¸ê¸°ë„ ${topUser.popularity}ì ìœ¼ë¡œ ìƒˆë¡œìš´ ì¸ê¸°ì™•ì´ ë˜ì—ˆìŠµë‹ˆë‹¤!`)
                        .setTimestamp();
                    
                    await channel.send({ embeds: [embed] });
                }
            }
        }
    } catch (error) {
        console.error('ì¸ê¸°ì™• ì—­í•  ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:', error);
    }
}

// ìŠ¬ë˜ì‹œ ëª…ë ¹ì–´ ì •ì˜
const commands = [
    new SlashCommandBuilder()
        .setName('ê²Œì„')
        .setDescription('ê°•í™”ì™• ê¹€í—Œí„° ê²Œì„ ë©”ë‰´'),
    
    new SlashCommandBuilder()
        .setName('í•‘')
        .setDescription('ë´‡ì˜ ì‘ë‹µ ì†ë„ë¥¼ í™•ì¸í•©ë‹ˆë‹¤'),
    
    new SlashCommandBuilder()
        .setName('íšŒì›ê°€ì…')
        .setDescription('ê°•í™”ì™• ê¹€í—Œí„° íšŒì›ê°€ì…'),
    
    new SlashCommandBuilder()
        .setName('dbí…ŒìŠ¤íŠ¸')
        .setDescription('ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° í…ŒìŠ¤íŠ¸'),
    
    new SlashCommandBuilder()
        .setName('ì´ë©”ì¼í…ŒìŠ¤íŠ¸')
        .setDescription('ì´ë©”ì¼ ì „ì†¡ í…ŒìŠ¤íŠ¸'),
    
    new SlashCommandBuilder()
        .setName('íšŒì›ê°€ì…ì±„ë„ì„¤ì •')
        .setDescription('íšŒì›ê°€ì… ì±„ë„ì— ì•ˆë‚´ ë©”ì‹œì§€ë¥¼ ê²Œì‹œí•©ë‹ˆë‹¤'),
    
    new SlashCommandBuilder()
        .setName('ì¸ê¸°ë„í…ŒìŠ¤íŠ¸')
        .setDescription('í…ŒìŠ¤íŠ¸ìš© ì¸ê¸°ë„ ì¡°ì‘ ëª…ë ¹ì–´')
        .addStringOption(option =>
            option.setName('í–‰ë™')
                .setDescription('ìˆ˜í–‰í•  í–‰ë™')
                .setRequired(true)
                .addChoices(
                    { name: 'ì¸ê¸°ë„ ì¦ê°€ (+5)', value: 'add' },
                    { name: 'ì¸ê¸°ë„ ê°ì†Œ (-5)', value: 'subtract' },
                    { name: 'ì¼ì¼ í•œë„ ë¦¬ì…‹', value: 'reset' },
                    { name: 'ì¸ê¸°ë„ í™•ì¸', value: 'check' }
                )),
    
    new SlashCommandBuilder()
        .setName('ì „íˆ¬ë ¥ìˆ˜ì •')
        .setDescription('ê´€ë¦¬ì ì „ìš©: ì „íˆ¬ë ¥ ìˆ˜ì • ëª…ë ¹ì–´')
        .addStringOption(option =>
            option.setName('íƒ€ì…')
                .setDescription('ìˆ˜ì •í•  ëŠ¥ë ¥ì¹˜')
                .setRequired(true)
                .addChoices(
                    { name: 'í˜ (+10)', value: 'strength' },
                    { name: 'ë¯¼ì²© (+10)', value: 'agility' },
                    { name: 'ì§€ëŠ¥ (+10)', value: 'intelligence' },
                    { name: 'ì²´ë ¥ (+10)', value: 'vitality' },
                    { name: 'í–‰ìš´ (+10)', value: 'luck' },
                    { name: 'ì „íˆ¬ë ¥ í™•ì¸', value: 'check' }
                )),

    new SlashCommandBuilder()
        .setName('ê°•í™”')
        .setDescription('ì¥ë¹„ë¥¼ ê°•í™”í•©ë‹ˆë‹¤ (0-30ê°•)')
        .addStringOption(option =>
            option.setName('ì¥ë¹„ìŠ¬ë¡¯')
                .setDescription('ê°•í™”í•  ì¥ë¹„ ìŠ¬ë¡¯')
                .setRequired(true)
                .addChoices(
                    { name: 'ë¬´ê¸°', value: 'weapon' },
                    { name: 'ê°‘ì˜·', value: 'armor' },
                    { name: 'íˆ¬êµ¬', value: 'helmet' },
                    { name: 'ì¥ê°‘', value: 'gloves' },
                    { name: 'ì‹ ë°œ', value: 'boots' },
                    { name: 'ì•¡ì„¸ì„œë¦¬', value: 'accessory' }
                ))
        .addBooleanOption(option =>
            option.setName('ë³´í˜¸ê¶Œì‚¬ìš©')
                .setDescription('ë³´í˜¸ê¶Œì„ ì‚¬ìš©í•˜ì—¬ íŒŒê´´ë¥¼ ë°©ì§€í•©ë‹ˆë‹¤ (20ê°• ì´ìƒë§Œ ì‚¬ìš© ê°€ëŠ¥)')
                .setRequired(false)),

    new SlashCommandBuilder()
        .setName('ê²°íˆ¬')
        .setDescription('PVP ê²°íˆ¬ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤'),

    new SlashCommandBuilder()
        .setName('ê²°íˆ¬ì •ë³´')
        .setDescription('PVP í†µê³„ ë° ì •ë³´ë¥¼ í™•ì¸í•©ë‹ˆë‹¤'),

    new SlashCommandBuilder()
        .setName('ë­í‚¹')
        .setDescription('PVP ë­í‚¹ì„ í™•ì¸í•©ë‹ˆë‹¤'),

    new SlashCommandBuilder()
        .setName('ì§‘ì¤‘ë ¥')
        .setDescription('ì§‘ì¤‘ë ¥ ì¶•ë³µìœ¼ë¡œ ì¥ë¹„ë¥¼ ê°•í™”í•©ë‹ˆë‹¤ (ì„±ê³µë¥  5% ì¦ê°€)')
        .addStringOption(option =>
            option.setName('ì¥ë¹„ìŠ¬ë¡¯')
                .setDescription('ê°•í™”í•  ì¥ë¹„ ìŠ¬ë¡¯')
                .setRequired(true)
                .addChoices(
                    { name: 'ë¬´ê¸°', value: 'weapon' },
                    { name: 'ê°‘ì˜·', value: 'armor' },
                    { name: 'íˆ¬êµ¬', value: 'helmet' },
                    { name: 'ì¥ê°‘', value: 'gloves' },
                    { name: 'ì‹ ë°œ', value: 'boots' },
                    { name: 'ì•¡ì„¸ì„œë¦¬', value: 'accessory' }
                ))
        .addBooleanOption(option =>
            option.setName('ë³´í˜¸ê¶Œì‚¬ìš©')
                .setDescription('ë³´í˜¸ê¶Œì„ ì‚¬ìš©í•˜ì—¬ íŒŒê´´ë¥¼ ë°©ì§€í•©ë‹ˆë‹¤ (20ê°• ì´ìƒë§Œ ì‚¬ìš© ê°€ëŠ¥)')
                .setRequired(false)),

    new SlashCommandBuilder()
        .setName('ì¶•ë³µë°›ì€ë‚ ')
        .setDescription('ì¶•ë³µë°›ì€ ë‚ ë¡œ ê°•í™”í•©ë‹ˆë‹¤ (15-22ê°• íŒŒê´´ìœ¨ 30% ê°ì†Œ)')
        .addStringOption(option =>
            option.setName('ì¥ë¹„ìŠ¬ë¡¯')
                .setDescription('ê°•í™”í•  ì¥ë¹„ ìŠ¬ë¡¯')
                .setRequired(true)
                .addChoices(
                    { name: 'ë¬´ê¸°', value: 'weapon' },
                    { name: 'ê°‘ì˜·', value: 'armor' },
                    { name: 'íˆ¬êµ¬', value: 'helmet' },
                    { name: 'ì¥ê°‘', value: 'gloves' },
                    { name: 'ì‹ ë°œ', value: 'boots' },
                    { name: 'ì•¡ì„¸ì„œë¦¬', value: 'accessory' }
                ))
        .addBooleanOption(option =>
            option.setName('ë³´í˜¸ê¶Œì‚¬ìš©')
                .setDescription('ë³´í˜¸ê¶Œì„ ì‚¬ìš©í•˜ì—¬ íŒŒê´´ë¥¼ ë°©ì§€í•©ë‹ˆë‹¤ (20ê°• ì´ìƒë§Œ ì‚¬ìš© ê°€ëŠ¥)')
                .setRequired(false)),

    new SlashCommandBuilder()
        .setName('ê°•í™”ë­í‚¹')
        .setDescription('ê°•í™” ë­í‚¹ì„ í™•ì¸í•©ë‹ˆë‹¤'),

    new SlashCommandBuilder()
        .setName('ê°•í™”í†µê³„')
        .setDescription('ë‚˜ì˜ ê°•í™” í†µê³„ë¥¼ í™•ì¸í•©ë‹ˆë‹¤'),

    new SlashCommandBuilder()
        .setName('ì˜ë¢°')
        .setDescription('ë§ˆì„ ì˜ë¢°ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤'),

    new SlashCommandBuilder()
        .setName('ì£¼ì‹')
        .setDescription('í˜ì‹ ì ì¸ ì£¼ì‹ ì‹œì¥ì— ì°¸ì—¬í•©ë‹ˆë‹¤'),
    
    // ğŸ”® ì—ë„ˆì§€ ì¡°ê° ì‹œìŠ¤í…œ ëª…ë ¹ì–´
    new SlashCommandBuilder()
        .setName('ì—ë„ˆì§€ì±„êµ´')
        .setDescription('â›ï¸ 1ë‹¨ê³„ ì—ë„ˆì§€ ì¡°ê°ì„ ì±„êµ´í•©ë‹ˆë‹¤ (500ê³¨ë“œ, ì¿¨íƒ€ì„ 2ë¶„)'),
    
    new SlashCommandBuilder()
        .setName('ì¡°ê°ìœµí•©')
        .setDescription('ğŸ”„ ë³´ìœ í•œ ê°™ì€ ë‹¨ê³„ ì¡°ê°ë“¤ì„ ìë™ìœ¼ë¡œ ìœµí•©í•©ë‹ˆë‹¤ (ì¼ì¼ 20íšŒ ì œí•œ)'),
    
    new SlashCommandBuilder()
        .setName('ë‚´ì¡°ê°')
        .setDescription('ğŸ’ í˜„ì¬ ë³´ìœ í•œ ì—ë„ˆì§€ ì¡°ê°ì„ í™•ì¸í•©ë‹ˆë‹¤'),
    
    new SlashCommandBuilder()
        .setName('ìœµí•©ë­í‚¹')
        .setDescription('ğŸ† ì´ë²ˆ ì£¼ ì—ë„ˆì§€ ì¡°ê° ìœµí•© ë­í‚¹ì„ í™•ì¸í•©ë‹ˆë‹¤'),
    
    new SlashCommandBuilder()
        .setName('ë‚´ì „íˆ¬ë ¥')
        .setDescription('âš”ï¸ í˜„ì¬ ì „íˆ¬ë ¥ê³¼ ì—ë„ˆì§€ ì¡°ê° ì •ë³´ë¥¼ í™•ì¸í•©ë‹ˆë‹¤'),
    
    // ê´€ë¦¬ì ì „ìš© ëª…ë ¹ì–´
    new SlashCommandBuilder()
        .setName('ì¹´ìš´íŠ¸ë‹¤ìš´')
        .setDescription('ğŸš€ [ê´€ë¦¬ì] ê²Œì„ ì˜¤í”ˆ ì¹´ìš´íŠ¸ë‹¤ìš´ ì„¤ì •')
        .addSubcommand(subcommand =>
            subcommand
                .setName('ì‹œì‘')
                .setDescription('ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘')
                .addIntegerOption(option =>
                    option.setName('ì‹œê°„')
                        .setDescription('ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œê°„ (ì‹œê°„ ë‹¨ìœ„)')
                        .setRequired(true)
                        .setMinValue(1)
                        .setMaxValue(168)) // ìµœëŒ€ 7ì¼
                .addChannelOption(option =>
                    option.setName('ì±„ë„')
                        .setDescription('ì¹´ìš´íŠ¸ë‹¤ìš´ì„ í‘œì‹œí•  ì±„ë„')
                        .setRequired(true)))
        .addSubcommand(subcommand =>
            subcommand
                .setName('ì¤‘ì§€')
                .setDescription('ì¹´ìš´íŠ¸ë‹¤ìš´ ì¤‘ì§€')),
    new SlashCommandBuilder()
        .setName('ê²Œì„ë°ì´í„°ì´ˆê¸°í™”')
        .setDescription('ğŸ”§ [ê´€ë¦¬ì ì „ìš©] ëª¨ë“  ê²Œì„ ë°ì´í„°ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤'),
    
    new SlashCommandBuilder()
        .setName('ìœµí•©ìˆ˜ë™')
        .setDescription('ğŸ¯ íŠ¹ì • ë‹¨ê³„ì˜ ì¡°ê°ì„ ì„ íƒí•˜ì—¬ ìˆ˜ë™ìœ¼ë¡œ ìœµí•©í•©ë‹ˆë‹¤'),
    
    new SlashCommandBuilder()
        .setName('í™€ì§')
        .setDescription('ğŸ² í™€ì§ ê²Œì„ì„ í”Œë ˆì´í•©ë‹ˆë‹¤'),
    
    new SlashCommandBuilder()
        .setName('ë…ë²„ì„¯')
        .setDescription('ğŸ„ ë…ë²„ì„¯ ê²Œì„ì„ í”Œë ˆì´í•©ë‹ˆë‹¤ - ì•ˆì „í•œ ë²„ì„¯ì„ ì°¾ì•„ ìƒì¡´í•˜ì„¸ìš”!')
        .addStringOption(option =>
            option.setName('ë‚œì´ë„')
                .setDescription('ê²Œì„ ë‚œì´ë„ ì„ íƒ')
                .setRequired(false)
                .addChoices(
                    { name: 'ğŸŒ± í˜¼ì í”Œë ˆì´', value: 'solo' },
                    { name: 'âš”ï¸ ìœ ì €ì™€ ëŒ€ê²°', value: 'pvp' },
                    { name: 'ğŸ¤– ë´‡ê³¼ ëŒ€ê²°', value: 'bot' }
                )),
                
    new SlashCommandBuilder()
        .setName('ì£¼ì‹ë³µêµ¬')
        .setDescription('ğŸ“ˆ ìƒì–´ë²„ë¦° ì£¼ì‹ ë°ì´í„°ë¥¼ ë³µêµ¬í•©ë‹ˆë‹¤ (ê´€ë¦¬ì ì „ìš©)')
        .addUserOption(option =>
            option.setName('ìœ ì €')
                .setDescription('ì£¼ì‹ì„ ë³µêµ¬í•  ìœ ì €')
                .setRequired(true))
        .addStringOption(option =>
            option.setName('ê¸°ì—…')
                .setDescription('ê¸°ì—… ID (ì˜ˆ: traveler_inn)')
                .setRequired(true))
        .addIntegerOption(option =>
            option.setName('ìˆ˜ëŸ‰')
                .setDescription('ë³´ìœ  ì£¼ì‹ ìˆ˜ëŸ‰')
                .setRequired(true))
        .addIntegerOption(option =>
            option.setName('í‰ê· ê°€')
                .setDescription('í‰ê·  ë§¤ìˆ˜ê°€')
                .setRequired(true)),
                
    new SlashCommandBuilder()
        .setName('ìœ ë¬¼íƒì‚¬')
        .setDescription('ğŸº ìœ ë¬¼ì„ íƒì‚¬í•˜ì—¬ ë³´ë¬¼ì„ ì°¾ì•„ë³´ì„¸ìš”!'),
        
    new SlashCommandBuilder()
        .setName('ëˆì§€ê¸‰')
        .setDescription('ğŸ’° ì‚¬ìš©ìì—ê²Œ ê³¨ë“œë¥¼ ì§€ê¸‰í•©ë‹ˆë‹¤ (ê´€ë¦¬ì ì „ìš©)')
        .addUserOption(option =>
            option.setName('ìœ ì €')
                .setDescription('ê³¨ë“œë¥¼ ë°›ì„ ìœ ì €')
                .setRequired(true))
        .addIntegerOption(option =>
            option.setName('ê¸ˆì•¡')
                .setDescription('ì§€ê¸‰í•  ê³¨ë“œ ê¸ˆì•¡')
                .setRequired(true)
                .setMinValue(1)),
    new SlashCommandBuilder()
        .setName('ë³´ìŠ¤')
        .setDescription('ğŸ—¡ï¸ ë³´ìŠ¤ ë ˆì´ë“œ ê´€ë¦¬ (ê´€ë¦¬ì ì „ìš©)')
        .addSubcommand(subcommand =>
            subcommand
                .setName('ìŠ¤í°')
                .setDescription('ë³´ìŠ¤ë¥¼ ì¦‰ì‹œ ìŠ¤í°í•©ë‹ˆë‹¤')
                .addStringOption(option =>
                    option.setName('ë³´ìŠ¤')
                        .setDescription('ìŠ¤í°í•  ë³´ìŠ¤ ì„ íƒ')
                        .setRequired(false)
                        .addChoices(
                            { name: 'ğŸ—¡ï¸ ê·¸ë¦¼ì ì•”ì‚´ì', value: 'shadow_assassin' },
                            { name: 'ğŸ‰ ì„œë¦¬ ë“œë˜ê³¤', value: 'frost_dragon' },
                            { name: 'ğŸ‘¹ ë°ëª¬ ë¡œë“œ', value: 'demon_lord' },
                            { name: 'ğŸ—¿ ê³ ëŒ€ ê³¨ë ˜', value: 'ancient_golem' },
                            { name: 'ğŸ‘‘ ê³µí—ˆì˜ í™©ì œ', value: 'void_emperor' }
                        )))
        .addSubcommand(subcommand =>
            subcommand
                .setName('ì¢…ë£Œ')
                .setDescription('í˜„ì¬ ë³´ìŠ¤ë¥¼ ì œê±°í•©ë‹ˆë‹¤'))
        .addSubcommand(subcommand =>
            subcommand
                .setName('ì •ë³´')
                .setDescription('í˜„ì¬ ë³´ìŠ¤ ìƒíƒœë¥¼ í™•ì¸í•©ë‹ˆë‹¤'))
];

// ë´‡ì´ ì¤€ë¹„ë˜ì—ˆì„ ë•Œ
client.once('ready', async () => {
    try {
        console.log(`${client.user.tag} ë´‡ì´ ì˜¨ë¼ì¸ ìƒíƒœì…ë‹ˆë‹¤! - ìë™ ì¬ì‹œì‘ í…ŒìŠ¤íŠ¸`);
        console.log(`ê°œë°œ ëª¨ë“œ: ${DEV_MODE ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'}`);
        if (DEV_MODE && DEV_CHANNEL_IDS.length > 0) {
            console.log(`ê°œë°œ ì±„ë„ë“¤: ${DEV_CHANNEL_IDS.join(', ')}`);
        }
        
        // MongoDB ì—°ê²°
        await connectDB();
        
        // ê¸°ì¡´ ObjectId ë°ì´í„° ì¼ê´„ ì •ë¦¬
        await cleanupEquipmentData();
        
        // ìœ ë¬¼ ë°ì´í„° ìˆ˜ì •
        await fixArtifactData();
        
        // ê²Œì„ ë°ì´í„° ë¡œë“œ
        loadGameData();
        
        // ìŠ¬ë˜ì‹œ ëª…ë ¹ì–´ ë“±ë¡
        try {
            const rest = new REST().setToken(TOKEN);
            console.log('ìŠ¬ë˜ì‹œ ëª…ë ¹ì–´ ë“±ë¡ ì¤‘...');
            
            // ê°œë°œ ëª¨ë“œì—ì„œëŠ” ê¸¸ë“œ(ì„œë²„) ëª…ë ¹ì–´ ì‚¬ìš© (ì¦‰ì‹œ ì ìš©)
            const guildId = DEV_MODE ? '1371885859649097849' : null; // ê°œë°œ ì„œë²„ ID
            
            const data = await rest.put(
                guildId ? Routes.applicationGuildCommands(CLIENT_ID, guildId) : Routes.applicationCommands(CLIENT_ID),
                { body: commands }
            );
            
            console.log(`ìŠ¬ë˜ì‹œ ëª…ë ¹ì–´ ${data.length}ê°œê°€ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤!`);
            console.log('ë“±ë¡ëœ ëª…ë ¹ì–´:', data.map(cmd => cmd.name).join(', '));
        } catch (error) {
            console.error('ëª…ë ¹ì–´ ë“±ë¡ ì‹¤íŒ¨:', error);
        }
        
        // ì— ë¸”ëŸ¼ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
        await initializeEmblemSystem();
    } catch (error) {
        console.error('ë´‡ ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
    }
});

// ì— ë¸”ëŸ¼ ì‹œìŠ¤í…œ ì´ˆê¸°í™” í•¨ìˆ˜
async function initializeEmblemSystem() {
    try {
        const channel = await client.channels.fetch(EMBLEM_CHANNEL_ID);
        if (!channel) {
            console.log('ì— ë¸”ëŸ¼ ì±„ë„ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            return;
        }

        // ì— ë¸”ëŸ¼ ìƒì  ì„ë² ë“œ ìƒì„±
        const emblemEmbed = new EmbedBuilder()
            .setColor('#ff6b6b')
            .setTitle('ğŸ† ì— ë¸”ëŸ¼ ìƒì ')
            .setDescription('**ë ˆë²¨ 20 ì´ìƒ**ë¶€í„° ì— ë¸”ëŸ¼ì„ êµ¬ë§¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!\n\nì— ë¸”ëŸ¼ì„ êµ¬ë§¤í•˜ë©´ íŠ¹ë³„í•œ ì¹­í˜¸ ì—­í• ì„ ë°›ê²Œ ë©ë‹ˆë‹¤.\n**âš ï¸ ì— ë¸”ëŸ¼ì€ í•œ ë²ˆ êµ¬ë§¤í•˜ë©´ ë³€ê²½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤!**')
            .addFields(
                { name: 'âš”ï¸ ì „ì‚¬ ê³„ì—´', value: 'ì´ˆë³´ì „ì‚¬ â†’ íŠ¼íŠ¼í•œ ê¸°ì‚¬ â†’ ìš©ë§¹í•œ ê²€ì‚¬ â†’ ë§¹ë ¹í•œ ì „ì‚¬ â†’ ì „ì„¤ì˜ ê¸°ì‚¬', inline: false },
                { name: 'ğŸ¹ ê¶ìˆ˜ ê³„ì—´', value: 'ë§ˆì„ì‚¬ëƒ¥ê¾¼ â†’ ìˆ²ì˜ ê¶ìˆ˜ â†’ ë°”ëŒ ì‚¬ìˆ˜ â†’ ì •í™•í•œ ì‚¬ê²©ìˆ˜ â†’ ì „ì„¤ì˜ ëª…ê¶', inline: false },
                { name: 'ğŸ”® ë§ˆê²€ì‚¬ ê³„ì—´', value: 'ë§ˆë²• í•™ë„ â†’ ë§ˆë²• ê²€ì‚¬ â†’ í˜„ëª…í•œ ê¸°ì‚¬ â†’ ë§ˆë„ ê²€ì‚¬ â†’ ì „ì„¤ì˜ ë§ˆê²€ì‚¬', inline: false },
                { name: 'ğŸ—¡ï¸ ë„ì  ê³„ì—´', value: 'ë– ëŒì´ ë„ì  â†’ ìš´ ì¢‹ì€ ë„ë‘‘ â†’ í–‰ìš´ì˜ ë‹Œì â†’ ë³µ ë§ì€ ë„ì  â†’ ì „ì„¤ì˜ í–‰ìš´ì•„', inline: false }
            )
            .setFooter({ text: 'ì›í•˜ëŠ” ê³„ì—´ì„ ì„ íƒí•˜ì—¬ ì— ë¸”ëŸ¼ì„ êµ¬ë§¤í•˜ì„¸ìš”!' });

        // ì— ë¸”ëŸ¼ ê³„ì—´ ì„ íƒ ë“œë¡­ë‹¤ìš´
        const emblemSelect = new ActionRowBuilder()
            .addComponents(
                new StringSelectMenuBuilder()
                    .setCustomId('emblem_category')
                    .setPlaceholder('ì— ë¸”ëŸ¼ ê³„ì—´ì„ ì„ íƒí•˜ì„¸ìš”')
                    .addOptions([
                        {
                            label: 'ì „ì‚¬ ê³„ì—´',
                            description: 'ì´ˆë³´ì „ì‚¬ë¶€í„° ì „ì„¤ì˜ ê¸°ì‚¬ê¹Œì§€',
                            value: 'warrior',
                            emoji: 'âš”ï¸'
                        },
                        {
                            label: 'ê¶ìˆ˜ ê³„ì—´',
                            description: 'ë§ˆì„ì‚¬ëƒ¥ê¾¼ë¶€í„° ì „ì„¤ì˜ ëª…ê¶ê¹Œì§€',
                            value: 'archer',
                            emoji: 'ğŸ¹'
                        },
                        {
                            label: 'ë§ˆê²€ì‚¬ ê³„ì—´',
                            description: 'ë§ˆë²• í•™ë„ë¶€í„° ì „ì„¤ì˜ ë§ˆê²€ì‚¬ê¹Œì§€',
                            value: 'spellsword',
                            emoji: 'ğŸ”®'
                        },
                        {
                            label: 'ë„ì  ê³„ì—´',
                            description: 'ë– ëŒì´ ë„ì ë¶€í„° ì „ì„¤ì˜ í–‰ìš´ì•„ê¹Œì§€',
                            value: 'rogue',
                            emoji: 'ğŸ—¡ï¸'
                        }
                    ])
            );

        // ê¸°ì¡´ ë©”ì‹œì§€ ì‚­ì œ í›„ ìƒˆë¡œ ì „ì†¡
        const messages = await channel.messages.fetch({ limit: 10 });
        const botMessages = messages.filter(msg => msg.author.id === client.user.id);
        if (botMessages.size > 0) {
            await channel.bulkDelete(botMessages);
        }

        await channel.send({
            embeds: [emblemEmbed],
            components: [emblemSelect]
        });

        console.log('ì— ë¸”ëŸ¼ ì‹œìŠ¤í…œì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.');
        
        // ë³´ìŠ¤ ìŠ¤í° ìŠ¤ì¼€ì¤„ëŸ¬ ì‹œì‘
        console.log('ë³´ìŠ¤ ìŠ¤í° ìŠ¤ì¼€ì¤„ëŸ¬ ì‹œì‘...');
        scheduleBossSpawn();
        
    } catch (error) {
        console.error('ì— ë¸”ëŸ¼ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì˜¤ë¥˜:', error);
    }
}

// ë©”ë‰´ ì‹œìŠ¤í…œ ì¸í„°ë™ì…˜ ì²˜ë¦¬
client.on('interactionCreate', async (interaction) => {
    if (!interaction.isStringSelectMenu()) return;
    
    const { customId, values, user } = interaction;
    console.log(`ğŸŸ£ ë“œë¡­ë‹¤ìš´ ì„ íƒë¨: ${customId}, ê°’: ${values[0]}`);
    
    try {
        // ì¹´í…Œê³ ë¦¬ ë©”ë‰´ ì²˜ë¦¬
        if (customId === 'category_menu') {
            const selectedValue = values[0];
            
            if (selectedValue.startsWith('category_')) {
                // íŠ¹ì • ì¹´í…Œê³ ë¦¬ ì„ íƒ
                const category = selectedValue.replace('category_', '');
                const categoryInfo = MENU_CATEGORIES[category];
                
                if (!categoryInfo) {
                    return await interaction.reply({ 
                        content: 'âŒ ì˜ëª»ëœ ì¹´í…Œê³ ë¦¬ì…ë‹ˆë‹¤!', 
                        flags: 64 
                    });
                }
                
                // ì¹´í…Œê³ ë¦¬ë³„ ë©”ë‰´ í‘œì‹œ
                const categoryMenu = createCategorySpecificMenu(category);
                const menuRow = new ActionRowBuilder().addComponents(categoryMenu);
                
                // ì¹´í…Œê³ ë¦¬ ì •ë³´ ì„ë² ë“œ
                const categoryEmbed = new EmbedBuilder()
                    .setColor(categoryInfo.color)
                    .setTitle(`${categoryInfo.emoji} ${categoryInfo.name}`)
                    .setDescription(categoryInfo.description)
                    .setFooter({ text: 'ì›í•˜ëŠ” ë©”ë‰´ë¥¼ ì„ íƒí•˜ì„¸ìš”!' });
                
                await interaction.update({
                    embeds: [categoryEmbed],
                    components: [menuRow]
                });
                
            } else if (selectedValue === 'all_menus') {
                // ì „ì²´ ë©”ë‰´ ë³´ê¸°
                const allMenus = await createCustomizedMenu(interaction.user.id);
                const menuRow = new ActionRowBuilder().addComponents(allMenus);
                
                const allMenuEmbed = new EmbedBuilder()
                    .setColor('#3498db')
                    .setTitle('ğŸ“‹ ì „ì²´ ë©”ë‰´')
                    .setDescription('ëª¨ë“  ë©”ë‰´ë¥¼ í•œë²ˆì— ë³´ê³  ìˆìŠµë‹ˆë‹¤.')
                    .setFooter({ text: 'ì›í•˜ëŠ” ë©”ë‰´ë¥¼ ì„ íƒí•˜ì„¸ìš”!' });
                
                await interaction.update({
                    embeds: [allMenuEmbed],
                    components: [menuRow]
                });
            }
            
            return;
        }
        
        // ë©”ì¸ ë©”ë‰´ ì²˜ë¦¬
        if (customId === 'main_menu') {
            const selectedValue = values[0];
            const user = await getUser(interaction.user.id);
            
            // ì¹´í…Œê³ ë¦¬ë¡œ ëŒì•„ê°€ê¸°
            if (selectedValue === 'back_to_categories') {
                const categoryMenu = createCategoryMenu();
                const menuRow = new ActionRowBuilder().addComponents(categoryMenu);
                
                // ê²½í—˜ì¹˜ ê³„ì‚°
                const maxExp = user.level * 100;
                
                // ì¶œì„ í˜„í™© ê³„ì‚°
                const today = new Date().toDateString();
                const attendanceStatus = user.lastDaily === today ? 'ì¶œì„' : 'ê²°ì„';
                
                // ì‹œê°„ëŒ€ë³„ ì´ë¯¸ì§€ ë° ìƒ‰ìƒ ì„¤ì •
                const now = new Date();
                const hour = now.getHours();
                
                let timeImage = '';
                let timeColor = '';
                
                if (hour >= 6 && hour < 12) {
                    timeImage = 'kim_main_morning.png';
                    timeColor = '#ffeb3b';
                } else if (hour >= 12 && hour < 18) {
                    timeImage = 'kim_main_lunch.png';
                    timeColor = '#ff9800';
                } else {
                    timeImage = 'kim_main_night.png';
                    timeColor = '#3f51b5';
                }
                
                const statusEmbed = new EmbedBuilder()
                    .setColor('#3498db')
                    .setTitle(`${getUserTitle(user)} ${user.nickname}ë‹˜ì˜ ìƒíƒœ`)
                    .addFields(
                        { name: 'â­ ë ˆë²¨', value: `\`\`\`Lv.${user.level}\`\`\``, inline: true },
                        { name: 'âœ¨ ê²½í—˜ì¹˜', value: `\`\`\`${user.exp}/${maxExp}\`\`\``, inline: true },
                        { name: '<:currency_emoji:1377404064316522778> ê³¨ë“œ', value: `\`\`\`${user.gold.toLocaleString()}\`\`\``, inline: true },
                        { name: 'ğŸ“… ì¶œì„í˜„í™©', value: `\`\`\`${attendanceStatus}\`\`\``, inline: true },
                        { name: 'ğŸ† ì¢…í•©ìˆœìœ„', value: `\`\`\`ì¤€ë¹„ì¤‘\`\`\``, inline: true },
                        { name: 'ğŸ’– ì¸ê¸°ë„', value: `\`\`\`${user.popularity}\`\`\``, inline: true }
                    )
                    .setFooter({ text: 'ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•˜ì„¸ìš”!' });
                
                // ë¹ ë¥¸ ì ‘ê·¼ ë²„íŠ¼ë“¤
                const quickButtons = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('daily')
                            .setLabel('ğŸ ì¼ì¼ë³´ìƒ')
                            .setStyle(ButtonStyle.Success),
                        new ButtonBuilder()
                            .setCustomId('hunting')
                            .setLabel('ğŸ¯ ì‚¬ëƒ¥í•˜ê¸°')
                            .setStyle(ButtonStyle.Primary),
                        new ButtonBuilder()
                            .setCustomId('equipment')
                            .setLabel('âš”ï¸ ì¥ë¹„ê´€ë¦¬')
                            .setStyle(ButtonStyle.Primary),
                        new ButtonBuilder()
                            .setCustomId('shop')
                            .setLabel('ğŸ›’ ìƒì ')
                            .setStyle(ButtonStyle.Primary)
                    );
                
                await interaction.update({
                    embeds: [statusEmbed],
                    components: [menuRow, quickButtons]
                });
                
                return;
            }
            
            // ê´€ë¦¬ì íŒ¨ë„ ì ‘ê·¼ ê¶Œí•œ í™•ì¸
            if (selectedValue === 'admin_panel' && !isAdmin(user.id)) {
                await interaction.deferUpdate();
                return await interaction.editReply({ 
                    content: 'âŒ ê´€ë¦¬ìë§Œ ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!' 
                });
            }
            
            // StringSelectMenu ìƒí˜¸ì‘ìš©ì´ë¯€ë¡œ ë¨¼ì € deferUpdate ì‹¤í–‰
            await interaction.deferUpdate();
            
            // ê° ë©”ë‰´ í•­ëª©ì— ë”°ë¥¸ ì²˜ë¦¬ - ê¸°ì¡´ ê¸°ëŠ¥ë“¤ì„ ì‹¤ì œë¡œ í˜¸ì¶œ
            switch (selectedValue) {
                case 'hunting':
                    // ê¸°ì¡´ ì‚¬ëƒ¥ ë¡œì§ í˜¸ì¶œ
                    
                    if (!user || !user.registered) {
                        return await interaction.editReply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!' });
                    }
                    
                    // ì‚¬ëƒ¥í„° ëª©ë¡ í‘œì‹œ (ê¸°ì¡´ hunting ë¡œì§ ì¬ì‚¬ìš©)
                    const currentPage = 0;
                    const itemsPerPage = 5;
                    const availableAreas = huntingAreas.filter(area => user.unlockedAreas.includes(area.id));
                    const totalPages = Math.ceil(availableAreas.length / itemsPerPage);
                    
                    if (availableAreas.length === 0) {
                        return await interaction.editReply({ content: 'âŒ ì‚¬ìš© ê°€ëŠ¥í•œ ì‚¬ëƒ¥í„°ê°€ ì—†ìŠµë‹ˆë‹¤!' });
                    }
                    
                    const embed = new EmbedBuilder()
                        .setColor('#ff6b6b')
                        .setTitle('ğŸ—¡ï¸ ì‚¬ëƒ¥í„° ì„ íƒ')
                        .setDescription('ì‚¬ëƒ¥í•  ì§€ì—­ì„ ì„ íƒí•˜ì„¸ìš”');
                    
                    const huntingButtons = new ActionRowBuilder();
                    const startIndex = currentPage * itemsPerPage;
                    const currentAreas = availableAreas.slice(startIndex, startIndex + itemsPerPage);
                    
                    currentAreas.forEach(area => {
                        huntingButtons.addComponents(
                            new ButtonBuilder()
                                .setCustomId(`hunt_area_${area.id}`)
                                .setLabel(area.name)
                                .setStyle(ButtonStyle.Primary)
                        );
                    });
                    
                    const navButtons = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('hunt_prev_page')
                                .setLabel('â—€ ì´ì „')
                                .setStyle(ButtonStyle.Secondary)
                                .setDisabled(currentPage === 0),
                            new ButtonBuilder()
                                .setCustomId('hunt_page_info')
                                .setLabel(`${currentPage + 1}/${totalPages}`)
                                .setStyle(ButtonStyle.Secondary)
                                .setDisabled(true),
                            new ButtonBuilder()
                                .setCustomId('hunt_next_page')
                                .setLabel('ë‹¤ìŒ â–¶')
                                .setStyle(ButtonStyle.Secondary)
                                .setDisabled(currentPage >= totalPages - 1),
                            new ButtonBuilder()
                                .setCustomId('back_to_game_menu')
                                .setLabel('ğŸ® ê²Œì„ ë©”ë‰´')
                                .setStyle(ButtonStyle.Secondary)
                        );
                    
                    return await interaction.editReply({ 
                        embeds: [embed], 
                        components: [huntingButtons, navButtons] 
                    });
                    
                case 'equipment':
                    // ì¥ë¹„ ê´€ë¦¬ë¥¼ ë“œë¡­ë‹¤ìš´ìœ¼ë¡œ ë³€ê²½
                    await interaction.deferReply({ flags: 64 });
                    
                    const equipUser = await getUser(interaction.user.id);
                    if (!equipUser || !equipUser.registered) {
                        return await interaction.editReply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!' });
                    }
                    
                    // ì¥ë¹„ ê´€ë¦¬ í™”ë©´ í‘œì‹œ
                    const equipmentEmbed = new EmbedBuilder()
                        .setColor('#ffaa00')
                        .setTitle('âš”ï¸ ì¥ë¹„ ê´€ë¦¬')
                        .setDescription('ì¥ì°© ì¤‘ì¸ ì¥ë¹„ë¥¼ í™•ì¸í•˜ê³  ê´€ë¦¬í•˜ì„¸ìš”\n\nğŸ’¼ í˜„ì¬ ì „íˆ¬ë ¥: ' + calculateCombatPower(equipUser).toLocaleString());
                    
                    const slots = ['weapon', 'armor', 'helmet', 'gloves', 'boots', 'accessory'];
                    const slotNames = {
                        weapon: 'âš”ï¸ ë¬´ê¸°',
                        armor: 'ğŸ›¡ï¸ ê°‘ì˜·',
                        helmet: 'â›‘ï¸ í—¬ë©§',
                        gloves: 'ğŸ§¬ ì¥ê°‘',
                        boots: 'ğŸ‘¢ ë¶€ì¸ ',
                        accessory: 'ğŸ’ ì•¡ì„¸ì„œë¦¬'
                    };
                    
                    for (const slot of slots) {
                        const slotIndex = equipUser.equipment[slot];
                        let slotInfo = 'ì°©ìš© ì•ˆí•¨';
                        
                        if (slotIndex !== -1) {
                            const equippedItem = equipUser.inventory.find(item => item.inventorySlot === slotIndex);
                            if (equippedItem) {
                                const enhanceText = equippedItem.enhanceLevel > 0 ? ` (+${equippedItem.enhanceLevel}ê°•)` : '';
                                slotInfo = `${equippedItem.name}${enhanceText}`;
                            }
                        }
                        
                        equipmentEmbed.addFields({
                            name: slotNames[slot],
                            value: slotInfo,
                            inline: true
                        });
                    }
                    
                    // ì¥ë¹„ ë³€ê²½ ë“œë¡­ë‹¤ìš´
                    const equipOptions = [
                        {
                            label: 'âš”ï¸ ë¬´ê¸° ë³€ê²½',
                            description: 'ë¬´ê¸°ë¥¼ ì¥ì°©í•˜ê±°ë‚˜ ë³€ê²½í•©ë‹ˆë‹¤',
                            value: 'equip_weapon',
                            emoji: 'âš”ï¸'
                        },
                        {
                            label: 'ğŸ›¡ï¸ ê°‘ì˜· ë³€ê²½',
                            description: 'ê°‘ì˜·ì„ ì¥ì°©í•˜ê±°ë‚˜ ë³€ê²½í•©ë‹ˆë‹¤',
                            value: 'equip_armor',
                            emoji: 'ğŸ›¡ï¸'
                        },
                        {
                            label: 'â›‘ï¸ í—¬ë©§ ë³€ê²½',
                            description: 'í—¬ë©§ì„ ì¥ì°©í•˜ê±°ë‚˜ ë³€ê²½í•©ë‹ˆë‹¤',
                            value: 'equip_helmet',
                            emoji: 'â›‘ï¸'
                        },
                        {
                            label: 'ğŸ§¬ ì¥ê°‘ ë³€ê²½',
                            description: 'ì¥ê°‘ì„ ì¥ì°©í•˜ê±°ë‚˜ ë³€ê²½í•©ë‹ˆë‹¤',
                            value: 'equip_gloves',
                            emoji: 'ğŸ§¬'
                        },
                        {
                            label: 'ğŸ‘¢ ë¶€ì¸  ë³€ê²½',
                            description: 'ë¶€ì¸ ë¥¼ ì¥ì°©í•˜ê±°ë‚˜ ë³€ê²½í•©ë‹ˆë‹¤',
                            value: 'equip_boots',
                            emoji: 'ğŸ‘¢'
                        },
                        {
                            label: 'ğŸ’ ì•¡ì„¸ì„œë¦¬ ë³€ê²½',
                            description: 'ì•¡ì„¸ì„œë¦¬ë¥¼ ì¥ì°©í•˜ê±°ë‚˜ ë³€ê²½í•©ë‹ˆë‹¤',
                            value: 'equip_accessory',
                            emoji: 'ğŸ’'
                        }
                    ];
                    
                    const equipSelectMenu = new StringSelectMenuBuilder()
                        .setCustomId('equipment_select')
                        .setPlaceholder('ğŸ® ë³€ê²½í•  ì¥ë¹„ ìŠ¬ë¡¯ì„ ì„ íƒí•˜ì„¸ìš”')
                        .addOptions(equipOptions);
                    
                    const selectRow = new ActionRowBuilder().addComponents(equipSelectMenu);
                    
                    const equipButtons = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('unequip_all')
                                .setLabel('ğŸš« ëª¨ë“  ì¥ë¹„ í•´ì œ')
                                .setStyle(ButtonStyle.Danger),
                            new ButtonBuilder()
                                .setCustomId('inventory')
                                .setLabel('ğŸ’ ì¸ë²¤í† ë¦¬')
                                .setStyle(ButtonStyle.Secondary),
                            new ButtonBuilder()
                                .setCustomId('back_to_game_menu')
                                .setLabel('ğŸ® ê²Œì„ ë©”ë‰´')
                                .setStyle(ButtonStyle.Secondary)
                        );
                    
                    return await interaction.editReply({ 
                        embeds: [equipmentEmbed], 
                        components: [selectRow, equipButtons] 
                    });
                    
                case 'shop':
                    // ìƒì ì„ ë“œë¡­ë‹¤ìš´ ë©”ë‰´ë¡œ ë³€ê²½
                    // interactionì´ ì´ë¯¸ deferë˜ì—ˆìœ¼ë¯€ë¡œ deferReply ì œê±°
                    
                    const shopEmbed = new EmbedBuilder()
                        .setColor('#00ff7f')
                        .setTitle('ğŸ›’ ê¹€í—Œí„° ìƒì ')
                        .setDescription('ì›í•˜ëŠ” ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•˜ì„¸ìš”\n\nğŸ’° ë³´ìœ  ê³¨ë“œ: ' + user.gold.toLocaleString() + 'G');
                    
                    // ì¹´í…Œê³ ë¦¬ ë“œë¡­ë‹¤ìš´ ë©”ë‰´
                    const categoryOptions = [
                        {
                            label: 'âš”ï¸ ë¬´ê¸°',
                            description: 'ë‹¤ì–‘í•œ ë¬´ê¸°ë¥¼ êµ¬ë§¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤',
                            value: 'shop_category_weapon',
                            emoji: 'âš”ï¸'
                        },
                        {
                            label: 'ğŸ›¡ï¸ ê°‘ì˜·',
                            description: 'íŠ¼íŠ¼í•œ ê°‘ì˜·ì„ êµ¬ë§¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤',
                            value: 'shop_category_armor',
                            emoji: 'ğŸ›¡ï¸'
                        },
                        {
                            label: 'â›‘ï¸ í—¬ë©§',
                            description: 'ë¨¸ë¦¬ë¥¼ ë³´í˜¸í•˜ëŠ” í—¬ë©§ì„ êµ¬ë§¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤',
                            value: 'shop_category_helmet',
                            emoji: 'â›‘ï¸'
                        },
                        {
                            label: 'ğŸ§¤ ì¥ê°‘',
                            description: 'ì†ì„ ë³´í˜¸í•˜ëŠ” ì¥ê°‘ì„ êµ¬ë§¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤',
                            value: 'shop_category_gloves',
                            emoji: 'ğŸ§¤'
                        },
                        {
                            label: 'ğŸ‘¢ ë¶€ì¸ ',
                            description: 'ë°œì„ ë³´í˜¸í•˜ëŠ” ë¶€ì¸ ë¥¼ êµ¬ë§¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤',
                            value: 'shop_category_boots',
                            emoji: 'ğŸ‘¢'
                        },
                        {
                            label: 'ğŸ’ ì•¡ì„¸ì„œë¦¬',
                            description: 'íŠ¹ë³„í•œ íš¨ê³¼ë¥¼ ê°€ì§„ ì•¡ì„¸ì„œë¦¬ë¥¼ êµ¬ë§¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤',
                            value: 'shop_category_accessory',
                            emoji: 'ğŸ’'
                        }
                    ];
                    
                    const categorySelectMenu = new StringSelectMenuBuilder()
                        .setCustomId('shop_category_select')
                        .setPlaceholder('ğŸ›ï¸ êµ¬ë§¤í•  ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•˜ì„¸ìš”')
                        .addOptions(categoryOptions);
                    
                    const shopSelectRow = new ActionRowBuilder().addComponents(categorySelectMenu);
                    
                    const backButton = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('back_to_game_menu')
                                .setLabel('ğŸ® ê²Œì„ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸°')
                                .setStyle(ButtonStyle.Secondary)
                        );
                    
                    return await interaction.editReply({ 
                        embeds: [shopEmbed], 
                        components: [shopSelectRow, backButton] 
                    });
                    
                case 'stocks':
                    // ê¸°ì¡´ ì£¼ì‹ ë¡œì§ í˜¸ì¶œ
                    // interactionì´ ì´ë¯¸ deferë˜ì—ˆìœ¼ë¯€ë¡œ deferReply ì œê±°
                    
                    const stockEmbed = new EmbedBuilder()
                        .setColor('#4169e1')
                        .setTitle('ğŸ“ˆ í™˜ìƒ ì°¨ì› ì£¼ì‹ê±°ë˜ì†Œ')
                        .setDescription('í™˜ìƒì ì¸ ìˆ˜ìµì„ ìœ„í•œ ì°¨ì›ê°„ íˆ¬ì!')
                        .setFooter({ text: 'íˆ¬ìì—ëŠ” ìœ„í—˜ì´ ë”°ë¦…ë‹ˆë‹¤. ì‹ ì¤‘í•˜ê²Œ ê²°ì •í•˜ì„¸ìš”!' });
                    
                    const stockButtons1 = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('stock_regions')
                                .setLabel('ğŸŒ ì§€ì—­ë³„ ê¸°ì—…')
                                .setStyle(ButtonStyle.Primary),
                            new ButtonBuilder()
                                .setCustomId('stock_chains')
                                .setLabel('ğŸ¢ ì²´ì¸ ê¸°ì—…')
                                .setStyle(ButtonStyle.Primary),
                            new ButtonBuilder()
                                .setCustomId('stock_portfolio')
                                .setLabel('ğŸ’¼ ë‚´ í¬íŠ¸í´ë¦¬ì˜¤')
                                .setStyle(ButtonStyle.Success)
                        );
                    
                    const stockButtons2 = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('stock_news')
                                .setLabel('ğŸ“° ì‹œì¥ ë‰´ìŠ¤')
                                .setStyle(ButtonStyle.Secondary),
                            new ButtonBuilder()
                                .setCustomId('stock_chart')
                                .setLabel('ğŸ“Š ì‹¤ì‹œê°„ ì°¨íŠ¸')
                                .setStyle(ButtonStyle.Success),
                            new ButtonBuilder()
                                .setCustomId('stock_analysis')
                                .setLabel('ğŸ” ì‹œì¥ ë¶„ì„')
                                .setStyle(ButtonStyle.Secondary)
                        );
                    
                    return await interaction.editReply({ 
                        embeds: [stockEmbed], 
                        components: [stockButtons1, stockButtons2] 
                    });
                    
                case 'artifacts':
                    // ê¸°ì¡´ ìœ ë¬¼íƒì‚¬ ë¡œì§ í˜¸ì¶œ
                    // interactionì´ ì´ë¯¸ deferë˜ì—ˆìœ¼ë¯€ë¡œ deferReply ì œê±°
                    
                    const artifactEmbed = new EmbedBuilder()
                        .setColor('#daa520')
                        .setTitle('ğŸº ìœ ë¬¼ íƒì‚¬ ì„¼í„°')
                        .setDescription('ê³ ëŒ€ì˜ ë³´ë¬¼ì„ ì°¾ì•„ ë¶€ë¥¼ ì¶•ì í•˜ì„¸ìš”!')
                        .setFooter({ text: 'íƒì‚¬ì—ëŠ” ìœ„í—˜ì´ ë”°ë¥´ì§€ë§Œ, ê·¸ë§Œí¼ í° ë³´ìƒì´ ê¸°ë‹¤ë¦½ë‹ˆë‹¤!' });
                    
                    const menuButtons = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('artifact_direct_explore')
                                .setLabel('â›ï¸ ì§ì ‘ íƒì‚¬')
                                .setStyle(ButtonStyle.Primary),
                            new ButtonBuilder()
                                .setCustomId('artifact_companies')
                                .setLabel('ğŸ¢ íƒì‚¬íšŒì‚¬ íˆ¬ì')
                                .setStyle(ButtonStyle.Secondary),
                            new ButtonBuilder()
                                .setCustomId('artifact_inventory')
                                .setLabel('ğŸ’ ìœ ë¬¼ ë³´ê´€í•¨')
                                .setStyle(ButtonStyle.Secondary),
                            new ButtonBuilder()
                                .setCustomId('artifact_shop')
                                .setLabel('ğŸª ìœ ë¬¼ ìƒì ')
                                .setStyle(ButtonStyle.Success)
                        );
                    
                    const extraButtons = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('artifact_rankings')
                                .setLabel('ğŸ† íƒì‚¬ê°€ ë­í‚¹')
                                .setStyle(ButtonStyle.Secondary),
                            new ButtonBuilder()
                                .setCustomId('artifact_guide')
                                .setLabel('ğŸ“– íƒì‚¬ ê°€ì´ë“œ')
                                .setStyle(ButtonStyle.Secondary),
                            new ButtonBuilder()
                                .setCustomId('artifact_market_chart')
                                .setLabel('ğŸ“ˆ ìœ ë¬¼ ì‹œì¥ ì°¨íŠ¸')
                                .setStyle(ButtonStyle.Success)
                        );
                    
                    return await interaction.editReply({ 
                        embeds: [artifactEmbed], 
                        components: [menuButtons, extraButtons] 
                    });
                    
                case 'daily':
                    // ì¼ì¼ë³´ìƒ ë²„íŠ¼ í•¸ë“¤ëŸ¬ë¡œ ì´ë™ (ë£°ë › ì‹œìŠ¤í…œ)
                    // ë²„íŠ¼ í´ë¦­ì„ ì‹œë®¬ë ˆì´ì…˜í•˜ì—¬ ë™ì¼í•œ í•¸ë“¤ëŸ¬ í˜¸ì¶œ
                    interaction.customId = 'daily';
                    // ë‘ ë²ˆì§¸ í•¸ë“¤ëŸ¬ì—ì„œ ì²˜ë¦¬ë˜ë„ë¡ í•¨
                    return;
                    
                case 'profile':
                    // ê¸°ì¡´ í”„ë¡œí•„ ë¡œì§ í˜¸ì¶œ
                    await interaction.deferReply({ flags: 64 });
                    
                    const profileUser = await getUser(interaction.user.id);
                    if (!profileUser || !profileUser.registered) {
                        return await interaction.editReply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!' });
                    }
                    
                    const maxExp = profileUser.level * 100;
                    const profileEmbed = new EmbedBuilder()
                        .setColor('#9932cc')
                        .setTitle('ğŸ‘¤ ë‚´ ì •ë³´')
                        .setDescription(`**${profileUser.nickname}**ë‹˜ì˜ ê²Œì„ ì •ë³´`)
                        .addFields(
                            { name: 'ë ˆë²¨', value: `Lv.${profileUser.level}`, inline: true },
                            { name: 'ê²½í—˜ì¹˜', value: `${profileUser.exp}/${maxExp} EXP`, inline: true },
                            { name: 'ê³¨ë“œ', value: `${profileUser.gold.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true },
                            { name: 'âš”ï¸ ê³µê²©ë ¥', value: `${profileUser.stats?.strength || 10}`, inline: true },
                            { name: 'ğŸ›¡ï¸ ë°©ì–´ë ¥', value: `${profileUser.stats?.vitality || 10}`, inline: true },
                            { name: 'ğŸ’¨ íšŒí”¼ë ¥', value: `${profileUser.stats?.agility || 10}`, inline: true },
                            { name: 'ğŸ€ í–‰ìš´', value: `${profileUser.stats?.luck || 10}`, inline: true },
                            { name: 'ğŸ“Š ë‚¨ì€ í¬ì¸íŠ¸', value: `${profileUser.statPoints}`, inline: true },
                            { name: 'ì¸ê¸°ë„', value: `${profileUser.popularity} ${profileUser.popularity > 0 ? 'â¤ï¸' : profileUser.popularity < 0 ? 'ğŸ’”' : ''}`, inline: true },
                            { name: 'ì¶œì„ ì—°ì†ì¼', value: `${profileUser.attendanceStreak}ì¼`, inline: true },
                            { name: 'í•´ì œëœ ì‚¬ëƒ¥í„°', value: `${profileUser.unlockedAreas.length}ê°œ`, inline: true }
                        );
                    
                    const profileButtons = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('back_to_game_menu')
                                .setLabel('ğŸ® ê²Œì„ ë©”ë‰´')
                                .setStyle(ButtonStyle.Secondary)
                        );
                    
                    return await interaction.editReply({ embeds: [profileEmbed], components: [profileButtons] });
                    
                case 'work':
                    // ìš´ë™í•˜ê¸° ì‹œìŠ¤í…œ
                    await interaction.deferReply({ flags: 64 });
                    
                    const exerciseUser = await getUser(interaction.user.id);
                    if (!exerciseUser || !exerciseUser.registered) {
                        return await interaction.editReply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!' });
                    }
                    
                    // í”¼íŠ¸ë‹ˆìŠ¤ ì´ˆê¸°í™”
                    if (!exerciseUser.fitness) {
                        exerciseUser.fitness = {
                            level: 1,
                            exp: 0,
                            totalExerciseTime: 0,
                            lastExercise: null,
                            streak: 0,
                            fatigue: 0,
                            stats: {
                                strength: 1,
                                stamina: 1,
                                flexibility: 1,
                                agility: 1,
                                mental: 1
                            },
                            equipment: {
                                clothes: 'basic',
                                shoes: 'basic'
                            },
                            activeSupplements: [],
                            exerciseHistory: []
                        };
                        await exerciseUser.save();
                    }
                    
                    // í”¼ë¡œë„ ì—…ë°ì´íŠ¸
                    updateFatigue(exerciseUser);
                    
                    // ì˜¤ëŠ˜ ìš´ë™ ì‹œê°„ í™•ì¸
                    const todayExerciseTime = getTodayExerciseTime(exerciseUser);
                    const todayMinutes = Math.floor(todayExerciseTime / 60000);
                    
                    // í˜„ì¬ ë ˆë²¨ í‹°ì–´ í™•ì¸
                    let currentTier = null;
                    for (const [level, tier] of Object.entries(EXERCISE_SYSTEM.levelTiers)) {
                        if (exerciseUser.fitness.level >= parseInt(level)) {
                            currentTier = tier;
                        }
                    }
                    
                    const exerciseEmbed = new EmbedBuilder()
                        .setColor('#00ff7f')
                        .setTitle('ğŸƒ ìš´ë™í•˜ê¸°')
                        .setDescription(`**${currentTier.emoji} ${currentTier.name}** Lv.${exerciseUser.fitness.level}\n\nì˜¤ëŠ˜ ìš´ë™ ì‹œê°„: ${todayMinutes}ë¶„`)
                        .addFields(
                            { name: 'ğŸ’ª ê·¼ë ¥', value: `${exerciseUser.fitness.stats.strength}`, inline: true },
                            { name: 'ğŸƒ ì²´ë ¥', value: `${exerciseUser.fitness.stats.stamina}`, inline: true },
                            { name: 'ğŸ§˜ ìœ ì—°ì„±', value: `${exerciseUser.fitness.stats.flexibility}`, inline: true },
                            { name: 'âš¡ ë¯¼ì²©', value: `${exerciseUser.fitness.stats.agility}`, inline: true },
                            { name: 'ğŸ§  ì •ì‹ ë ¥', value: `${exerciseUser.fitness.stats.mental}`, inline: true },
                            { name: 'ğŸ˜« í”¼ë¡œë„', value: `${exerciseUser.fitness.fatigue}/${EXERCISE_SYSTEM.fatigue.maxFatigue}`, inline: true }
                        );
                    
                    // ìš´ë™ ì¢…ë¥˜ ë“œë¡­ë‹¤ìš´
                    const exerciseOptions = [];
                    
                    // ê¸°ë³¸ ìš´ë™
                    Object.values(EXERCISE_SYSTEM.exercises)
                        .filter(ex => ex.category === 'basic')
                        .forEach(ex => {
                            exerciseOptions.push({
                                label: `${ex.emoji} ${ex.name}`,
                                description: ex.description,
                                value: ex.id,
                                emoji: ex.emoji
                            });
                        });
                    
                    // í—¬ìŠ¤ì¥ ìš´ë™ (ì¼ì¼ ì´ìš©ê¶Œ í™•ì¸)
                    const hasGymPass = exerciseUser.inventory?.some(item => item.name === 'í—¬ìŠ¤ì¥ ì¼ì¼ ì´ìš©ê¶Œ') || false;
                    Object.values(EXERCISE_SYSTEM.exercises)
                        .filter(ex => ex.category === 'gym')
                        .forEach(ex => {
                            exerciseOptions.push({
                                label: `${ex.emoji} ${ex.name} ${!hasGymPass ? '(ì´ìš©ê¶Œ í•„ìš”)' : ''}`,
                                description: ex.description,
                                value: ex.id,
                                emoji: ex.emoji
                            });
                        });
                    
                    const exerciseSelectMenu = new StringSelectMenuBuilder()
                        .setCustomId('exercise_select')
                        .setPlaceholder('ğŸƒ ìš´ë™ì„ ì„ íƒí•˜ì„¸ìš”')
                        .addOptions(exerciseOptions);
                    
                    const exerciseSelectRow = new ActionRowBuilder().addComponents(exerciseSelectMenu);
                    
                    const buttonRow = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('exercise_status')
                                .setLabel('ğŸ“Š ìš´ë™ í˜„í™©')
                                .setStyle(ButtonStyle.Secondary),
                            new ButtonBuilder()
                                .setCustomId('exercise_shop')
                                .setLabel('ğŸ›’ ìš´ë™ ìš©í’ˆì ')
                                .setStyle(ButtonStyle.Secondary),
                            new ButtonBuilder()
                                .setCustomId('exercise_ranking')
                                .setLabel('ğŸ† í”¼íŠ¸ë‹ˆìŠ¤ ë­í‚¹')
                                .setStyle(ButtonStyle.Secondary),
                            new ButtonBuilder()
                                .setCustomId('back_to_game_menu')
                                .setLabel('ğŸ® ê²Œì„ ë©”ë‰´')
                                .setStyle(ButtonStyle.Success)
                        );
                    
                    return await interaction.editReply({ 
                        embeds: [exerciseEmbed], 
                        components: [exerciseSelectRow, buttonRow] 
                    });
                    
                case 'quest':
                    // ëœë¤ ì˜ë¢° ê¸°ëŠ¥
                    await interaction.deferReply({ flags: 64 });
                    
                    const questUser = await getUser(interaction.user.id);
                    if (!questUser || !questUser.registered) {
                        return await interaction.editReply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!' });
                    }
                    
                    // ì¿¨íƒ€ì„ ì²´í¬
                    const cooldownMinutes = checkQuestCooldown(interaction.user.id);
                    if (cooldownMinutes) {
                        await interaction.editReply({ 
                            content: `â° ì˜ë¢° ì¿¨íƒ€ì„ì´ **${cooldownMinutes}ë¶„** ë‚¨ì•˜ìŠµë‹ˆë‹¤!` 
                        });
                        return;
                    }
                    
                    // ëœë¤ ì˜ë¢° ì„ íƒ
                    const quest = getRandomQuest();
                    
                    const questEmbed = new EmbedBuilder()
                        .setColor('#f39c12')
                        .setTitle(`${quest.emoji} ${quest.title}`)
                        .setDescription(`**${quest.name}**\n\n"${quest.description}"`)
                        .setFooter({ text: 'ì˜ë¢°ë¥¼ ìˆ˜ë½í•˜ì‹œê² ìŠµë‹ˆê¹Œ?' });

                    if (quest.type === 'scam') {
                        questEmbed.setColor('#e74c3c');
                    }

                    const questButtons = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId(`accept_quest_${quest.id}`)
                                .setLabel('âœ… ìˆ˜ë½')
                                .setStyle(ButtonStyle.Success),
                            new ButtonBuilder()
                                .setCustomId('decline_quest')
                                .setLabel('âŒ ê±°ì ˆ')
                                .setStyle(ButtonStyle.Danger)
                        );

                    await interaction.editReply({ 
                        embeds: [questEmbed], 
                        components: [questButtons]
                    });
                    return;
                    
                case 'pvp':
                    // PVP ë©”ë‰´
                    await interaction.deferReply({ flags: 64 });
                    
                    const pvpUser = await getUser(interaction.user.id);
                    if (!pvpUser || !pvpUser.registered) {
                        return await interaction.editReply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!' });
                    }
                    
                    const pvpEmbed = new EmbedBuilder()
                        .setColor('#ff0000')
                        .setTitle('âš”ï¸ PVP ëŒ€ì „ì¥')
                        .setDescription('ë‹¤ë¥¸ í”Œë ˆì´ì–´ì™€ ì‹¤ë ¥ì„ ê²¨ë¤„ë³´ì„¸ìš”!')
                        .addFields(
                            { name: 'ğŸ–ï¸ ë‚˜ì˜ ë ˆì´íŒ…', value: `${pvpUser.pvp?.rating || 1000}ì `, inline: true },
                            { name: 'ğŸ… í‹°ì–´', value: pvpUser.pvp?.tier || 'Bronze', inline: true },
                            { name: 'ğŸ« ê²°íˆ¬ê¶Œ', value: `${pvpUser.pvp?.duelTickets || 20}ê°œ`, inline: true }
                        );
                    
                    const pvpButtons = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('pvp_matchmaking')
                                .setLabel('âš”ï¸ ëŒ€ì „ ì‹œì‘')
                                .setStyle(ButtonStyle.Danger),
                            new ButtonBuilder()
                                .setCustomId('pvp_enhance')
                                .setLabel('ğŸ’ ê³µê²© ê°•í™”')
                                .setStyle(ButtonStyle.Success),
                            new ButtonBuilder()
                                .setCustomId('pvp_ranking')
                                .setLabel('ğŸ† PVP ë­í‚¹')
                                .setStyle(ButtonStyle.Secondary),
                            new ButtonBuilder()
                                .setCustomId('pvp_info')
                                .setLabel('ğŸ“– PVP ì •ë³´')
                                .setStyle(ButtonStyle.Secondary)
                        );
                    
                    return await interaction.editReply({ embeds: [pvpEmbed], components: [pvpButtons] });
                    
                case 'mushroom':
                    // ë…ë²„ì„¯ ê²Œì„
                    await interaction.deferReply();
                    
                    const mushroomUser = await getUser(interaction.user.id);
                    if (!mushroomUser || !mushroomUser.registered) {
                        return await interaction.editReply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!' });
                    }
                    
                    const mushroomEmbed = new EmbedBuilder()
                        .setColor('#32cd32')
                        .setTitle('ğŸ„ ë…ë²„ì„¯ ê²Œì„')
                        .setDescription('ë…ë²„ì„¯ì„ í”¼í•˜ê³  í™©ê¸ˆë²„ì„¯ì„ ì°¾ì•„ë³´ì„¸ìš”!')
                        .addFields(
                            { name: 'ğŸ® ê²Œì„ ë°©ì‹', value: 'ì—¬ëŸ¬ ë²„ì„¯ ì¤‘ ë…ë²„ì„¯ì„ í”¼í•˜ê³  í™©ê¸ˆë²„ì„¯ì„ ì°¾ìœ¼ì„¸ìš”', inline: false },
                            { name: 'ğŸ’° ë² íŒ… ê¸ˆì•¡', value: '1ë¼ìš´ë“œë‹¹ 100ê³¨ë“œ', inline: true },
                            { name: 'ğŸ† ìµœëŒ€ ë³´ìƒ', value: 'ë² íŒ…ê¸ˆì˜ 10ë°°ê¹Œì§€!', inline: true }
                        );
                    
                    const mushroomButtons = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('mushroom_solo')
                                .setLabel('ğŸ„ í˜¼ì í”Œë ˆì´')
                                .setStyle(ButtonStyle.Primary),
                            new ButtonBuilder()
                                .setCustomId('mushroom_pvp')
                                .setLabel('ğŸ‘¥ PVP ëŒ€ì „')
                                .setStyle(ButtonStyle.Danger)
                        );
                    
                    return await interaction.editReply({ embeds: [mushroomEmbed], components: [mushroomButtons] });
                    
                case 'oddeven':
                    // í™€ì§ ê²Œì„
                    await interaction.deferReply({ flags: 64 });
                    
                    const oddevenUser = await getUser(interaction.user.id);
                    if (!oddevenUser || !oddevenUser.registered) {
                        return await interaction.editReply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!' });
                    }
                    
                    const oddevenEmbed = new EmbedBuilder()
                        .setColor('#ffd700')
                        .setTitle('ğŸ² ëª¬ìŠ¤í„° í™€ì§ ëŒ€ê²°')
                        .setDescription('ëª¬ìŠ¤í„°ì™€ í™€ì§ ëŒ€ê²°ì„ í¼ì³ë³´ì„¸ìš”!')
                        .addFields(
                            { name: 'ğŸ² ê²Œì„ ë°©ì‹', value: '1-100 ì‚¬ì´ì˜ ìˆ«ìë¥¼ ë§ì¶”ì„¸ìš”', inline: false },
                            { name: 'ğŸ’° ë² íŒ… ì˜µì…˜', value: 'í™€/ì§, ëŒ€/ì†Œ, ëŸ­í‚¤7, ì­íŒŸ', inline: true },
                            { name: 'ğŸ† ìµœëŒ€ ë°°ìœ¨', value: 'ì­íŒŸ 99ë°°!', inline: true }
                        );
                    
                    const oddevenButtons = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('oddeven_play')
                                .setLabel('ğŸ² ê²Œì„ ì‹œì‘')
                                .setStyle(ButtonStyle.Success),
                            new ButtonBuilder()
                                .setCustomId('oddeven_stats')
                                .setLabel('ğŸ“Š ë‚´ ê¸°ë¡')
                                .setStyle(ButtonStyle.Secondary)
                        );
                    
                    return await interaction.editReply({ embeds: [oddevenEmbed], components: [oddevenButtons] });
                    
                case 'stats':
                    // ëŠ¥ë ¥ì¹˜
                    await interaction.deferReply({ flags: 64 });
                    
                    const statsUser = await getUser(interaction.user.id);
                    if (!statsUser || !statsUser.registered) {
                        return await interaction.editReply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!' });
                    }
                    
                    const statsEmbed = new EmbedBuilder()
                        .setColor('#ff69b4')
                        .setTitle('ğŸ’ª ëŠ¥ë ¥ì¹˜')
                        .setDescription(`**${statsUser.nickname}**ë‹˜ì˜ ëŠ¥ë ¥ì¹˜`)
                        .addFields(
                            { name: 'ğŸ’ª í˜', value: `${statsUser.stats.strength}`, inline: true },
                            { name: 'ğŸƒ ë¯¼ì²©', value: `${statsUser.stats.agility}`, inline: true },
                            { name: 'ğŸ§  ì§€ëŠ¥', value: `${statsUser.stats.intelligence}`, inline: true },
                            { name: 'â¤ï¸ ì²´ë ¥', value: `${statsUser.stats.vitality}`, inline: true },
                            { name: 'ğŸ€ í–‰ìš´', value: `${statsUser.stats.luck}`, inline: true },
                            { name: 'ğŸ“Š ì”ì—¬ í¬ì¸íŠ¸', value: `${statsUser.statPoints}`, inline: true }
                        );
                    
                    const components = [];
                    
                    // ê° ìŠ¤íƒ¯ë³„ +1, +10 ë²„íŠ¼
                    if (statsUser.statPoints > 0) {
                        // í˜ ë²„íŠ¼
                        const strengthButtons = new ActionRowBuilder()
                            .addComponents(
                                new ButtonBuilder()
                                    .setCustomId('add_strength_1')
                                    .setLabel('ğŸ’ª í˜ +1')
                                    .setStyle(ButtonStyle.Primary)
                                    .setDisabled(statsUser.statPoints < 1),
                                new ButtonBuilder()
                                    .setCustomId('add_strength_10')
                                    .setLabel('ğŸ’ª í˜ +10')
                                    .setStyle(ButtonStyle.Success)
                                    .setDisabled(statsUser.statPoints < 10)
                            );
                        
                        // ë¯¼ì²©/ì§€ëŠ¥ ë²„íŠ¼
                        const agilityIntButtons = new ActionRowBuilder()
                            .addComponents(
                                new ButtonBuilder()
                                    .setCustomId('add_agility_1')
                                    .setLabel('ğŸƒ ë¯¼ì²© +1')
                                    .setStyle(ButtonStyle.Primary)
                                    .setDisabled(statsUser.statPoints < 1),
                                new ButtonBuilder()
                                    .setCustomId('add_agility_10')
                                    .setLabel('ğŸƒ ë¯¼ì²© +10')
                                    .setStyle(ButtonStyle.Success)
                                    .setDisabled(statsUser.statPoints < 10),
                                new ButtonBuilder()
                                    .setCustomId('add_intelligence_1')
                                    .setLabel('ğŸ§  ì§€ëŠ¥ +1')
                                    .setStyle(ButtonStyle.Primary)
                                    .setDisabled(statsUser.statPoints < 1),
                                new ButtonBuilder()
                                    .setCustomId('add_intelligence_10')
                                    .setLabel('ğŸ§  ì§€ëŠ¥ +10')
                                    .setStyle(ButtonStyle.Success)
                                    .setDisabled(statsUser.statPoints < 10)
                            );
                        
                        // ì²´ë ¥/í–‰ìš´ ë²„íŠ¼
                        const vitalityLuckButtons = new ActionRowBuilder()
                            .addComponents(
                                new ButtonBuilder()
                                    .setCustomId('add_vitality_1')
                                    .setLabel('â¤ï¸ ì²´ë ¥ +1')
                                    .setStyle(ButtonStyle.Primary)
                                    .setDisabled(statsUser.statPoints < 1),
                                new ButtonBuilder()
                                    .setCustomId('add_vitality_10')
                                    .setLabel('â¤ï¸ ì²´ë ¥ +10')
                                    .setStyle(ButtonStyle.Success)
                                    .setDisabled(statsUser.statPoints < 10),
                                new ButtonBuilder()
                                    .setCustomId('add_luck_1')
                                    .setLabel('ğŸ€ í–‰ìš´ +1')
                                    .setStyle(ButtonStyle.Primary)
                                    .setDisabled(statsUser.statPoints < 1),
                                new ButtonBuilder()
                                    .setCustomId('add_luck_10')
                                    .setLabel('ğŸ€ í–‰ìš´ +10')
                                    .setStyle(ButtonStyle.Success)
                                    .setDisabled(statsUser.statPoints < 10)
                            );
                        
                        components.push(strengthButtons, agilityIntButtons, vitalityLuckButtons);
                    }
                    
                    // ê¸°íƒ€ ë²„íŠ¼
                    const otherButtons = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('stat_reset')
                                .setLabel('ğŸ”„ ìŠ¤íƒ¯ ì´ˆê¸°í™”')
                                .setStyle(ButtonStyle.Danger),
                            new ButtonBuilder()
                                .setCustomId('back_to_game_menu')
                                .setLabel('ğŸ® ê²Œì„ ë©”ë‰´')
                                .setStyle(ButtonStyle.Secondary)
                        );
                    
                    components.push(otherButtons);
                    
                    return await interaction.editReply({ embeds: [statsEmbed], components });
                    
                case 'skills':
                    // ìŠ¤í‚¬
                    await interaction.deferReply({ flags: 64 });
                    
                    const skillsUser = await getUser(interaction.user.id);
                    if (!skillsUser || !skillsUser.registered) {
                        return await interaction.editReply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!' });
                    }
                    
                    const skillsEmbed = new EmbedBuilder()
                        .setColor('#9370db')
                        .setTitle('ğŸ”® ìŠ¤í‚¬ ì‹œìŠ¤í…œ')
                        .setDescription('ìŠ¤í‚¬ ì‹œìŠ¤í…œì€ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤!\nê³§ ë‹¤ì–‘í•œ ìŠ¤í‚¬ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                    
                    return await interaction.editReply({ embeds: [skillsEmbed] });
                    
                case 'inventory':
                    // ì¸ë²¤í† ë¦¬ë¥¼ ë“œë¡­ë‹¤ìš´ìœ¼ë¡œ ë³€ê²½
                    await interaction.deferReply({ flags: 64 });
                    
                    const invUser = await getUser(interaction.user.id);
                    if (!invUser || !invUser.registered) {
                        return await interaction.editReply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!' });
                    }
                    
                    const inventoryEmbed = new EmbedBuilder()
                        .setColor('#8a2be2')
                        .setTitle('ğŸ’ ì¸ë²¤í† ë¦¬')
                        .setDescription(`ë³´ìœ ì¤‘ì¸ ì•„ì´í…œì„ í™•ì¸í•˜ì„¸ìš”\n\nğŸ”„ ìŠ¬ë¡¯: ${invUser.inventory.length}/${invUser.maxInventorySlots}`)
                        .setFooter({ text: 'ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•˜ì—¬ ì•„ì´í…œì„ í™•ì¸í•˜ì„¸ìš”' });
                    
                    // ì¸ë²¤í† ë¦¬ ì¹´í…Œê³ ë¦¬ ë³„ ì•„ì´í…œ ìˆ˜ ê³„ì‚°
                    const categoryCounts = {
                        weapon: 0,
                        armor: 0,
                        helmet: 0,
                        gloves: 0,
                        boots: 0,
                        accessory: 0,
                        consumable: 0,
                        coin: 0,
                        scroll: 0
                    };
                    
                    invUser.inventory.forEach(item => {
                        if (categoryCounts[item.type] !== undefined) {
                            categoryCounts[item.type]++;
                        }
                    });
                    
                    // ì¸ë²¤í† ë¦¬ ì¹´í…Œê³ ë¦¬ ë“œë¡­ë‹¤ìš´
                    const invOptions = [
                        {
                            label: `âš”ï¸ ë¬´ê¸° (${categoryCounts.weapon}ê°œ)`,
                            description: 'ë³´ìœ í•œ ë¬´ê¸°ë¥¼ í™•ì¸í•©ë‹ˆë‹¤',
                            value: 'inv_weapon',
                            emoji: 'âš”ï¸'
                        },
                        {
                            label: `ğŸ›¡ï¸ ê°‘ì˜· (${categoryCounts.armor}ê°œ)`,
                            description: 'ë³´ìœ í•œ ê°‘ì˜·ì„ í™•ì¸í•©ë‹ˆë‹¤',
                            value: 'inv_armor',
                            emoji: 'ğŸ›¡ï¸'
                        },
                        {
                            label: `â›‘ï¸ í—¬ë©§ (${categoryCounts.helmet}ê°œ)`,
                            description: 'ë³´ìœ í•œ í—¬ë©‡ì„ í™•ì¸í•©ë‹ˆë‹¤',
                            value: 'inv_helmet',
                            emoji: 'â›‘ï¸'
                        },
                        {
                            label: `ğŸ§¬ ì¥ê°‘ (${categoryCounts.gloves}ê°œ)`,
                            description: 'ë³´ìœ í•œ ì¥ê°‘ì„ í™•ì¸í•©ë‹ˆë‹¤',
                            value: 'inv_gloves',
                            emoji: 'ğŸ§¬'
                        },
                        {
                            label: `ğŸ‘¢ ë¶€ì¸  (${categoryCounts.boots}ê°œ)`,
                            description: 'ë³´ìœ í•œ ë¶€ì¸ ë¥¼ í™•ì¸í•©ë‹ˆë‹¤',
                            value: 'inv_boots',
                            emoji: 'ğŸ‘¢'
                        },
                        {
                            label: `ğŸ’ ì•¡ì„¸ì„œë¦¬ (${categoryCounts.accessory}ê°œ)`,
                            description: 'ë³´ìœ í•œ ì•¡ì„¸ì„œë¦¬ë¥¼ í™•ì¸í•©ë‹ˆë‹¤',
                            value: 'inv_accessory',
                            emoji: 'ğŸ’'
                        },
                        {
                            label: `ğŸ“œ ì£¼ë¬¸ì„œ (${categoryCounts.scroll}ê°œ)`,
                            description: 'ë³´ìœ í•œ ì£¼ë¬¸ì„œë¥¼ í™•ì¸í•©ë‹ˆë‹¤',
                            value: 'inv_scroll',
                            emoji: 'ğŸ“œ'
                        },
                        {
                            label: `ğŸ§ª ì†Œë¹„ (${categoryCounts.consumable}ê°œ)`,
                            description: 'ë³´ìœ í•œ ì†Œë¹„ ì•„ì´í…œì„ í™•ì¸í•©ë‹ˆë‹¤',
                            value: 'inv_consumable',
                            emoji: 'ğŸ§ª'
                        },
                        {
                            label: `ğŸª™ ì½”ì¸ (${categoryCounts.coin}ê°œ)`,
                            description: 'ë³´ìœ í•œ ì½”ì¸ì„ í™•ì¸í•©ë‹ˆë‹¤',
                            value: 'inv_coin',
                            emoji: 'ğŸª™'
                        }
                    ];
                    
                    const invSelectMenu = new StringSelectMenuBuilder()
                        .setCustomId('inventory_category_select')
                        .setPlaceholder('ğŸ“¦ í™•ì¸í•  ì•„ì´í…œ ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•˜ì„¸ìš”')
                        .addOptions(invOptions);
                    
                    const invSelectRow = new ActionRowBuilder().addComponents(invSelectMenu);
                    
                    const invButtons = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('inventory_sort')
                                .setLabel('ğŸ”„ ì •ë ¬')
                                .setStyle(ButtonStyle.Secondary),
                            new ButtonBuilder()
                                .setCustomId('inventory_sell')
                                .setLabel('ğŸ’° íŒë§¤')
                                .setStyle(ButtonStyle.Danger),
                            new ButtonBuilder()
                                .setCustomId('back_to_game_menu')
                                .setLabel('ğŸ® ê²Œì„ ë©”ë‰´')
                                .setStyle(ButtonStyle.Secondary)
                        );
                    
                    return await interaction.editReply({ 
                        embeds: [inventoryEmbed], 
                        components: [invSelectRow, invButtons] 
                    });
                    
                case 'enhancement':
                    // ì¥ë¹„ ê°•í™”
                    await interaction.deferReply({ flags: 64 });
                    
                    const enhanceUser = await getUser(interaction.user.id);
                    if (!enhanceUser || !enhanceUser.registered) {
                        return await interaction.editReply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!' });
                    }
                    
                    const enhanceMenuEmbed = new EmbedBuilder()
                        .setColor('#ffd700')
                        .setTitle('ğŸ’ ì¥ë¹„ ê°•í™”ì†Œ')
                        .setDescription('ì¥ë¹„ë¥¼ ê°•í™”í•˜ì—¬ ë”ìš± ê°•ë ¥í•´ì§€ì„¸ìš”!')
                        .addFields(
                            { name: 'âš”ï¸ ì¥ë¹„ ê°•í™”', value: 'ì¥ë¹„ì˜ ëŠ¥ë ¥ì¹˜ë¥¼ í–¥ìƒì‹œí‚µë‹ˆë‹¤', inline: true },
                            { name: 'ğŸ”„ ë³´í˜¸ê¶Œ ë³€í™˜', value: 'íŒŒê´´ ë°©ì§€ë¥¼ ìœ„í•œ ë³´í˜¸ê¶Œ', inline: true }
                        );
                    
                    const enhanceMenuButtons = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('enhance')
                                .setLabel('âš”ï¸ ì¥ë¹„ ê°•í™”')
                                .setStyle(ButtonStyle.Primary),
                            new ButtonBuilder()
                                .setCustomId('protection_scroll')
                                .setLabel('ğŸ”„ ë³´í˜¸ê¶Œ ë³€í™˜')
                                .setStyle(ButtonStyle.Secondary)
                        );
                    
                    return await interaction.editReply({ embeds: [enhanceMenuEmbed], components: [enhanceMenuButtons] });
                    
                case 'fusion':
                    // ì¡°ê° ìœµí•©
                    await interaction.deferReply({ flags: 64 });
                    
                    const fusionUser = await getUser(interaction.user.id);
                    if (!fusionUser || !fusionUser.registered) {
                        return await interaction.editReply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!' });
                    }
                    
                    if (fusionUser.level < 10) {
                        return await interaction.editReply({ content: 'âš ï¸ ì¡°ê° ìœµí•©ì€ ë ˆë²¨ 10ë¶€í„° ê°€ëŠ¥í•©ë‹ˆë‹¤!' });
                    }
                    
                    const fusionEmbed = new EmbedBuilder()
                        .setColor('#ff1493')
                        .setTitle('âš¡ ì—ë„ˆì§€ ìœµí•© ì‹œìŠ¤í…œ')
                        .setDescription('ì—ë„ˆì§€ ì¡°ê°ì„ ìœµí•©í•˜ì—¬ ë” ë†’ì€ ë“±ê¸‰ì˜ ì¡°ê°ì„ ë§Œë“¤ì–´ë³´ì„¸ìš”!');
                    
                    const fusionButtons = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('energy_mine')
                                .setLabel('â›ï¸ ì—ë„ˆì§€ ì±„êµ´')
                                .setStyle(ButtonStyle.Primary),
                            new ButtonBuilder()
                                .setCustomId('energy_fusion')
                                .setLabel('âœ¨ ì—ë„ˆì§€ ìœµí•©')
                                .setStyle(ButtonStyle.Success),
                            new ButtonBuilder()
                                .setCustomId('fusion_ranking')
                                .setLabel('ğŸ† ìœµí•© ë­í‚¹')
                                .setStyle(ButtonStyle.Secondary)
                        );
                    
                    return await interaction.editReply({ embeds: [fusionEmbed], components: [fusionButtons] });
                    
                case 'racing':
                    // ë ˆì´ì‹± ê²Œì„
                    await interaction.deferReply({ flags: 64 });
                    
                    const racingUser = await getUser(interaction.user.id);
                    if (!racingUser || !racingUser.registered) {
                        return await interaction.editReply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!' });
                    }
                    
                    const raceStatus = raceSystem.getRaceStatus();
                    
                    let statusText = `**ğŸ ì™„ì „ ìš´ë¹¨ ë ˆì´ì‹±! ğŸ²**\n\n`;
                    statusText += `ğŸ’° **í˜„ì¬ ìƒê¸ˆí’€**: ${raceStatus.totalPot.toLocaleString()}<:currency_emoji:1377404064316522778>\n`;
                    statusText += `ğŸ‘¥ **ì°¸ê°€ì**: ${raceStatus.playerCount}/${raceSystem.maxPlayers}ëª…\n\n`;
                    
                    if (raceStatus.isRacing) {
                        statusText += `ğŸƒâ€â™‚ï¸ **ë ˆì´ìŠ¤ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤!**\nì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.`;
                    } else if (raceStatus.playerCount === 0) {
                        statusText += `ğŸ¯ **ëŒ€ê¸° ì¤‘ì¸ ì°¸ê°€ìê°€ ì—†ìŠµë‹ˆë‹¤.**\nì²« ë²ˆì§¸ ì°¸ê°€ìê°€ ë˜ì–´ë³´ì„¸ìš”!`;
                    } else {
                        statusText += `â° **${raceStatus.playerCount >= raceSystem.minPlayers ? 'ê³³ ì‹œì‘ë©ë‹ˆë‹¤!' : `ìµœì†Œ ${raceSystem.minPlayers}ëª… í•„ìš”`}**\n`;
                    }
                    
                    const racingEmbed = new EmbedBuilder()
                        .setColor('#00ff00')
                        .setTitle('ğŸ ê²½ë§ˆ ë ˆì´ì‹±')
                        .setDescription(statusText)
                        .addFields(
                            { name: 'ğŸ² ê²Œì„ ë°©ì‹', value: 'ì˜¨ì „íˆ ìš´ì— ë‹¬ë¦° ê²½ë§ˆ ê²Œì„', inline: true },
                            { name: 'ğŸ’° ìµœì†Œ ë² íŒ…', value: '100 ê³¨ë“œ', inline: true },
                            { name: 'ğŸ† ìš°ìŠ¹ ìƒê¸ˆ', value: 'ì „ì²´ ìƒê¸ˆí’€ì˜ 80%', inline: true }
                        );
                    
                    const racingButtons = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('join_race')
                                .setLabel('ğŸ ë ˆì´ìŠ¤ ì°¸ê°€')
                                .setStyle(ButtonStyle.Success)
                                .setDisabled(raceStatus.isRacing),
                            new ButtonBuilder()
                                .setCustomId('race_status')
                                .setLabel('ğŸ“Š í˜„í™© ë³´ê¸°')
                                .setStyle(ButtonStyle.Secondary),
                            new ButtonBuilder()
                                .setCustomId('racing_ranking')
                                .setLabel('ğŸ† ë ˆì´ì‹± ë­í‚¹')
                                .setStyle(ButtonStyle.Primary),
                            new ButtonBuilder()
                                .setCustomId('back_to_game_menu')
                                .setLabel('ğŸ® ê²Œì„ ë©”ë‰´')
                                .setStyle(ButtonStyle.Secondary)
                        );
                    
                    return await interaction.editReply({ embeds: [racingEmbed], components: [racingButtons] });
                    
                case 'auction':
                    // ê²½ë§¤ì¥
                    await interaction.deferReply();
                    
                    const auctionEmbed = new EmbedBuilder()
                        .setColor('#ffd700')
                        .setTitle('ğŸ›ï¸ ê¹€í—Œí„° ê²½ë§¤ì¥')
                        .setDescription('ì•„ì´í…œì„ ì‚¬ê³ íŒ” ìˆ˜ ìˆëŠ” ê²½ë§¤ì¥ì…ë‹ˆë‹¤!')
                        .addFields(
                            { name: 'ğŸ“Š í˜„ì¬ ë“±ë¡ëœ ë§¤ë¬¼', value: `${AUCTION_HOUSE.listings.size}ê°œ`, inline: true },
                            { name: 'ğŸ’° 24ì‹œê°„ ê±°ë˜ëŸ‰', value: 'ì¤€ë¹„ì¤‘', inline: true },
                            { name: 'ğŸ”¥ ì¸ê¸° ì•„ì´í…œ', value: AUCTION_HOUSE.topItems.length > 0 ? AUCTION_HOUSE.topItems[0] : 'ì—†ìŒ', inline: true }
                        );
                    
                    const auctionButtons1 = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('auction_browse')
                                .setLabel('ğŸ” ê²½ë§¤ ë‘˜ëŸ¬ë³´ê¸°')
                                .setStyle(ButtonStyle.Primary),
                            new ButtonBuilder()
                                .setCustomId('auction_sell')
                                .setLabel('ğŸ’° ì•„ì´í…œ íŒë§¤')
                                .setStyle(ButtonStyle.Success),
                            new ButtonBuilder()
                                .setCustomId('auction_my_listings')
                                .setLabel('ğŸ“‹ ë‚´ ê²½ë§¤')
                                .setStyle(ButtonStyle.Secondary)
                        );
                    
                    const auctionButtons2 = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('auction_market_price')
                                .setLabel('ğŸ“ˆ ì‹œì„¸ ì¡°íšŒ')
                                .setStyle(ButtonStyle.Secondary),
                            new ButtonBuilder()
                                .setCustomId('auction_hot_items')
                                .setLabel('ğŸ”¥ ì¸ê¸° ì•„ì´í…œ')
                                .setStyle(ButtonStyle.Danger),
                            new ButtonBuilder()
                                .setCustomId('auction_trade_history')
                                .setLabel('ğŸ“Š ê±°ë˜ ë‚´ì—­')
                                .setStyle(ButtonStyle.Secondary)
                        );
                    
                    return await interaction.editReply({ embeds: [auctionEmbed], components: [auctionButtons1, auctionButtons2] });
                    
                case 'ranking':
                    // ë­í‚¹
                    // interactionì´ ì´ë¯¸ deferë˜ì—ˆìœ¼ë¯€ë¡œ deferReply ì œê±°
                    
                    const rankingEmbed = new EmbedBuilder()
                        .setColor('#ff4500')
                        .setTitle('ğŸ† ê¹€í—Œí„° ë­í‚¹')
                        .setDescription('ë‹¤ì–‘í•œ ë¶„ì•¼ì˜ ìµœê°•ìë“¤ì„ í™•ì¸í•˜ì„¸ìš”!');
                    
                    const rankingButtons1 = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('ranking_level')
                                .setLabel('ğŸ“Š ë ˆë²¨ ë­í‚¹')
                                .setStyle(ButtonStyle.Primary),
                            new ButtonBuilder()
                                .setCustomId('ranking_gold')
                                .setLabel('ğŸ’° ì¬ì‚° ë­í‚¹')
                                .setStyle(ButtonStyle.Success),
                            new ButtonBuilder()
                                .setCustomId('ranking_popularity')
                                .setLabel('â¤ï¸ ì¸ê¸°ë„ ë­í‚¹')
                                .setStyle(ButtonStyle.Danger)
                        );
                    
                    const rankingButtons2 = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('ranking_pvp')
                                .setLabel('âš”ï¸ PVP ë­í‚¹')
                                .setStyle(ButtonStyle.Danger),
                            new ButtonBuilder()
                                .setCustomId('ranking_racing')
                                .setLabel('ğŸ ë ˆì´ì‹± ë­í‚¹')
                                .setStyle(ButtonStyle.Secondary),
                            new ButtonBuilder()
                                .setCustomId('ranking_energy')
                                .setLabel('âœ¨ ìœµí•© ë­í‚¹')
                                .setStyle(ButtonStyle.Secondary)
                        );
                    
                    return await interaction.editReply({ embeds: [rankingEmbed], components: [rankingButtons1, rankingButtons2] });
                    
                case 'emblem':
                    // ì— ë¸”ëŸ¼ ì‹œìŠ¤í…œ
                    // interactionì´ ì´ë¯¸ deferë˜ì—ˆìœ¼ë¯€ë¡œ deferReply ì œê±°
                    
                    if (!user || !user.registered) {
                        return await interaction.editReply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!' });
                    }
                    
                    if (user.level < 20) {
                        return await interaction.editReply({ content: 'âš ï¸ ì— ë¸”ëŸ¼ì€ ë ˆë²¨ 20ë¶€í„° ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤!' });
                    }
                    
                    if (user.emblem) {
                        const emblemEmbed = new EmbedBuilder()
                            .setColor('#ff6b6b')
                            .setTitle('ğŸ† ë‚´ ì— ë¸”ëŸ¼')
                            .setDescription(`í˜„ì¬ ì— ë¸”ëŸ¼: **${user.emblem}**\n\nâš ï¸ ì— ë¸”ëŸ¼ì€ í•œ ë²ˆ ì„ íƒí•˜ë©´ ë³€ê²½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤!`)
                            .setFooter({ text: 'ì— ë¸”ëŸ¼ì€ ë‹¹ì‹ ì˜ ì •ì²´ì„±ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤!' });
                        
                        return await interaction.editReply({ embeds: [emblemEmbed] });
                    }
                    
                    // ì— ë¸”ëŸ¼ ìƒì  í‘œì‹œ
                    const emblemEmbed = new EmbedBuilder()
                        .setColor('#ff6b6b')
                        .setTitle('ğŸ† ì— ë¸”ëŸ¼ ìƒì ')
                        .setDescription('**ë ˆë²¨ 20 ì´ìƒ**ë¶€í„° ì— ë¸”ëŸ¼ì„ êµ¬ë§¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!\n\nì— ë¸”ëŸ¼ì„ êµ¬ë§¤í•˜ë©´ íŠ¹ë³„í•œ ì¹­í˜¸ ì—­í• ì„ ë°›ê²Œ ë©ë‹ˆë‹¤.\n**âš ï¸ ì— ë¸”ëŸ¼ì€ í•œ ë²ˆ êµ¬ë§¤í•˜ë©´ ë³€ê²½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤!**')
                        .addFields(
                            { name: 'âš”ï¸ ì „ì‚¬ ê³„ì—´', value: 'ì´ˆë³´ì „ì‚¬ â†’ íŠ¼íŠ¼í•œ ê¸°ì‚¬ â†’ ìš©ë§¹í•œ ê²€ì‚¬ â†’ ë§¹ë ¹í•œ ì „ì‚¬ â†’ ì „ì„¤ì˜ ê¸°ì‚¬', inline: false },
                            { name: 'ğŸ¹ ê¶ìˆ˜ ê³„ì—´', value: 'ë§ˆì„ì‚¬ëƒ¥ê¾¼ â†’ ìˆ²ì˜ ê¶ìˆ˜ â†’ ë°”ëŒ ì‚¬ìˆ˜ â†’ ì •í™•í•œ ì‚¬ê²©ìˆ˜ â†’ ì „ì„¤ì˜ ëª…ê¶', inline: false },
                            { name: 'ğŸ”® ë§ˆê²€ì‚¬ ê³„ì—´', value: 'ë§ˆë²• í•™ë„ â†’ ë§ˆë²• ê²€ì‚¬ â†’ í˜„ëª…í•œ ê¸°ì‚¬ â†’ ë§ˆë„ ê²€ì‚¬ â†’ ì „ì„¤ì˜ ë§ˆê²€ì‚¬', inline: false },
                            { name: 'ğŸ—¡ï¸ ë„ì  ê³„ì—´', value: 'ë– ëŒì´ ë„ì  â†’ ìš´ ì¢‹ì€ ë„ë‘‘ â†’ í–‰ìš´ì˜ ë‹Œì â†’ ë³µ ë§ì€ ë„ì  â†’ ì „ì„¤ì˜ í–‰ìš´ì•„', inline: false }
                        )
                        .setFooter({ text: 'ì›í•˜ëŠ” ê³„ì—´ì„ ì„ íƒí•˜ì—¬ ì— ë¸”ëŸ¼ì„ êµ¬ë§¤í•˜ì„¸ìš”!' });
                    
                    const emblemSelect = new ActionRowBuilder()
                        .addComponents(
                            new StringSelectMenuBuilder()
                                .setCustomId('emblem_category')
                                .setPlaceholder('ì— ë¸”ëŸ¼ ê³„ì—´ì„ ì„ íƒí•˜ì„¸ìš”')
                                .addOptions([
                                    {
                                        label: 'ì „ì‚¬ ê³„ì—´',
                                        description: 'ì´ˆë³´ì „ì‚¬ë¶€í„° ì „ì„¤ì˜ ê¸°ì‚¬ê¹Œì§€',
                                        value: 'warrior',
                                        emoji: 'âš”ï¸'
                                    },
                                    {
                                        label: 'ê¶ìˆ˜ ê³„ì—´',
                                        description: 'ë§ˆì„ì‚¬ëƒ¥ê¾¼ë¶€í„° ì „ì„¤ì˜ ëª…ê¶ê¹Œì§€',
                                        value: 'archer',
                                        emoji: 'ğŸ¹'
                                    },
                                    {
                                        label: 'ë§ˆê²€ì‚¬ ê³„ì—´',
                                        description: 'ë§ˆë²• í•™ë„ë¶€í„° ì „ì„¤ì˜ ë§ˆê²€ì‚¬ê¹Œì§€',
                                        value: 'mageknight',
                                        emoji: 'ğŸ”®'
                                    },
                                    {
                                        label: 'ë„ì  ê³„ì—´',
                                        description: 'ë– ëŒì´ ë„ì ë¶€í„° ì „ì„¤ì˜ í–‰ìš´ì•„ê¹Œì§€',
                                        value: 'thief',
                                        emoji: 'ğŸ—¡ï¸'
                                    }
                                ])
                        );
                    
                    return await interaction.editReply({ embeds: [emblemEmbed], components: [emblemSelect] });
                    
                case 'settings':
                    await interaction.reply({
                        content: 'âš™ï¸ ë©”ë‰´ ì„¤ì •',
                        components: [new ActionRowBuilder().addComponents(createMenuCustomizer())],
                        flags: 64
                    });
                    return;
                    
                case 'enhancement':
                    // ì¥ë¹„ ê°•í™”
                    // interactionì´ ì´ë¯¸ deferë˜ì—ˆìœ¼ë¯€ë¡œ deferReply ì œê±°
                    
                    if (!user || !user.registered) {
                        return await interaction.editReply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!' });
                    }
                    
                    const enhEmbed = new EmbedBuilder()
                        .setColor('#ff69b4')
                        .setTitle('ğŸ’ ì¥ë¹„ ê°•í™”')
                        .setDescription('ì¥ë¹„ë¥¼ ê°•í™”í•˜ì—¬ ë” ê°•ë ¥í•˜ê²Œ ë§Œë“œì„¸ìš”!')
                        .addFields(
                            { name: 'ğŸ’° ë³´ìœ  ê³¨ë“œ', value: `${user.gold.toLocaleString()}G`, inline: true },
                            { name: 'ğŸ›¡ï¸ ë³´í˜¸ê¶Œ', value: `${user.protectionScrolls || 0}ê°œ`, inline: true },
                            { name: 'ğŸ“Š ê°•í™” í†µê³„', value: `ì„±ê³µ: ${user.enhanceStats?.successCount || 0}íšŒ\níŒŒê´´: ${user.enhanceStats?.destroyCount || 0}íšŒ`, inline: true }
                        );
                    
                    const enhButtons = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('enhance_select_item')
                                .setLabel('âš”ï¸ ì¥ë¹„ ì„ íƒ')
                                .setStyle(ButtonStyle.Primary),
                            new ButtonBuilder()
                                .setCustomId('enhance_buy_protection')
                                .setLabel('ğŸ›¡ï¸ ë³´í˜¸ê¶Œ êµ¬ë§¤')
                                .setStyle(ButtonStyle.Success),
                            new ButtonBuilder()
                                .setCustomId('enhance_ranking')
                                .setLabel('ğŸ† ê°•í™” ë­í‚¹')
                                .setStyle(ButtonStyle.Secondary),
                            new ButtonBuilder()
                                .setCustomId('enhance_info')
                                .setLabel('ğŸ“– ê°•í™” ì •ë³´')
                                .setStyle(ButtonStyle.Secondary)
                        );
                    
                    return await interaction.editReply({ embeds: [enhEmbed], components: [enhButtons] });
                    
                case 'admin_panel':
                    await interaction.reply({
                        content: 'ğŸ› ï¸ ê´€ë¦¬ì íŒ¨ë„ì— ì ‘ê·¼í•©ë‹ˆë‹¤.',
                        components: [new ActionRowBuilder().addComponents(createAdminPanel())],
                        flags: 64
                    });
                    return;
                    
                default:
                    await interaction.reply({ 
                        content: `âŒ ì•Œ ìˆ˜ ì—†ëŠ” ë©”ë‰´: ${selectedValue}`, 
                        flags: 64 
                    });
            }
        }
        
        // ì¥ë¹„ ì„ íƒ ë“œë¡­ë‹¤ìš´ ì²˜ë¦¬
        else if (customId === 'equipment_select') {
            const slotType = values[0].replace('equip_', '');
            await interaction.deferReply({ flags: 64 });
            
            const user = await getUser(interaction.user.id);
            const itemsPerPage = 5;
            
            // í•´ë‹¹ íƒ€ì…ì˜ ì•„ì´í…œë§Œ í•„í„°ë§
            const availableItems = user.inventory.filter(item => 
                item.type === slotType && !item.equipped
            );
            
            if (availableItems.length === 0) {
                return await interaction.editReply({ 
                    content: `âŒ ì¥ì°© ê°€ëŠ¥í•œ ${slotType} ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤!` 
                });
            }
            
            // í˜„ì¬ ì¥ì°©ëœ ì•„ì´í…œ ì¶”ê°€
            const currentSlotIndex = user.equipment[slotType];
            if (currentSlotIndex !== -1) {
                const currentEquipped = user.inventory.find(item => 
                    item.inventorySlot === currentSlotIndex
                );
                if (currentEquipped) {
                    availableItems.unshift({
                        ...currentEquipped,
                        name: `[ì¥ì°©ì¤‘] ${currentEquipped.name}`
                    });
                }
            }
            
            // ì•„ì´í…œ ì˜µì…˜ ìƒì„± (ìµœëŒ€ 25ê°œê¹Œì§€ë§Œ)
            const itemOptions = availableItems.slice(0, 25).map((item, index) => {
                const enhanceText = item.enhanceLevel > 0 ? ` (+${item.enhanceLevel})` : '';
                // statsê°€ ê°ì²´ í˜•íƒœì¼ ê²½ìš° ì²˜ë¦¬
                let statsText = '';
                if (item.stats) {
                    const attack = item.stats.attack || 0;
                    const defense = item.stats.defense || 0;
                    const dodge = item.stats.dodge || 0;
                    const luck = item.stats.luck || 0;
                    
                    const statParts = [];
                    if (attack > 0) statParts.push(`ê³µê²©ë ¥: +${attack}`);
                    if (defense > 0) statParts.push(`ë°©ì–´ë ¥: +${defense}`);
                    if (dodge > 0) statParts.push(`íšŒí”¼ë ¥: +${dodge}`);
                    if (luck > 0) statParts.push(`í–‰ìš´: +${luck}`);
                    
                    statsText = statParts.join(', ') || 'ê¸°ë³¸ ìŠ¤íƒ¯';
                }
                
                return {
                    label: `${item.name}${enhanceText}`,
                    description: statsText.substring(0, 50),
                    value: `equip_item_${slotType}_${index}_${item.inventorySlot}`,
                    emoji: getRarityEmoji(item.rarity)
                };
            });
            
            // ì¥ì°© í•´ì œ ì˜µì…˜ ì¶”ê°€
            if (currentSlotIndex !== -1) {
                itemOptions.push({
                    label: 'ğŸš« ì¥ì°© í•´ì œ',
                    description: 'í˜„ì¬ ì¥ì°©ëœ ì•„ì´í…œì„ í•´ì œí•©ë‹ˆë‹¤',
                    value: `unequip_${slotType}`,
                    emoji: 'ğŸš«'
                });
            }
            
            const equipItemMenu = new StringSelectMenuBuilder()
                .setCustomId('equip_item_select')
                .setPlaceholder('ğŸ® ì¥ì°©í•  ì•„ì´í…œì„ ì„ íƒí•˜ì„¸ìš”')
                .addOptions(itemOptions);
            
            const selectRow = new ActionRowBuilder().addComponents(equipItemMenu);
            
            const backButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('equipment')
                        .setLabel('ğŸ”™ ì¥ë¹„ ê´€ë¦¬')
                        .setStyle(ButtonStyle.Primary)
                );
            
            const itemListEmbed = new EmbedBuilder()
                .setColor('#ffaa00')
                .setTitle(`${getRarityEmoji(slotType)} ${slotType} ì¥ì°©`)
                .setDescription(`ì¥ì°©í•  ì•„ì´í…œì„ ì„ íƒí•˜ì„¸ìš”\n\nğŸ“¦ ì‚¬ìš© ê°€ëŠ¥í•œ ì•„ì´í…œ: ${availableItems.length}ê°œ`);
            
            await interaction.editReply({
                embeds: [itemListEmbed],
                components: [selectRow, backButton]
            });
        }
        
        // ê°•í™”í•  ì¥ë¹„ ì„ íƒ ì²˜ë¦¬
        else if (customId === 'enhance_select') {
            const value = values[0];
            const parts = value.split('_');
            const inventorySlot = parseInt(parts[2]); // enhance_item_inventorySlot_timestamp_indexì—ì„œ inventorySlot ì¶”ì¶œ
            
            await interaction.deferReply({ flags: 64 });
            
            const user = await getUser(interaction.user.id);
            const item = user.inventory.find(inv => inv.inventorySlot === inventorySlot && inv.equipped);
            
            if (!item) {
                return await interaction.editReply({ content: 'í•´ë‹¹ ì¥ë¹„ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!' });
            }
            
            const itemLevel = ITEM_LEVELS[item.setName] || ITEM_LEVELS[item.name] || 1;
            const currentStar = item.enhanceLevel || 0;
            const cost = calculateEnhanceCost(itemLevel, currentStar);
            
            if (user.gold < cost) {
                return await interaction.editReply({ content: `âŒ ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤! í•„ìš” ê³¨ë“œ: ${cost.toLocaleString()}G` });
            }
            
            // ê°•í™” ì‹¤í–‰
            user.gold -= cost;
            const success = Math.random() < calculateSuccessRate(currentStar);
            
            if (success) {
                item.enhanceLevel = (item.enhanceLevel || 0) + 1;
                user.enhanceStats = user.enhanceStats || { successCount: 0, failCount: 0 };
                user.enhanceStats.successCount++;
                
                await user.save();
                
                const successEmbed = new EmbedBuilder()
                    .setColor('#00ff00')
                    .setTitle('âœ¨ ê°•í™” ì„±ê³µ!')
                    .setDescription(`${item.name}ì´(ê°€) **+${item.enhanceLevel}ê°•**ìœ¼ë¡œ ê°•í™”ë˜ì—ˆìŠµë‹ˆë‹¤!`)
                    .addFields(
                        { name: 'ğŸ’° ì†Œëª¨ ê³¨ë“œ', value: `${cost.toLocaleString()}G`, inline: true },
                        { name: 'ğŸ’° ë‚¨ì€ ê³¨ë“œ', value: `${user.gold.toLocaleString()}G`, inline: true }
                    );
                
                await interaction.editReply({ embeds: [successEmbed] });
            } else {
                // ê°•í™” ì‹¤íŒ¨ ì²˜ë¦¬
                user.enhanceStats = user.enhanceStats || { successCount: 0, failCount: 0 };
                user.enhanceStats.failCount++;
                
                if (currentStar >= 10) {
                    // 10ê°• ì´ìƒì€ íŒŒê´´ í™•ë¥ 
                    const destroyChance = (currentStar - 9) * 0.05;
                    if (Math.random() < destroyChance) {
                        // ì•„ì´í…œ íŒŒê´´
                        const itemIndex = user.inventory.findIndex(inv => inv.id === itemId);
                        user.inventory.splice(itemIndex, 1);
                        user.equipment[item.type] = -1;
                        
                        await user.save();
                        
                        const destroyEmbed = new EmbedBuilder()
                            .setColor('#ff0000')
                            .setTitle('ğŸ’¥ ì•„ì´í…œ íŒŒê´´!')
                            .setDescription(`ê°•í™”ì— ì‹¤íŒ¨í•˜ì—¬ ${item.name}ì´(ê°€) íŒŒê´´ë˜ì—ˆìŠµë‹ˆë‹¤...`)
                            .addFields(
                                { name: 'ğŸ’° ì†Œëª¨ ê³¨ë“œ', value: `${cost.toLocaleString()}G`, inline: true },
                                { name: 'ğŸ’° ë‚¨ì€ ê³¨ë“œ', value: `${user.gold.toLocaleString()}G`, inline: true }
                            );
                        
                        return await interaction.editReply({ embeds: [destroyEmbed] });
                    }
                }
                
                // ê°•í™” ë ˆë²¨ í•˜ë½
                if (item.enhanceLevel > 0) {
                    item.enhanceLevel--;
                }
                
                await user.save();
                
                const failEmbed = new EmbedBuilder()
                    .setColor('#ff0000')
                    .setTitle('âŒ ê°•í™” ì‹¤íŒ¨!')
                    .setDescription(`ê°•í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ${item.name}ì´(ê°€) **+${item.enhanceLevel}ê°•**ìœ¼ë¡œ í•˜ë½í–ˆìŠµë‹ˆë‹¤.`)
                    .addFields(
                        { name: 'ğŸ’° ì†Œëª¨ ê³¨ë“œ', value: `${cost.toLocaleString()}G`, inline: true },
                        { name: 'ğŸ’° ë‚¨ì€ ê³¨ë“œ', value: `${user.gold.toLocaleString()}G`, inline: true }
                    );
                
                await interaction.editReply({ embeds: [failEmbed] });
            }
        }
        
        // ë³´ìŠ¤ ë„ì „í•˜ê¸° ë²„íŠ¼ ì²˜ë¦¬
        else if (customId === 'boss_challenge') {
            const boss = BOSS_SYSTEM.activeBoss;
            if (!boss) {
                await interaction.reply({ content: 'âŒ í˜„ì¬ í™œì„±í™”ëœ ë³´ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            const user = await getUser(interaction.user.id);
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            if (user.level < boss.requiredLevel) {
                await interaction.reply({ 
                    content: `âŒ ë ˆë²¨ì´ ë¶€ì¡±í•©ë‹ˆë‹¤! (í•„ìš” ë ˆë²¨: ${boss.requiredLevel}, í˜„ì¬ ë ˆë²¨: ${user.level})`, 
                    flags: 64 
                });
                return;
            }
            
            // ì„œë²„ ë©¤ë²„ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
            const guild = interaction.guild;
            const members = await guild.members.fetch();
            const validMembers = members.filter(member => 
                !member.user.bot && 
                member.user.id !== interaction.user.id
            ).map(member => ({
                label: member.displayName,
                description: `@${member.user.username}`,
                value: member.user.id
            })).slice(0, 25); // Discord ì œí•œ
            
            if (validMembers.length === 0) {
                BOSS_SYSTEM.participants.add(interaction.user.id);
                await interaction.reply({
                    content: `âš”ï¸ **${user.nickname}**ë‹˜ì´ ë³´ìŠ¤ ë ˆì´ë“œì— ì°¸ê°€í–ˆìŠµë‹ˆë‹¤!\nì´ˆëŒ€í•  ë©¤ë²„ê°€ ì—†ì–´ í˜¼ì ë„ì „í•©ë‹ˆë‹¤!`,
                    flags: 64
                });
                return;
            }
            
            const selectMenu = new StringSelectMenuBuilder()
                .setCustomId('boss_party_invite')
                .setPlaceholder('ğŸ¯ ì´ˆëŒ€í•  íŒŒí‹°ì›ì„ ì„ íƒí•˜ì„¸ìš” (ìµœëŒ€ 10ëª…)')
                .setMinValues(0)
                .setMaxValues(Math.min(validMembers.length, 10))
                .addOptions(validMembers);
            
            const row = new ActionRowBuilder().addComponents(selectMenu);
            
            await interaction.reply({
                content: 'ğŸ¯ ë³´ìŠ¤ ë ˆì´ë“œì— ì´ˆëŒ€í•  íŒŒí‹°ì›ì„ ì„ íƒí•˜ì„¸ìš”!',
                components: [row],
                flags: 64
            });
        }
        
        // ë³´ìŠ¤ ì •ë³´ ë²„íŠ¼ ì²˜ë¦¬
        else if (customId === 'boss_info') {
            const boss = BOSS_SYSTEM.activeBoss;
            if (!boss) {
                await interaction.reply({ content: 'âŒ í˜„ì¬ í™œì„±í™”ëœ ë³´ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            const remainingTime = Math.max(0, boss.endTime - Date.now());
            const minutes = Math.floor(remainingTime / 60000);
            const seconds = Math.floor((remainingTime % 60000) / 1000);
            
            const infoEmbed = new EmbedBuilder()
                .setColor('#ff0000')
                .setTitle(`${boss.emoji} ${boss.name} ì •ë³´`)
                .setDescription(`ë ˆë²¨ ${boss.level} ë³´ìŠ¤`)
                .addFields(
                    { name: 'â¤ï¸ ì²´ë ¥', value: `${boss.currentHp.toLocaleString()} / ${boss.hp.toLocaleString()}`, inline: true },
                    { name: 'âš”ï¸ ê³µê²©ë ¥', value: `${boss.attack}`, inline: true },
                    { name: 'ğŸ›¡ï¸ ë°©ì–´ë ¥', value: `${boss.defense}`, inline: true },
                    { name: 'ğŸ’° ê³¨ë“œ ë³´ìƒ', value: `${boss.rewards.gold.toLocaleString()}G`, inline: true },
                    { name: 'âœ¨ ê²½í—˜ì¹˜ ë³´ìƒ', value: `${boss.rewards.exp.toLocaleString()} EXP`, inline: true },
                    { name: 'â° ë‚¨ì€ ì‹œê°„', value: `${minutes}ë¶„ ${seconds}ì´ˆ`, inline: true }
                )
                .setFooter({ text: `í˜„ì¬ ${BOSS_SYSTEM.participants.size}ëª… ì°¸ê°€ì¤‘` });
            
            // ìŠ¤í‚¬ ì •ë³´ ì¶”ê°€
            if (boss.skills && boss.skills.length > 0) {
                const skillText = boss.skills.map(skill => 
                    `â€¢ **${skill.name}**: ${skill.damage ? `ë°ë¯¸ì§€ ${skill.damage}` : skill.effect}`
                ).join('\n');
                infoEmbed.addFields({ name: 'ğŸ’« ìŠ¤í‚¬', value: skillText, inline: false });
            }
            
            // ë“œë¡­ ì•„ì´í…œ ì •ë³´
            if (boss.rewards.items && boss.rewards.items.length > 0) {
                const itemText = boss.rewards.items.map(item => {
                    const itemInfo = BOSS_SYSTEM.bossItems[item.id];
                    return `â€¢ **${itemInfo.name}** (${(item.chance * 100).toFixed(1)}%)`;
                }).join('\n');
                infoEmbed.addFields({ name: 'ğŸ ë“œë¡­ ì•„ì´í…œ', value: itemText, inline: false });
            }
            
            await interaction.reply({ embeds: [infoEmbed], flags: 64 });
        }
        
        // ë³´ìŠ¤ íŒŒí‹° ì´ˆëŒ€ ì²˜ë¦¬
        else if (customId === 'boss_party_invite') {
            await interaction.deferUpdate();
            const selectedUsers = values;
            
            // ìì‹ ì„ ì°¸ê°€ìì— ì¶”ê°€
            BOSS_SYSTEM.participants.add(interaction.user.id);
            
            // ì°¸ê°€ ë©”ì‹œì§€
            await interaction.editReply({
                content: `âš”ï¸ **${user.nickname}**ë‹˜ì´ ë³´ìŠ¤ ë ˆì´ë“œì— ì°¸ê°€í–ˆìŠµë‹ˆë‹¤!\ní˜„ì¬ ì°¸ê°€ì: ${BOSS_SYSTEM.participants.size}ëª…`,
                components: []
            });
            
            // ì±„ë„ì— ì•Œë¦¼
            const bossChannel = client.channels.cache.get(BOSS_SYSTEM.activeBoss.channelId);
            if (bossChannel) {
                await bossChannel.send(`âš”ï¸ **${user.nickname}**ë‹˜ì´ ë³´ìŠ¤ ë ˆì´ë“œì— ì°¸ê°€í–ˆìŠµë‹ˆë‹¤! (ì°¸ê°€ì: ${BOSS_SYSTEM.participants.size}ëª…)`);
            }
            
            // ì„ íƒëœ ìœ ì €ë“¤ì—ê²Œ DM ì „ì†¡
            if (selectedUsers.length > 0) {
                const boss = BOSS_SYSTEM.activeBoss;
                const inviteEmbed = new EmbedBuilder()
                    .setColor('#ff0000')
                    .setTitle('ğŸ—¡ï¸ ë³´ìŠ¤ ë ˆì´ë“œ íŒŒí‹° ì´ˆëŒ€!')
                    .setDescription(`**${user.nickname}**ë‹˜ì´ ë³´ìŠ¤ ë ˆì´ë“œì— ì´ˆëŒ€í–ˆìŠµë‹ˆë‹¤!`)
                    .addFields(
                        { name: 'ğŸ¯ ë³´ìŠ¤', value: `${boss.emoji} ${boss.name} (Lv.${boss.level})`, inline: true },
                        { name: 'â¤ï¸ HP', value: `${boss.hp.toLocaleString()}`, inline: true },
                        { name: 'â° ë‚¨ì€ ì‹œê°„', value: 'ì•½ 30ë¶„', inline: true }
                    )
                    .setFooter({ text: 'ì„œë²„ì—ì„œ ë³´ìŠ¤ ë„ì „í•˜ê¸° ë²„íŠ¼ì„ ëˆŒëŸ¬ ì°¸ê°€í•˜ì„¸ìš”!' });
                
                for (const userId of selectedUsers) {
                    try {
                        const targetUser = await client.users.fetch(userId);
                        await targetUser.send({ embeds: [inviteEmbed] });
                        console.log(`ë³´ìŠ¤ ì´ˆëŒ€ DM ì „ì†¡ ì„±ê³µ: ${targetUser.username}`);
                    } catch (error) {
                        console.error(`DM ì „ì†¡ ì‹¤íŒ¨ (${userId}):`, error);
                    }
                }
                
                await interaction.followUp({
                    content: `ğŸ“¨ ${selectedUsers.length}ëª…ì—ê²Œ ì´ˆëŒ€ ë©”ì‹œì§€ë¥¼ ì „ì†¡í–ˆìŠµë‹ˆë‹¤!`,
                    flags: 64
                });
            }
        }
        
        // ì•„ì´í…œ ì¥ì°© ì²˜ë¦¬
        else if (customId === 'equip_item_select') {
            const value = values[0];
            console.log('=== ì¥ì°© í•¸ë“¤ëŸ¬ ì§„ì… ===');
            console.log('ì„ íƒëœ value:', value);
            
            await interaction.deferReply({ flags: 64 });
            const user = await getUser(interaction.user.id);
            
            // ë°ì´í„° ë¬´ê²°ì„± ê²€ì‚¬
            await validateAndFixInventory(user);
            
            if (value.startsWith('unequip_')) {
                // ì¥ë¹„ í•´ì œ
                const slotType = value.replace('unequip_', '');
                console.log('ì¥ë¹„ í•´ì œ ì‹œë„:', slotType);
                
                const result = await unequipItem(user, slotType);
                
                if (result.success) {
                    await interaction.editReply({
                        content: `âœ… **${result.itemName}**ì„(ë¥¼) í•´ì œí–ˆìŠµë‹ˆë‹¤!`
                    });
                } else {
                    await interaction.editReply({
                        content: `âŒ ì¥ë¹„ í•´ì œ ì‹¤íŒ¨: ${result.error}`
                    });
                }
            } else if (value.startsWith('equip_item_')) {
                // ì•„ì´í…œ ì¥ì°©
                const parts = value.split('_');
                console.log('value parts:', parts);
                
                if (parts.length >= 5) {
                    const slotType = parts[2];
                    const index = parseInt(parts[3]);
                    const inventorySlot = parseInt(parts[4]);
                    
                    console.log(`ì¥ì°© ì‹œë„ - slotType: ${slotType}, index: ${index}, inventorySlot: ${inventorySlot}`);
                    
                    // inventorySlotì´ NaNì´ë©´ ì˜¤ë¥˜
                    if (isNaN(inventorySlot)) {
                        console.error('inventorySlot íŒŒì‹± ì‹¤íŒ¨:', parts[4]);
                        await interaction.editReply({
                            content: 'âŒ ì•„ì´í…œ ì •ë³´ë¥¼ í™•ì¸í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'
                        });
                        return;
                    }
                    
                    const result = await equipItem(user, slotType, inventorySlot);
                    
                    if (result.success) {
                        await interaction.editReply({
                            content: `âœ… **${result.itemName}**ì„(ë¥¼) ì¥ì°©í–ˆìŠµë‹ˆë‹¤!`
                        });
                    } else {
                        await interaction.editReply({
                            content: `âŒ ì¥ì°© ì‹¤íŒ¨: ${result.error}`
                        });
                    }
                } else {
                    console.error('ì˜ëª»ëœ value í˜•ì‹:', value);
                    await interaction.editReply({
                        content: 'âŒ ì˜ëª»ëœ ì„ íƒì…ë‹ˆë‹¤.'
                    });
                }
            }
        }
        
        // ì¸ë²¤í† ë¦¬ ì¹´í…Œê³ ë¦¬ ì„ íƒ ì²˜ë¦¬
        else if (customId === 'inventory_category_select') {
            const categoryType = values[0].replace('inv_', '');
            await interaction.deferReply({ flags: 64 });
            
            const user = await getUser(interaction.user.id);
            const itemsPerPage = 10;
            const currentPage = 0;
            
            // í•´ë‹¹ ì¹´í…Œê³ ë¦¬ì˜ ì•„ì´í…œë§Œ í•„í„°ë§
            const categoryItems = user.inventory.filter(item => item.type === categoryType);
            
            if (categoryItems.length === 0) {
                return await interaction.editReply({ 
                    content: `âŒ í•´ë‹¹ ì¹´í…Œê³ ë¦¬ì— ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤!` 
                });
            }
            
            const totalPages = Math.ceil(categoryItems.length / itemsPerPage);
            const startIndex = currentPage * itemsPerPage;
            const currentItems = categoryItems.slice(startIndex, startIndex + itemsPerPage);
            
            const categoryEmbed = new EmbedBuilder()
                .setColor('#8a2be2')
                .setTitle(`ğŸ“¦ ${categoryType} ì•„ì´í…œ ëª©ë¡`)
                .setDescription(`í˜ì´ì§€ ${currentPage + 1}/${totalPages}`);
            
            currentItems.forEach((item, index) => {
                const enhanceText = item.enhanceLevel > 0 ? ` (+${item.enhanceLevel})` : '';
                const equippedText = item.equipped ? ' [ì¥ì°©ì¤‘]' : '';
                const statsText = `ê³µê²©: ${item.stats.attack[0]}-${item.stats.attack[1]}, ë°©ì–´: ${item.stats.defense[0]}-${item.stats.defense[1]}`;
                
                categoryEmbed.addFields({
                    name: `${startIndex + index + 1}. ${item.name}${enhanceText}${equippedText}`,
                    value: `${getRarityEmoji(item.rarity)} ${item.rarity} | ${statsText}\n${item.description}`,
                    inline: false
                });
            });
            
            const navButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId(`inv_page_${categoryType}_prev`)
                        .setLabel('â—€ ì´ì „')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(currentPage === 0),
                    new ButtonBuilder()
                        .setCustomId(`inv_page_${categoryType}_${currentPage}`)
                        .setLabel(`${currentPage + 1}/${totalPages}`)
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(true),
                    new ButtonBuilder()
                        .setCustomId(`inv_page_${categoryType}_next`)
                        .setLabel('ë‹¤ìŒ â–¶')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(currentPage >= totalPages - 1),
                    new ButtonBuilder()
                        .setCustomId('inventory')
                        .setLabel('ğŸ”™ ì¸ë²¤í† ë¦¬')
                        .setStyle(ButtonStyle.Primary)
                );
            
            await interaction.editReply({
                embeds: [categoryEmbed],
                components: [navButtons]
            });
        }
        
        // ë©”ë‰´ ì»¤ìŠ¤í„°ë§ˆì´ì§• ì²˜ë¦¬
        else if (customId === 'customize_menu') {
            const selectedValue = values[0];
            
            switch (selectedValue) {
                case 'manage_favorites':
                    // ì¦ê²¨ì°¾ê¸° ê´€ë¦¬
                    const favUser = await User.findOne({ discordId: interaction.user.id });
                    const favoriteMenus = favUser?.menuSettings?.favoriteMenus || [];
                    const allCategories = Object.keys(MENU_CATEGORIES);
                    
                    const favoriteEmbed = new EmbedBuilder()
                        .setColor('#ffd700')
                        .setTitle('â­ ì¦ê²¨ì°¾ê¸° ê´€ë¦¬')
                        .setDescription('ìì£¼ ì‚¬ìš©í•˜ëŠ” ì¹´í…Œê³ ë¦¬ë¥¼ ì¦ê²¨ì°¾ê¸°ì— ì¶”ê°€í•˜ë©´ ë¹ ë¥´ê²Œ ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.')
                        .addFields(
                            { name: 'í˜„ì¬ ì¦ê²¨ì°¾ê¸°', value: favoriteMenus.length > 0 ? favoriteMenus.map(id => MENU_CATEGORIES[id]?.label || id).join(', ') : 'ì—†ìŒ', inline: false }
                        );
                    
                    const favoriteMenu = new StringSelectMenuBuilder()
                        .setCustomId('favorite_category_toggle')
                        .setPlaceholder('â­ ì¦ê²¨ì°¾ê¸°í•  ì¹´í…Œê³ ë¦¬ ì„ íƒ')
                        .addOptions(
                            allCategories.map(catId => {
                                const cat = MENU_CATEGORIES[catId];
                                const isFavorite = favoriteMenus.includes(catId);
                                return {
                                    label: `${isFavorite ? 'â­ ' : ''}${cat.label}`,
                                    description: `${cat.description} ${isFavorite ? '(ì œê±°)' : '(ì¶”ê°€)'}`,
                                    value: catId,
                                    emoji: cat.emoji
                                };
                            })
                        );
                    
                    await interaction.reply({
                        embeds: [favoriteEmbed],
                        components: [new ActionRowBuilder().addComponents(favoriteMenu)],
                        flags: 64
                    });
                    break;
                    
                case 'manage_quickslots':
                    // í€µìŠ¬ë¡¯ ì„¤ì •
                    const quickEmbed = new EmbedBuilder()
                        .setColor('#ff9800')
                        .setTitle('ğŸ¯ í€µìŠ¬ë¡¯ ì„¤ì •')
                        .setDescription('ë©”ì¸ í™”ë©´ì— í‘œì‹œë  4ê°œì˜ í€µìŠ¬ë¡¯ì„ ì„¤ì •í•˜ì„¸ìš”.')
                        .addFields(
                            { name: 'í˜„ì¬ í€µìŠ¬ë¡¯', value: 'ğŸ ì¼ì¼ë³´ìƒ | ğŸ¯ ì‚¬ëƒ¥í•˜ê¸° | âš”ï¸ ì¥ë¹„ê´€ë¦¬ | ğŸ›’ ìƒì ', inline: false }
                        );
                    
                    await interaction.reply({
                        content: 'ğŸ¯ í€µìŠ¬ë¡¯ ì„¤ì • ê¸°ëŠ¥ì€ ê³§ ì¶”ê°€ë©ë‹ˆë‹¤!',
                        embeds: [quickEmbed],
                        flags: 64
                    });
                    break;
                    
                case 'change_theme':
                    // í…Œë§ˆ ì„¤ì •
                    const themeEmbed = new EmbedBuilder()
                        .setColor('#9c27b0')
                        .setTitle('ğŸ¨ í…Œë§ˆ ì„¤ì •')
                        .setDescription('ì¸í„°í˜ì´ìŠ¤ ìƒ‰ìƒ í…Œë§ˆë¥¼ ì„ íƒí•˜ì„¸ìš”.');
                    
                    const themeButtons = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('theme_default')
                                .setLabel('ğŸŒˆ ê¸°ë³¸')
                                .setStyle(ButtonStyle.Secondary),
                            new ButtonBuilder()
                                .setCustomId('theme_dark')
                                .setLabel('ğŸŒ™ ë‹¤í¬')
                                .setStyle(ButtonStyle.Secondary),
                            new ButtonBuilder()
                                .setCustomId('theme_light')
                                .setLabel('â˜€ï¸ ë¼ì´íŠ¸')
                                .setStyle(ButtonStyle.Secondary),
                            new ButtonBuilder()
                                .setCustomId('theme_rpg')
                                .setLabel('âš”ï¸ RPG')
                                .setStyle(ButtonStyle.Primary)
                        );
                    
                    await interaction.reply({
                        embeds: [themeEmbed],
                        components: [themeButtons],
                        flags: 64
                    });
                    break;
                    
                case 'change_layout':
                    // UI ë ˆì´ì•„ì›ƒ
                    const layoutEmbed = new EmbedBuilder()
                        .setColor('#4caf50')
                        .setTitle('ğŸ“Š UI ë ˆì´ì•„ì›ƒ')
                        .setDescription('ë©”ë‰´ í‘œì‹œ ë°©ì‹ì„ ì„ íƒí•˜ì„¸ìš”.');
                    
                    const layoutButtons = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('layout_list')
                                .setLabel('ğŸ“‹ ëª©ë¡í˜•')
                                .setStyle(ButtonStyle.Secondary),
                            new ButtonBuilder()
                                .setCustomId('layout_grid')
                                .setLabel('â¬› ê·¸ë¦¬ë“œí˜•')
                                .setStyle(ButtonStyle.Secondary),
                            new ButtonBuilder()
                                .setCustomId('layout_compact')
                                .setLabel('ğŸ“¦ ê°„ì†Œí˜•')
                                .setStyle(ButtonStyle.Secondary)
                        );
                    
                    await interaction.reply({
                        embeds: [layoutEmbed],
                        components: [layoutButtons],
                        flags: 64
                    });
                    break;
                    
                case 'notification_settings':
                    // ì•Œë¦¼ ì„¤ì •
                    const notifEmbed = new EmbedBuilder()
                        .setColor('#2196f3')
                        .setTitle('ğŸ”” ì•Œë¦¼ ì„¤ì •')
                        .setDescription('ê²Œì„ ì•Œë¦¼ì„ ê´€ë¦¬í•˜ì„¸ìš”.')
                        .addFields(
                            { name: 'ğŸ ì¼ì¼ë³´ìƒ', value: 'âœ… í™œì„±í™”', inline: true },
                            { name: 'âš”ï¸ PVP ëŒ€ì „', value: 'âœ… í™œì„±í™”', inline: true },
                            { name: 'ğŸ“ˆ ì£¼ì‹ ë³€ë™', value: 'âŒ ë¹„í™œì„±í™”', inline: true },
                            { name: 'ğŸ† ë­í‚¹ ë³€ë™', value: 'âœ… í™œì„±í™”', inline: true }
                        );
                    
                    await interaction.reply({
                        embeds: [notifEmbed],
                        flags: 64
                    });
                    break;
                    
                case 'reset_settings':
                    // ì„¤ì • ì´ˆê¸°í™”
                    const confirmEmbed = new EmbedBuilder()
                        .setColor('#f44336')
                        .setTitle('â™»ï¸ ì„¤ì • ì´ˆê¸°í™”')
                        .setDescription('âš ï¸ ì •ë§ë¡œ ëª¨ë“  ì„¤ì •ì„ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?');
                    
                    const confirmButtons = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('confirm_reset_settings')
                                .setLabel('âœ… ì´ˆê¸°í™”')
                                .setStyle(ButtonStyle.Danger),
                            new ButtonBuilder()
                                .setCustomId('cancel_reset_settings')
                                .setLabel('âŒ ì·¨ì†Œ')
                                .setStyle(ButtonStyle.Secondary)
                        );
                    
                    await interaction.reply({
                        embeds: [confirmEmbed],
                        components: [confirmButtons],
                        flags: 64
                    });
                    break;
                    
                case 'reorder_menu':
                    // ë©”ë‰´ ìˆœì„œ ë³€ê²½
                    const user = await User.findOne({ discordId: interaction.user.id });
                    const currentOrder = user?.menuSettings?.menuOrder || [
                        'daily', 'work', 'quest', 
                        'hunting', 'racing', 'pvp', 'mushroom', 'oddeven',
                        'stats', 'skills', 'equipment', 'enhancement',
                        'shop', 'inventory', 'stocks', 'artifacts', 'auction',
                        'ranking', 'profile'
                    ];
                    
                    // í˜„ì¬ ìˆœì„œë¥¼ ë³´ì—¬ì£¼ëŠ” ë“œë¡­ë‹¤ìš´ ìƒì„±
                    const reorderMenu = new StringSelectMenuBuilder()
                        .setCustomId('reorder_select')
                        .setPlaceholder('ğŸ”½ ìœ„ë¡œ ì˜¬ë¦´ ë©”ë‰´ë¥¼ ì„ íƒí•˜ì„¸ìš”')
                        .addOptions(
                            currentOrder.map((menuId, index) => {
                                const menuDef = MENU_DEFINITIONS[menuId];
                                return {
                                    label: `${index + 1}. ${menuDef.label}`,
                                    description: menuDef.description,
                                    value: menuId,
                                    emoji: menuDef.emoji
                                };
                            })
                        );
                    
                    await interaction.reply({
                        content: 'ğŸ“‹ ë©”ë‰´ ìˆœì„œ ë³€ê²½ - ìœ„ë¡œ ì˜¬ë¦´ ë©”ë‰´ë¥¼ ì„ íƒí•˜ì„¸ìš”',
                        components: [new ActionRowBuilder().addComponents(reorderMenu)],
                        flags: 64
                    });
                    break;
                    
                case 'favorite_menu':
                    // ì¦ê²¨ì°¾ê¸° ì„¤ì •
                    const favUserOld = await User.findOne({ discordId: interaction.user.id });
                    const favoriteMenusOld = favUserOld?.menuSettings?.favoriteMenus || [];
                    const allMenus = Object.keys(MENU_DEFINITIONS);
                    
                    const favoriteMenuOld = new StringSelectMenuBuilder()
                        .setCustomId('favorite_toggle')
                        .setPlaceholder('â­ ì¦ê²¨ì°¾ê¸° ì¶”ê°€/ì œê±°í•  ë©”ë‰´ ì„ íƒ')
                        .addOptions(
                            allMenus.map(menuId => {
                                const menuDef = MENU_DEFINITIONS[menuId];
                                const isFavorite = favoriteMenusOld.includes(menuId);
                                return {
                                    label: `${isFavorite ? 'â­ ' : ''}${menuDef.label}`,
                                    description: `${menuDef.description} ${isFavorite ? '(ì¦ê²¨ì°¾ê¸° í•´ì œ)' : '(ì¦ê²¨ì°¾ê¸° ì¶”ê°€)'}`,
                                    value: menuId,
                                    emoji: menuDef.emoji
                                };
                            })
                        );
                    
                    await interaction.reply({
                        content: 'â­ ì¦ê²¨ì°¾ê¸° ë©”ë‰´ ì„¤ì •',
                        components: [new ActionRowBuilder().addComponents(favoriteMenuOld)],
                        flags: 64
                    });
                    break;
                    
                case 'toggle_menu':
                    // ë©”ë‰´ ìˆ¨ê¸°ê¸°/ë³´ì´ê¸°
                    const hideUser = await User.findOne({ discordId: interaction.user.id });
                    const hiddenMenus = hideUser?.menuSettings?.hiddenMenus || [];
                    const visibleMenus = Object.keys(MENU_DEFINITIONS);
                    
                    const toggleMenu = new StringSelectMenuBuilder()
                        .setCustomId('hide_toggle')
                        .setPlaceholder('ğŸ‘ï¸ ìˆ¨ê¸°ê¸°/ë³´ì´ê¸°í•  ë©”ë‰´ ì„ íƒ')
                        .addOptions(
                            visibleMenus.map(menuId => {
                                const menuDef = MENU_DEFINITIONS[menuId];
                                const isHidden = hiddenMenus.includes(menuId);
                                return {
                                    label: `${isHidden ? 'ğŸš« ' : 'ğŸ‘ï¸ '}${menuDef.label}`,
                                    description: `${menuDef.description} ${isHidden ? '(ìˆ¨ê¹€ â†’ ë³´ì´ê¸°)' : '(ë³´ì´ê¸° â†’ ìˆ¨ê¹€)'}`,
                                    value: menuId,
                                    emoji: menuDef.emoji
                                };
                            })
                        );
                    
                    await interaction.reply({
                        content: 'ğŸ‘ï¸ ë©”ë‰´ ìˆ¨ê¸°ê¸°/ë³´ì´ê¸° ì„¤ì •',
                        components: [new ActionRowBuilder().addComponents(toggleMenu)],
                        flags: 64
                    });
                    break;
                    
                case 'menu_style':
                    await interaction.reply({
                        content: 'ğŸ¨ ë©”ë‰´ ìŠ¤íƒ€ì¼ ë³€ê²½ ê¸°ëŠ¥ì€ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤.',
                        flags: 64
                    });
                    break;
                    
                case 'reset_menu':
                    // ë©”ë‰´ ì„¤ì • ì´ˆê¸°í™”
                    await User.findOneAndUpdate(
                        { discordId: user.id },
                        { 
                            $unset: { 
                                'menuSettings.menuOrder': 1,
                                'menuSettings.favoriteMenus': 1,
                                'menuSettings.hiddenMenus': 1
                            }
                        }
                    );
                    await interaction.reply({
                        content: 'ğŸ”„ ë©”ë‰´ ì„¤ì •ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤!',
                        flags: 64
                    });
                    break;
            }
        }
        
        // ê´€ë¦¬ì íŒ¨ë„ ì²˜ë¦¬
        else if (customId === 'admin_panel' && isAdmin(user.id)) {
            const selectedValue = values[0];
            
            switch (selectedValue) {
                case 'admin_users':
                    await interaction.reply({
                        content: 'ğŸ‘¥ ì‚¬ìš©ì ê´€ë¦¬',
                        components: [new ActionRowBuilder().addComponents(createUserManagementMenu())],
                        flags: 64
                    });
                    break;
                    
                case 'admin_economy':
                    await interaction.reply({
                        content: 'ğŸ’° ê²½ì œ ê´€ë¦¬',
                        components: [new ActionRowBuilder().addComponents(createEconomyManagementMenu())],
                        flags: 64
                    });
                    break;
                    
                case 'admin_system':
                    await interaction.reply({
                        content: 'ğŸ”§ ì‹œìŠ¤í…œ ì œì–´',
                        components: [new ActionRowBuilder().addComponents(createSystemControlMenu())],
                        flags: 64
                    });
                    break;
                    
                case 'admin_stats':
                    await interaction.deferReply({ flags: 64 });
                    const totalUsers = await User.countDocuments();
                    const totalGold = await User.aggregate([
                        { $group: { _id: null, total: { $sum: '$gold' } } }
                    ]);
                    
                    const statsEmbed = new EmbedBuilder()
                        .setTitle('ğŸ“Š ì„œë²„ í†µê³„')
                        .addFields(
                            { name: 'ğŸ‘¥ ì´ ì‚¬ìš©ì ìˆ˜', value: totalUsers.toString(), inline: true },
                            { name: 'ğŸ’° ì´ ê³¨ë“œëŸ‰', value: (totalGold[0]?.total || 0).toLocaleString(), inline: true },
                            { name: 'ğŸ¤– ë´‡ ìƒíƒœ', value: 'ì •ìƒ ì‘ë™', inline: true }
                        )
                        .setColor('Blue');
                        
                    await interaction.editReply({ embeds: [statsEmbed] });
                    break;
                    
                default:
                    await interaction.reply({
                        content: `ğŸ”§ ${selectedValue} ê¸°ëŠ¥ì€ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤.`,
                        flags: 64
                    });
            }
        }
        
        // ë©”ë‰´ ìˆœì„œ ë³€ê²½ ì²˜ë¦¬
        else if (customId === 'reorder_select') {
            const selectedMenu = values[0];
            const user = await User.findOne({ discordId: interaction.user.id });
            const currentOrder = user?.menuSettings?.menuOrder || [
                'daily', 'work', 'quest', 
                'hunting', 'racing', 'pvp', 'mushroom', 'oddeven',
                'stats', 'skills', 'equipment', 'enhancement',
                'shop', 'inventory', 'stocks', 'artifacts', 'auction',
                'ranking', 'profile'
            ];
            
            // ì„ íƒí•œ ë©”ë‰´ë¥¼ ë§¨ ìœ„ë¡œ ì´ë™
            const newOrder = currentOrder.filter(id => id !== selectedMenu);
            newOrder.unshift(selectedMenu);
            
            await User.findOneAndUpdate(
                { discordId: interaction.user.id },
                { 'menuSettings.menuOrder': newOrder },
                { upsert: true }
            );
            
            await interaction.reply({
                content: `âœ… **${MENU_DEFINITIONS[selectedMenu].label}** ë©”ë‰´ê°€ ë§¨ ìœ„ë¡œ ì´ë™ë˜ì—ˆìŠµë‹ˆë‹¤!`,
                flags: 64
            });
        }
        
        // ì¦ê²¨ì°¾ê¸° í† ê¸€ ì²˜ë¦¬
        else if (customId === 'favorite_toggle') {
            const selectedMenu = values[0];
            const user = await User.findOne({ discordId: interaction.user.id });
            const favoriteMenus = user?.menuSettings?.favoriteMenus || [];
            
            let newFavorites;
            let message;
            
            if (favoriteMenus.includes(selectedMenu)) {
                // ì¦ê²¨ì°¾ê¸°ì—ì„œ ì œê±°
                newFavorites = favoriteMenus.filter(id => id !== selectedMenu);
                message = `â­ **${MENU_DEFINITIONS[selectedMenu].label}** ë©”ë‰´ê°€ ì¦ê²¨ì°¾ê¸°ì—ì„œ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤.`;
            } else {
                // ì¦ê²¨ì°¾ê¸°ì— ì¶”ê°€
                newFavorites = [...favoriteMenus, selectedMenu];
                message = `â­ **${MENU_DEFINITIONS[selectedMenu].label}** ë©”ë‰´ê°€ ì¦ê²¨ì°¾ê¸°ì— ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!`;
            }
            
            await User.findOneAndUpdate(
                { discordId: interaction.user.id },
                { 'menuSettings.favoriteMenus': newFavorites },
                { upsert: true }
            );
            
            await interaction.reply({
                content: message,
                flags: 64
            });
        }
        
        // ë©”ë‰´ ìˆ¨ê¹€ í† ê¸€ ì²˜ë¦¬
        else if (customId === 'hide_toggle') {
            const selectedMenu = values[0];
            const user = await User.findOne({ discordId: interaction.user.id });
            const hiddenMenus = user?.menuSettings?.hiddenMenus || [];
            
            let newHidden;
            let message;
            
            if (hiddenMenus.includes(selectedMenu)) {
                // ìˆ¨ê¹€ì—ì„œ ì œê±° (ë³´ì´ê¸°)
                newHidden = hiddenMenus.filter(id => id !== selectedMenu);
                message = `ğŸ‘ï¸ **${MENU_DEFINITIONS[selectedMenu].label}** ë©”ë‰´ê°€ ë‹¤ì‹œ í‘œì‹œë©ë‹ˆë‹¤.`;
            } else {
                // ìˆ¨ê¹€ì— ì¶”ê°€
                newHidden = [...hiddenMenus, selectedMenu];
                message = `ğŸš« **${MENU_DEFINITIONS[selectedMenu].label}** ë©”ë‰´ê°€ ìˆ¨ê²¨ì¡ŒìŠµë‹ˆë‹¤.`;
            }
            
            await User.findOneAndUpdate(
                { discordId: interaction.user.id },
                { 'menuSettings.hiddenMenus': newHidden },
                { upsert: true }
            );
            
            await interaction.reply({
                content: message,
                flags: 64
            });
        }
        
        // ìƒì  ì¹´í…Œê³ ë¦¬ ì„ íƒ ì²˜ë¦¬
        else if (customId === 'shop_category_select') {
            const selectedCategory = values[0].replace('shop_category_', '');
            const categoryData = SHOP_CATEGORIES[selectedCategory];
            
            if (!categoryData) {
                await interaction.reply({ content: 'âŒ í•´ë‹¹ ì¹´í…Œê³ ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            await interaction.deferReply({ flags: 64 });
            
            const user = await getUser(interaction.user.id);
            
            // ì¹´í…Œê³ ë¦¬ë³„ ì•„ì´í…œ ëª©ë¡ ìƒì„± (í˜ì´ì§€ 1)
            const itemsPerPage = 5;
            const currentPage = 0;
            const startIndex = currentPage * itemsPerPage;
            const endIndex = Math.min(startIndex + itemsPerPage, categoryData.items.length);
            const currentItems = categoryData.items.slice(startIndex, endIndex);
            const totalPages = Math.ceil(categoryData.items.length / itemsPerPage);
            
            // ì•„ì´í…œ ëª©ë¡ì„ ìœ„í•œ ë“œë¡­ë‹¤ìš´ ì˜µì…˜ ìƒì„±
            const itemOptions = currentItems.map((item, index) => ({
                label: `${item.name} - ${item.price.toLocaleString()}G`,
                description: `${item.rarity} | ${item.description.substring(0, 50)}...`,
                value: `buy_${selectedCategory}_${startIndex + index}`,
                emoji: getRarityEmoji(item.rarity)
            }));
            
            const itemSelectMenu = new StringSelectMenuBuilder()
                .setCustomId('shop_item_select')
                .setPlaceholder('ğŸ›ï¸ êµ¬ë§¤í•  ì•„ì´í…œì„ ì„ íƒí•˜ì„¸ìš”')
                .addOptions(itemOptions);
            
            const selectRow = new ActionRowBuilder().addComponents(itemSelectMenu);
            
            // í˜ì´ì§€ë„¤ì´ì…˜ ë²„íŠ¼
            const navButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId(`shop_page_${selectedCategory}_prev`)
                        .setLabel('â—€ ì´ì „')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(currentPage === 0),
                    new ButtonBuilder()
                        .setCustomId(`shop_page_${selectedCategory}_info`)
                        .setLabel(`${currentPage + 1}/${totalPages}`)
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(true),
                    new ButtonBuilder()
                        .setCustomId(`shop_page_${selectedCategory}_next`)
                        .setLabel('ë‹¤ìŒ â–¶')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(currentPage >= totalPages - 1),
                    new ButtonBuilder()
                        .setCustomId('shop')
                        .setLabel('ğŸ”™ ì¹´í…Œê³ ë¦¬ ì„ íƒ')
                        .setStyle(ButtonStyle.Primary)
                );
            
            const categoryEmbed = new EmbedBuilder()
                .setColor('#00ff7f')
                .setTitle(`${categoryData.emoji} ${categoryData.name} ìƒì `)
                .setDescription(`ğŸ’° ë³´ìœ  ê³¨ë“œ: ${user.gold.toLocaleString()}G\n\nêµ¬ë§¤í•  ì•„ì´í…œì„ ì„ íƒí•˜ì„¸ìš”!`)
                .setThumbnail(`attachment://${categoryData.gif}`)
                .setFooter({ text: `í˜ì´ì§€ ${currentPage + 1}/${totalPages}` });
            
            const categoryAttachment = new AttachmentBuilder(
                path.join(__dirname, 'resource', categoryData.gif), 
                { name: categoryData.gif }
            );
            
            await interaction.editReply({
                embeds: [categoryEmbed],
                components: [selectRow, navButtons],
                files: [categoryAttachment]
            });
        }
        
        // ìƒì  ì•„ì´í…œ êµ¬ë§¤ ì²˜ë¦¬
        else if (customId === 'shop_item_select') {
            const [action, category, itemIndex] = values[0].split('_');
            const categoryData = SHOP_CATEGORIES[category];
            const item = categoryData.items[parseInt(itemIndex)];
            
            if (!item) {
                await interaction.reply({ content: 'âŒ ì•„ì´í…œì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            const user = await getUser(interaction.user.id);
            
            if (user.gold < item.price) {
                await interaction.reply({ content: 'âŒ ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            // êµ¬ë§¤ í™•ì¸ ì„ë² ë“œ
            const confirmEmbed = new EmbedBuilder()
                .setColor('#00ff7f')
                .setTitle('ğŸ›’ êµ¬ë§¤ í™•ì¸')
                .setDescription(`**${item.name}**ì„(ë¥¼) êµ¬ë§¤í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)
                .addFields(
                    { name: 'ê°€ê²©', value: `${item.price.toLocaleString()}G`, inline: true },
                    { name: 'ë³´ìœ  ê³¨ë“œ', value: `${user.gold.toLocaleString()}G`, inline: true },
                    { name: 'êµ¬ë§¤ í›„ ì”ì•¡', value: `${(user.gold - item.price).toLocaleString()}G`, inline: true }
                );
            
            const confirmButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId(`confirm_buy_${category}_${itemIndex}`)
                        .setLabel('âœ… êµ¬ë§¤í•˜ê¸°')
                        .setStyle(ButtonStyle.Success),
                    new ButtonBuilder()
                        .setCustomId('cancel_buy')
                        .setLabel('âŒ ì·¨ì†Œ')
                        .setStyle(ButtonStyle.Danger)
                );
            
            await interaction.reply({
                embeds: [confirmEmbed],
                components: [confirmButtons],
                flags: 64
            });
        }
        
        // ì¥ë¹„ ì„ íƒ ë“œë¡­ë‹¤ìš´ ì²˜ë¦¬ (ì¤‘ë³µë˜ì–´ ì£¼ì„ ì²˜ë¦¬)
//         else if (customId === 'equipment_select') {
//             const selectedSlot = values[0].replace('equip_', '');
//             
//             await interaction.deferReply({ flags: 64 });
//             
//             const user = await getUser(interaction.user.id);
//             if (!user) {
//                 return await interaction.editReply({ content: 'ìœ ì € ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!' });
//             }
//             
//             // í•´ë‹¹ ìŠ¬ë¡¯ì— ì¥ì°© ê°€ëŠ¥í•œ ì•„ì´í…œ ì°¾ê¸°
//             const equipableItems = user.inventory.filter(item => item.type === selectedSlot);
//             
//             if (equipableItems.length === 0) {
//                 return await interaction.editReply({ content: `âŒ ì¥ì°© ê°€ëŠ¥í•œ ${getSlotDisplayName(selectedSlot)}ì´(ê°€) ì—†ìŠµë‹ˆë‹¤!` });
//             }
//             
//             // í˜„ì¬ ì¥ì°© ì¤‘ì¸ ì•„ì´í…œ
//             const currentEquipIndex = user.equipment[selectedSlot];
//             
//             // ì¥ì°© ê°€ëŠ¥í•œ ì•„ì´í…œ ëª©ë¡ ìƒì„±
//             const itemOptions = equipableItems.map((item, index) => {
//                 const isEquipped = item.inventorySlot === currentEquipIndex;
//                 const enhanceText = item.enhanceLevel > 0 ? ` (+${item.enhanceLevel}ê°•)` : '';
//                 const statsText = `ê³µê²©ë ¥: ${item.stats.attack[0]}-${item.stats.attack[1]}, ë°©ì–´ë ¥: ${item.stats.defense[0]}-${item.stats.defense[1]}`;
//                 
//                 return {
//                     label: `${item.name}${enhanceText} ${isEquipped ? '(ì¥ì°©ì¤‘)' : ''}`,
//                     description: statsText.substring(0, 100),
//                     value: `equip_item_${selectedSlot}_${index}_${item.inventorySlot}`,
//                     emoji: getRarityEmoji(item.rarity)
//                 };
//             });
//             
//             // ì¥ì°© í•´ì œ ì˜µì…˜ ì¶”ê°€
//             if (currentEquipIndex !== -1) {
//                 itemOptions.unshift({
//                     label: 'ğŸš« ì¥ì°© í•´ì œ',
//                     description: 'í˜„ì¬ ì¥ì°©ëœ ì•„ì´í…œì„ í•´ì œí•©ë‹ˆë‹¤',
//                     value: `unequip_${selectedSlot}`,
//                     emoji: 'ğŸš«'
//                 });
//             }
//             
//             const itemSelectMenu = new StringSelectMenuBuilder()
//                 .setCustomId('equipment_item_select')
//                 .setPlaceholder(`ğŸ® ì¥ì°©í•  ${getSlotDisplayName(selectedSlot)}ì„(ë¥¼) ì„ íƒí•˜ì„¸ìš”`)
//                 .addOptions(itemOptions.slice(0, 25)); // Discord ì œí•œ
//             
//             const selectRow = new ActionRowBuilder().addComponents(itemSelectMenu);
//             
//             const equipEmbed = new EmbedBuilder()
//                 .setColor('#ffaa00')
//                 .setTitle(`${getSlotDisplayName(selectedSlot)} ì¥ì°©`)
//                 .setDescription('ì¥ì°©í•  ì•„ì´í…œì„ ì„ íƒí•˜ì„¸ìš”');
//             
//             await interaction.editReply({ 
//                 embeds: [equipEmbed], 
//                 components: [selectRow] 
//             });
//         }
        
        // ì¥ë¹„ ì•„ì´í…œ ì„ íƒ ì²˜ë¦¬ (ì¤‘ë³µë˜ì–´ ì£¼ì„ ì²˜ë¦¬)
//         else if (customId === 'equipment_item_select') {
//             const value = values[0];
//             
//             await interaction.deferReply({ flags: 64 });
//             
//             const user = await getUser(interaction.user.id);
//             if (!user) {
//                 return await interaction.editReply({ content: 'ìœ ì € ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!' });
//             }
//             
//             if (value.startsWith('unequip_')) {
//                 // ì¥ì°© í•´ì œ
//                 const slot = value.replace('unequip_', '');
//                 user.equipment[slot] = -1;
//                 await user.save();
//                 
//                 return await interaction.editReply({ 
//                     content: `âœ… ${getSlotDisplayName(slot)} ì¥ì°©ì„ í•´ì œí–ˆìŠµë‹ˆë‹¤!`,
//                     components: [] 
//                 });
//             } else if (value.startsWith('equip_item_')) {
//                 // ì•„ì´í…œ ì¥ì°©
//                 const [, , slot, index, inventorySlot] = value.split('_');
//                 const itemIndex = parseInt(inventorySlot);
//                 
//                 // ì•„ì´í…œ í™•ì¸
//                 const item = user.inventory.find(i => i.inventorySlot === itemIndex);
//                 if (!item || item.type !== slot) {
//                     return await interaction.editReply({ content: 'âŒ ì˜ëª»ëœ ì•„ì´í…œì…ë‹ˆë‹¤!' });
//                 }
//                 
//                 // ì¥ì°©
//                 user.equipment[slot] = itemIndex;
//                 await user.save();
//                 
//                 const enhanceText = item.enhanceLevel > 0 ? ` (+${item.enhanceLevel}ê°•)` : '';
//                 return await interaction.editReply({ 
//                     content: `âœ… ${item.name}${enhanceText}ì„(ë¥¼) ì¥ì°©í–ˆìŠµë‹ˆë‹¤!`,
//                     components: [] 
//                 });
//             }
//         }
        
        // ìš´ë™ ì„ íƒ ë“œë¡­ë‹¤ìš´ ì²˜ë¦¬
        else if (customId === 'select_exercise_type') {
            const selectedValue = values[0];
            const exerciseId = selectedValue.replace('start_exercise_', '');
            const exercise = EXERCISE_SYSTEM.exercises[exerciseId];
            
            if (!exercise) {
                return await interaction.reply({ content: 'âŒ ì˜ëª»ëœ ìš´ë™ì…ë‹ˆë‹¤!', flags: 64 });
            }
            
            // Modalì„ ì‚¬ìš©í•˜ë¯€ë¡œ deferí•˜ì§€ ì•ŠìŒ
            const user = await getUser(interaction.user.id);
            if (!user) {
                return await interaction.reply({ content: 'ìœ ì € ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
            }
            
            // í”¼ë¡œë„ í™•ì¸
            const currentFatigue = user.fitness?.fatigue || 0;
            if (currentFatigue >= EXERCISE_SYSTEM.fatigue.exerciseLimit) {
                return await interaction.reply({ 
                    content: `âŒ í”¼ë¡œë„ê°€ ë„ˆë¬´ ë†’ìŠµë‹ˆë‹¤! (${currentFatigue}/${EXERCISE_SYSTEM.fatigue.maxFatigue})\nì ì‹œ íœ´ì‹ì„ ì·¨í•˜ì„¸ìš”.`,
                    flags: 64
                });
            }
            
            // ìš´ë™ ì‹œê°„ ì„ íƒ ëª¨ë‹¬ ìƒì„±
            const exerciseModal = new ModalBuilder()
                .setCustomId(`exercise_modal_${exerciseId}`)
                .setTitle(`${exercise.emoji} ${exercise.name} ì‹œì‘`);
            
            const durationInput = new TextInputBuilder()
                .setCustomId('duration')
                .setLabel('ìš´ë™ ì‹œê°„ (ë¶„)')
                .setStyle(TextInputStyle.Short)
                .setPlaceholder('1 ~ ' + Math.floor(exercise.maxDuration / 60000))
                .setRequired(true)
                .setMaxLength(3);
            
            const actionRow = new ActionRowBuilder().addComponents(durationInput);
            exerciseModal.addComponents(actionRow);
            
            await interaction.showModal(exerciseModal);
        }
        
        // ì¸ë²¤í† ë¦¬ ë“œë¡­ë‹¤ìš´ ì²˜ë¦¬
        else if (customId === 'inventory_select') {
            const action = values[0];
            
            await interaction.deferReply({ flags: 64 });
            
            const user = await getUser(interaction.user.id);
            if (!user) {
                return await interaction.editReply({ content: 'ìœ ì € ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!' });
            }
            
            if (action === 'sell_items') {
                // íŒë§¤í•  ì•„ì´í…œ ì„ íƒ
                const sellableItems = user.inventory.filter(item => {
                    // ì¥ì°© ì¤‘ì´ì§€ ì•Šì€ ì•„ì´í…œë§Œ
                    const isEquipped = Object.values(user.equipment).includes(item.inventorySlot);
                    return !isEquipped;
                });
                
                if (sellableItems.length === 0) {
                    return await interaction.editReply({ content: 'âŒ íŒë§¤ ê°€ëŠ¥í•œ ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤!' });
                }
                
                const itemOptions = sellableItems.slice(0, 25).map((item, index) => {
                    const sellPrice = Math.floor(item.price * 0.5);
                    const enhanceText = item.enhanceLevel > 0 ? ` (+${item.enhanceLevel}ê°•)` : '';
                    
                    return {
                        label: `${item.name}${enhanceText}`,
                        description: `íŒë§¤ê°€: ${sellPrice.toLocaleString()}G`,
                        value: `sell_${index}_${item.inventorySlot}`,
                        emoji: getRarityEmoji(item.rarity)
                    };
                });
                
                const sellSelectMenu = new StringSelectMenuBuilder()
                    .setCustomId('inventory_sell_select')
                    .setPlaceholder('ğŸ›ï¸ íŒë§¤í•  ì•„ì´í…œì„ ì„ íƒí•˜ì„¸ìš”')
                    .addOptions(itemOptions);
                
                const selectRow = new ActionRowBuilder().addComponents(sellSelectMenu);
                
                const sellEmbed = new EmbedBuilder()
                    .setColor('#ff6b6b')
                    .setTitle('ğŸ›ï¸ ì•„ì´í…œ íŒë§¤')
                    .setDescription('íŒë§¤í•  ì•„ì´í…œì„ ì„ íƒí•˜ì„¸ìš” (íŒë§¤ê°€ëŠ” êµ¬ë§¤ê°€ì˜ 50%)');
                
                await interaction.editReply({ 
                    embeds: [sellEmbed], 
                    components: [selectRow] 
                });
            } else if (action === 'filter_items') {
                // í•„í„° ì˜µì…˜ í‘œì‹œ
                const filterOptions = [
                    { label: 'âš”ï¸ ë¬´ê¸°ë§Œ ë³´ê¸°', value: 'filter_weapon', emoji: 'âš”ï¸' },
                    { label: 'ğŸ›¡ï¸ ê°‘ì˜·ë§Œ ë³´ê¸°', value: 'filter_armor', emoji: 'ğŸ›¡ï¸' },
                    { label: 'â›‘ï¸ í—¬ë©§ë§Œ ë³´ê¸°', value: 'filter_helmet', emoji: 'â›‘ï¸' },
                    { label: 'ğŸ§¤ ì¥ê°‘ë§Œ ë³´ê¸°', value: 'filter_gloves', emoji: 'ğŸ§¤' },
                    { label: 'ğŸ‘¢ ë¶€ì¸ ë§Œ ë³´ê¸°', value: 'filter_boots', emoji: 'ğŸ‘¢' },
                    { label: 'ğŸ’ ì•¡ì„¸ì„œë¦¬ë§Œ ë³´ê¸°', value: 'filter_accessory', emoji: 'ğŸ’' },
                    { label: 'ğŸ“‹ ì „ì²´ ë³´ê¸°', value: 'filter_all', emoji: 'ğŸ“‹' }
                ];
                
                const filterSelectMenu = new StringSelectMenuBuilder()
                    .setCustomId('inventory_filter_select')
                    .setPlaceholder('ğŸ” í•„í„°ë¥¼ ì„ íƒí•˜ì„¸ìš”')
                    .addOptions(filterOptions);
                
                const selectRow = new ActionRowBuilder().addComponents(filterSelectMenu);
                
                await interaction.editReply({ 
                    content: 'ì›í•˜ëŠ” í•„í„°ë¥¼ ì„ íƒí•˜ì„¸ìš”', 
                    components: [selectRow] 
                });
            }
        }
        
        // ì¸ë²¤í† ë¦¬ íŒë§¤ ì„ íƒ ì²˜ë¦¬
        else if (customId === 'inventory_sell_select') {
            const parts = values[0].split('_');
            const index = parseInt(parts[1]);
            const selectedSlot = parseInt(parts[2]);
            
            await interaction.deferReply({ flags: 64 });
            
            const user = await getUser(interaction.user.id);
            if (!user) {
                return await interaction.editReply({ content: 'ìœ ì € ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!' });
            }
            
            const item = user.inventory.find(i => i.inventorySlot === selectedSlot);
            if (!item) {
                return await interaction.editReply({ content: 'âŒ ì•„ì´í…œì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!' });
            }
            
            // ì¥ì°© ì¤‘ì¸ì§€ ë‹¤ì‹œ í™•ì¸
            const isEquipped = Object.values(user.equipment).includes(selectedSlot);
            if (isEquipped) {
                return await interaction.editReply({ content: 'âŒ ì¥ì°© ì¤‘ì¸ ì•„ì´í…œì€ íŒë§¤í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤!' });
            }
            
            const sellPrice = Math.floor(item.price * 0.5);
            const enhanceText = item.enhanceLevel > 0 ? ` (+${item.enhanceLevel}ê°•)` : '';
            
            // íŒë§¤ í™•ì¸ ì„ë² ë“œ
            const confirmEmbed = new EmbedBuilder()
                .setColor('#ff6b6b')
                .setTitle('ğŸ›ï¸ íŒë§¤ í™•ì¸')
                .setDescription(`**${item.name}${enhanceText}**ì„(ë¥¼) íŒë§¤í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)
                .addFields(
                    { name: 'íŒë§¤ê°€', value: `${sellPrice.toLocaleString()}G`, inline: true },
                    { name: 'í˜„ì¬ ê³¨ë“œ', value: `${user.gold.toLocaleString()}G`, inline: true },
                    { name: 'íŒë§¤ í›„ ê³¨ë“œ', value: `${(user.gold + sellPrice).toLocaleString()}G`, inline: true }
                );
            
            const confirmButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId(`confirm_sell_${selectedSlot}`)
                        .setLabel('âœ… íŒë§¤í•˜ê¸°')
                        .setStyle(ButtonStyle.Success),
                    new ButtonBuilder()
                        .setCustomId('cancel_sell')
                        .setLabel('âŒ ì·¨ì†Œ')
                        .setStyle(ButtonStyle.Danger)
                );
            
            await interaction.editReply({
                embeds: [confirmEmbed],
                components: [confirmButtons]
            });
        }
        
        // ì¸ë²¤í† ë¦¬ í•„í„° ì„ íƒ ì²˜ë¦¬
        else if (customId === 'inventory_filter_select') {
            const filterType = values[0].replace('filter_', '');
            
            await interaction.deferReply({ flags: 64 });
            
            const user = await getUser(interaction.user.id);
            if (!user) {
                return await interaction.editReply({ content: 'ìœ ì € ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!' });
            }
            
            let filteredItems = [];
            let filterName = '';
            
            if (filterType === 'all') {
                filteredItems = user.inventory;
                filterName = 'ì „ì²´ ì•„ì´í…œ';
            } else {
                filteredItems = user.inventory.filter(item => item.type === filterType);
                const typeNames = {
                    weapon: 'ë¬´ê¸°',
                    armor: 'ê°‘ì˜·',
                    helmet: 'í—¬ë©§',
                    gloves: 'ì¥ê°‘',
                    boots: 'ë¶€ì¸ ',
                    accessory: 'ì•¡ì„¸ì„œë¦¬'
                };
                filterName = typeNames[filterType] || filterType;
            }
            
            if (filteredItems.length === 0) {
                return await interaction.editReply({ content: `âŒ ${filterName} ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤!` });
            }
            
            // í˜ì´ì§€ë„¤ì´ì…˜ ì„¤ì •
            const itemsPerPage = 5;
            const totalPages = Math.ceil(filteredItems.length / itemsPerPage);
            const currentPage = 0;
            const startIndex = currentPage * itemsPerPage;
            const currentItems = filteredItems.slice(startIndex, startIndex + itemsPerPage);
            
            const filterEmbed = new EmbedBuilder()
                .setColor('#3498db')
                .setTitle(`ğŸ” ${filterName} ëª©ë¡`)
                .setDescription(`ì´ ${filteredItems.length}ê°œì˜ ${filterName}`)
                .setFooter({ text: `í˜ì´ì§€ ${currentPage + 1}/${totalPages}` });
            
            // ì•„ì´í…œ ëª©ë¡ í‘œì‹œ
            currentItems.forEach((item, index) => {
                const globalIndex = startIndex + index;
                const isEquipped = Object.values(user.equipment).includes(item.inventorySlot);
                const enhanceText = item.enhanceLevel > 0 ? ` (+${item.enhanceLevel}ê°•)` : '';
                const equippedText = isEquipped ? ' [ì¥ì°©ì¤‘]' : '';
                
                filterEmbed.addFields({
                    name: `${globalIndex + 1}. ${item.name}${enhanceText}${equippedText}`,
                    value: `${getRarityEmoji(item.rarity)} ${item.rarity} | íŒë§¤ê°€: ${Math.floor(item.price * 0.5).toLocaleString()}G`,
                    inline: false
                });
            });
            
            // ë’¤ë¡œê°€ê¸° ë²„íŠ¼
            const backButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('inventory')
                        .setLabel('ğŸ”™ ì¸ë²¤í† ë¦¬ ë©”ì¸')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            await interaction.editReply({
                embeds: [filterEmbed],
                components: [backButtons]
            });
        }
        
        // ì¸ë²¤í† ë¦¬ ì¹´í…Œê³ ë¦¬ ì„ íƒ ì²˜ë¦¬
        else if (customId === 'inventory_category_select') {
            const category = values[0].replace('inv_', '');
            
            await interaction.deferReply({ flags: 64 });
            
            const user = await getUser(interaction.user.id);
            if (!user) {
                return await interaction.editReply({ content: 'ìœ ì € ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!' });
            }
            
            // í•´ë‹¹ ì¹´í…Œê³ ë¦¬ì˜ ì•„ì´í…œ í•„í„°ë§
            const categoryItems = user.inventory.filter(item => item.type === category);
            
            if (categoryItems.length === 0) {
                return await interaction.editReply({ content: `âŒ ${getSlotDisplayName(category)} ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤!` });
            }
            
            // í˜ì´ì§€ë„¤ì´ì…˜ ì„¤ì •
            const itemsPerPage = 5;
            const totalPages = Math.ceil(categoryItems.length / itemsPerPage);
            const currentPage = 0;
            const startIndex = currentPage * itemsPerPage;
            const currentItems = categoryItems.slice(startIndex, startIndex + itemsPerPage);
            
            const categoryEmbed = new EmbedBuilder()
                .setColor('#8a2be2')
                .setTitle(`${getRarityEmoji(category)} ${getSlotDisplayName(category)} ì¸ë²¤í† ë¦¬`)
                .setDescription(`ë³´ìœ  ì¤‘ì¸ ${getSlotDisplayName(category)} ëª©ë¡`)
                .setFooter({ text: `í˜ì´ì§€ ${currentPage + 1}/${totalPages}` });
            
            // ì•„ì´í…œ ëª©ë¡ í‘œì‹œ
            currentItems.forEach((item, index) => {
                const globalIndex = startIndex + index;
                const isEquipped = Object.values(user.equipment).includes(item.inventorySlot);
                const enhanceText = item.enhanceLevel > 0 ? ` (+${item.enhanceLevel}ê°•)` : '';
                const equippedText = isEquipped ? ' **[ì¥ì°©ì¤‘]**' : '';
                
                let statsText = '';
                if (item.stats) {
                    const statParts = [];
                    if (item.stats.attack && item.stats.attack[0] > 0) statParts.push(`ê³µê²©ë ¥: ${item.stats.attack[0]}-${item.stats.attack[1]}`);
                    if (item.stats.defense && item.stats.defense[0] > 0) statParts.push(`ë°©ì–´ë ¥: ${item.stats.defense[0]}-${item.stats.defense[1]}`);
                    if (item.stats.dodge && item.stats.dodge[0] > 0) statParts.push(`íšŒí”¼ë ¥: ${item.stats.dodge[0]}-${item.stats.dodge[1]}`);
                    if (item.stats.luck && item.stats.luck[0] > 0) statParts.push(`í–‰ìš´: ${item.stats.luck[0]}-${item.stats.luck[1]}`);
                    statsText = statParts.join(', ');
                }
                
                categoryEmbed.addFields({
                    name: `${globalIndex + 1}. ${item.name}${enhanceText}${equippedText}`,
                    value: `${getRarityEmoji(item.rarity)} ${item.rarity}${statsText ? `\n${statsText}` : ''}\níŒë§¤ê°€: ${Math.floor(item.price * 0.5).toLocaleString()}G`,
                    inline: false
                });
            });
            
            // ì•„ì´í…œ ê´€ë¦¬ ë“œë¡­ë‹¤ìš´
            const itemActions = [
                {
                    label: 'ğŸ›ï¸ ì•„ì´í…œ íŒë§¤',
                    description: 'ì„ íƒí•œ ì•„ì´í…œì„ íŒë§¤í•©ë‹ˆë‹¤',
                    value: 'sell_items',
                    emoji: 'ğŸ›ï¸'
                },
                {
                    label: 'ğŸ” í•„í„° ë³´ê¸°',
                    description: 'íŠ¹ì • íƒ€ì…ì˜ ì•„ì´í…œë§Œ ë³´ê¸°',
                    value: 'filter_items',
                    emoji: 'ğŸ”'
                }
            ];
            
            const actionSelectMenu = new StringSelectMenuBuilder()
                .setCustomId('inventory_select')
                .setPlaceholder('ğŸ® ì‘ì—…ì„ ì„ íƒí•˜ì„¸ìš”')
                .addOptions(itemActions);
            
            const selectRow = new ActionRowBuilder().addComponents(actionSelectMenu);
            
            // í˜ì´ì§€ë„¤ì´ì…˜ ë° ë’¤ë¡œê°€ê¸° ë²„íŠ¼
            const navButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId(`inv_cat_${category}_prev_${currentPage}`)
                        .setLabel('â—€ ì´ì „')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(currentPage === 0),
                    new ButtonBuilder()
                        .setCustomId(`inv_cat_${category}_page_${currentPage}`)
                        .setLabel(`${currentPage + 1}/${totalPages}`)
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(true),
                    new ButtonBuilder()
                        .setCustomId(`inv_cat_${category}_next_${currentPage}`)
                        .setLabel('ë‹¤ìŒ â–¶')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(currentPage >= totalPages - 1),
                    new ButtonBuilder()
                        .setCustomId('back_to_inventory_menu')
                        .setLabel('ğŸ”™ ì¸ë²¤í† ë¦¬ ë©”ì¸')
                        .setStyle(ButtonStyle.Primary)
                );
            
            await interaction.editReply({
                embeds: [categoryEmbed],
                components: [selectRow, navButtons]
            });
        }
        
    } catch (error) {
        console.error('ë©”ë‰´ ì‹œìŠ¤í…œ ì˜¤ë¥˜:', error);
        if (!interaction.replied && !interaction.deferred) {
            await interaction.reply({ 
                content: 'âŒ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.', 
                flags: 64 
            }).catch(() => {
                // ì´ë¯¸ ì‘ë‹µëœ ê²½ìš° ë¬´ì‹œ
            });
        }
    }
});

// ìŠ¬ë˜ì‹œ ëª…ë ¹ì–´ ì²˜ë¦¬
client.on('interactionCreate', async (interaction) => {
    if (!interaction.isChatInputCommand()) return;

    console.log(`ëª…ë ¹ì–´ ì‹¤í–‰ - ì±„ë„: ${interaction.channelId}, ì‚¬ìš©ì: ${interaction.user.id}, ë² íƒ€ ëª¨ë“œ: ${BETA_MODE}`);
    
    // ë² íƒ€ ëª¨ë“œ ì²´í¬
    if (BETA_MODE) {
        // ë² íƒ€ ì±„ë„ì´ ì•„ë‹Œ ê²½ìš°
        if (!isBetaChannel(interaction.channelId)) {
            await interaction.reply({ 
                content: 'ğŸš§ í˜„ì¬ í´ë¡œì¦ˆë² íƒ€ í…ŒìŠ¤íŠ¸ ì¤‘ì…ë‹ˆë‹¤.\nì§€ì •ëœ ë² íƒ€ ì±„ë„ì—ì„œë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.', 
                flags: 64 
            });
            return;
        }
        
        // ë² íƒ€ í…ŒìŠ¤í„°ê°€ ì•„ë‹Œ ê²½ìš°
        if (!isBetaTester(interaction.user.id)) {
            await interaction.reply({ 
                content: 'ğŸ”’ í˜„ì¬ í´ë¡œì¦ˆë² íƒ€ í…ŒìŠ¤íŠ¸ ì¤‘ì…ë‹ˆë‹¤.\në² íƒ€ í…ŒìŠ¤í„°ë¡œ ë“±ë¡ëœ ì‚¬ìš©ìë§Œ ì´ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.', 
                flags: 64 
            });
            return;
        }
    }
    
    // ê°œë°œ ëª¨ë“œì—ì„œ ì±„ë„ ì œí•œ
    if (DEV_MODE && DEV_CHANNEL_IDS.length > 0 && !DEV_CHANNEL_IDS.includes(interaction.channelId)) {
        console.log(`ì±„ë„ ë¶ˆì¼ì¹˜ - í˜„ì¬: ${interaction.channelId}, í—ˆìš©ëœ ê°œë°œ ì±„ë„ë“¤: ${DEV_CHANNEL_IDS.join(', ')}`);
        await interaction.reply({ content: 'ê°œë°œ ëª¨ë“œì—ì„œëŠ” ì§€ì •ëœ ì±„ë„ì—ì„œë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤!', flags: 64 });
        return;
    }

    const { commandName } = interaction;

    // ì¹´ìš´íŠ¸ë‹¤ìš´ ì¤‘ì—ë„ í—ˆìš©ë˜ëŠ” ëª…ë ¹ì–´ë“¤
    const allowedDuringCountdown = ['í•‘', 'íšŒì›ê°€ì…', 'ì¹´ìš´íŠ¸ë‹¤ìš´', 'ê²Œì„ë°ì´í„°ì´ˆê¸°í™”'];
    
    // ì¹´ìš´íŠ¸ë‹¤ìš´ ì²´í¬ (í—ˆìš©ëœ ëª…ë ¹ì–´ ì œì™¸)
    if (isCountdownActive() && !allowedDuringCountdown.includes(commandName)) {
        await interaction.reply({ content: getCountdownMessage(), flags: 64 });
        return;
    }

    try {
        if (commandName === 'í•‘') {
            const ping = Date.now() - interaction.createdTimestamp;
            await interaction.reply(`í! ì§€ì—°ì‹œê°„: ${ping}ms`);
        }
        
        else if (commandName === 'ê²Œì„') {
            // ë¨¼ì € deferë¡œ ì‘ë‹µì„ ì§€ì—°ì‹œí‚´ (3ì´ˆ ì œí•œ í•´ê²°)
            await interaction.deferReply({ flags: 64 });
            
            const user = await getUser(interaction.user.id);
            if (!user) {
                await interaction.editReply({ content: 'ìœ ì € ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!' });
                return;
            }
            
            // ì‹œê°„ëŒ€ë³„ ì´ë¯¸ì§€ ë° ì¸ì‚¬ë§ ì„¤ì •
            const now = new Date();
            const hour = now.getHours();
            
            let timeImage = '';
            let timeColor = '';
            
            if (hour >= 6 && hour < 12) {
                // ì•„ì¹¨ ì‹œê°„ëŒ€ (6:00 - 11:59)
                timeImage = 'kim_main_morning.png';
                timeColor = '#ffeb3b'; // ë…¸ë€ìƒ‰
            } else if (hour >= 12 && hour < 18) {
                // ì ì‹¬ ì‹œê°„ëŒ€ (12:00 - 17:59)
                timeImage = 'kim_main_lunch.png';
                timeColor = '#ff9800'; // ì£¼í™©ìƒ‰
            } else {
                // ì €ë…/ë°¤ ì‹œê°„ëŒ€ (18:00 - 5:59)
                timeImage = 'kim_main_night.png';
                timeColor = '#3f51b5'; // ë‚¨ìƒ‰
            }

            // ìƒíƒœì°½ (RPG ìŠ¤íƒ€ì¼)
            const greetings = [
                'ì˜¤ëŠ˜ë„ í˜ì°¨ê²Œ ëª¨í—˜ì„ ë– ë‚˜ë³¼ê¹Œìš”?',
                'ìƒˆë¡œìš´ í•˜ë£¨ê°€ ì‹œì‘ë˜ì—ˆë„¤ìš”!',
                'ëª¨í—˜ê°€ë‹˜, ì¤€ë¹„ëŠ” ë˜ì…¨ë‚˜ìš”?',
                'ì˜¤ëŠ˜ì€ ì–´ë–¤ ì¬ë¯¸ìˆëŠ” ì¼ì´ ìˆì„ê¹Œìš”?',
                'ê°•í™”ì™•ì˜ ì„¸ê³„ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!',
                'ë ˆë²¨ì—…ì„ í–¥í•´ ë‹¬ë ¤ê°€ë³¼ê¹Œìš”?',
                'ì˜¤ëŠ˜ë„ ì¢‹ì€ í•˜ë£¨ ë˜ì„¸ìš”!',
                'ëª¨í—˜ì´ ì—¬ëŸ¬ë¶„ì„ ê¸°ë‹¤ë¦¬ê³  ìˆì–´ìš”!',
                'í–‰ìš´ì´ í•¨ê»˜í•˜ê¸¸ ë°”ëë‹ˆë‹¤!',
                'ìƒˆë¡œìš´ ë„ì „ì´ ì‹œì‘ë©ë‹ˆë‹¤!'
            ];
            
            const randomGreeting = greetings[Math.floor(Math.random() * greetings.length)];
            
            // ê²½í—˜ì¹˜ ê³„ì‚° ìˆ˜ì • (ë ˆë²¨ì—… ì‹œ í•„ìš” ê²½í—˜ì¹˜ = ë ˆë²¨ * 100)
            const maxExp = user.level * 100;
            
            // ì¶œì„ í˜„í™© ê³„ì‚° (ì˜¤ëŠ˜ ì¶œì„ì²´í¬ ì—¬ë¶€)
            const today = new Date().toDateString();
            const attendanceStatus = user.lastDaily === today ? 'ì¶œì„' : 'ê²°ì„';
            
            const statusEmbed = new EmbedBuilder()
                .setColor(timeColor)
                .setTitle(`${getUserTitle(user)} ${user.nickname}ë‹˜, ${randomGreeting}`)
                .addFields(
                    { name: 'â­ ë ˆë²¨', value: `\`\`\`Lv.${user.level}\`\`\``, inline: true },
                    { name: 'âœ¨ ê²½í—˜ì¹˜', value: `\`\`\`${user.exp}/${maxExp}\`\`\``, inline: true },
                    { name: '<:currency_emoji:1377404064316522778> ê³¨ë“œ', value: `\`\`\`${user.gold.toLocaleString()}\`\`\``, inline: true },
                    { name: 'ğŸ“… ì¶œì„í˜„í™©', value: `\`\`\`${attendanceStatus}\`\`\``, inline: true },
                    { name: 'ğŸ† ì¢…í•©ìˆœìœ„', value: `\`\`\`ì¤€ë¹„ì¤‘\`\`\``, inline: true },
                    { name: 'ğŸ’– ì¸ê¸°ë„', value: `\`\`\`${user.popularity}\`\`\``, inline: true }
                )
                .setImage(`attachment://${timeImage}`)
                .setFooter({ text: 'ê²Œì„ ë©”ë‰´ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!' });

            // RPG ìŠ¤íƒ€ì¼ ì¹´í…Œê³ ë¦¬ ë©”ë‰´ ìƒì„±
            const categoryMenu = createCategoryMenu();
            const menuRow = new ActionRowBuilder().addComponents(categoryMenu);
            
            // ë¹ ë¥¸ ì ‘ê·¼ ë²„íŠ¼ë“¤
            const quickButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('daily')
                        .setLabel('ğŸ ì¼ì¼ë³´ìƒ')
                        .setStyle(ButtonStyle.Success),
                    new ButtonBuilder()
                        .setCustomId('hunting')
                        .setLabel('ğŸ¯ ì‚¬ëƒ¥í•˜ê¸°')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('equipment')
                        .setLabel('âš”ï¸ ì¥ë¹„ê´€ë¦¬')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('shop')
                        .setLabel('ğŸ›’ ìƒì ')
                        .setStyle(ButtonStyle.Primary)
                );

            // ì‹œê°„ëŒ€ë³„ ì´ë¯¸ì§€ ì²¨ë¶€íŒŒì¼
            const timeAttachment = new AttachmentBuilder(path.join(__dirname, 'resource', timeImage), { name: timeImage });
            
            await interaction.editReply({ 
                embeds: [statusEmbed], 
                components: [menuRow, quickButtons], 
                files: [timeAttachment]
            });
        }
        
        else if (commandName === 'íšŒì›ê°€ì…') {
            const attachment = new AttachmentBuilder(path.join(__dirname, 'resource', 'kim_join.png'), { name: 'kim_join.png' });
            
            const embed = new EmbedBuilder()
                .setColor('#ff6b6b')
                .setTitle('ê°•í™”ì™• ê¹€í—Œí„° íšŒì›ê°€ì…')
                .setDescription('í™˜ì˜í•©ë‹ˆë‹¤! ê°•í™”ì™• ê¹€í—Œí„°ì˜ ì„¸ê³„ë¡œ ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤.\n\nê²Œì„ì„ ì‹œì‘í•˜ê¸° ìœ„í•´ íšŒì›ê°€ì…ì„ ì§„í–‰í•´ì£¼ì„¸ìš”.')
                .setImage('attachment://kim_join.png')
                .addFields(
                    { name: 'ì´ë©”ì¼ ë¬¸ì˜', value: 'support@kimhunter.com', inline: true },
                    { name: 'ë””ìŠ¤ì½”ë“œ ë¬¸ì˜', value: 'ê¹€í—Œí„°#0001', inline: true },
                    { name: 'ê¸°íƒ€ ë¬¸ì˜', value: 'í‹°ì¼“ ì‹œìŠ¤í…œ ì´ìš©', inline: true }
                )
                .setFooter({ text: 'ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ íšŒì›ê°€ì…ì„ ì§„í–‰í•˜ì„¸ìš”!' });

            const row = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('register')
                        .setLabel('íšŒì›ê°€ì…')
                        .setStyle(ButtonStyle.Primary)
                );

            await interaction.reply({ embeds: [embed], components: [row], files: [attachment] });
        }
        
        else if (commandName === 'dbí…ŒìŠ¤íŠ¸') {
            try {
                const user = await getUser(interaction.user.id);
                const totalUsers = await User.countDocuments();
                
                const embed = new EmbedBuilder()
                    .setColor('#00ff00')
                    .setTitle('ë°ì´í„°ë² ì´ìŠ¤ í…ŒìŠ¤íŠ¸')
                    .setDescription('MongoDB ì—°ê²° ìƒíƒœë¥¼ í™•ì¸í•©ë‹ˆë‹¤.')
                    .addFields(
                        { name: 'ì—°ê²° ìƒíƒœ', value: 'MongoDB ì—°ê²° ì„±ê³µ', inline: true },
                        { name: 'ì´ ìœ ì € ìˆ˜', value: `${totalUsers}ëª…`, inline: true },
                        { name: 'ë‚´ ê³¨ë“œ', value: `${user.gold.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true },
                        { name: 'ë‚´ ë ˆë²¨', value: `Lv.${user.level}`, inline: true },
                        { name: 'Discord ID', value: user.discordId, inline: true },
                        { name: 'ê°€ì…ì¼', value: user.createdAt.toLocaleDateString('ko-KR'), inline: true }
                    );
                
                await interaction.reply({ embeds: [embed], flags: 64 });
            } catch (error) {
                console.error('DB í…ŒìŠ¤íŠ¸ ì˜¤ë¥˜:', error);
                await interaction.reply({ content: 'ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì‹¤íŒ¨!', flags: 64 });
            }
        }
        
        else if (commandName === 'ì¸ê¸°ë„í…ŒìŠ¤íŠ¸') {
            const action = interaction.options.getString('í–‰ë™');
            const user = await getUser(interaction.user.id);
            
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            let message = '';
            
            switch(action) {
                case 'add':
                    user.popularity += 5;
                    await user.save();
                    await updatePopularKingRole(interaction.guild);
                    message = `ì¸ê¸°ë„ê°€ 5 ì¦ê°€í•˜ì—¬ ${user.popularity}ì ì´ ë˜ì—ˆìŠµë‹ˆë‹¤.`;
                    break;
                    
                case 'subtract':
                    user.popularity -= 5;
                    await user.save();
                    await updatePopularKingRole(interaction.guild);
                    message = `ì¸ê¸°ë„ê°€ 5 ê°ì†Œí•˜ì—¬ ${user.popularity}ì ì´ ë˜ì—ˆìŠµë‹ˆë‹¤.`;
                    break;
                    
                case 'reset':
                    user.dailyPopularityGain = 0;
                    user.dailyPopularityLoss = 0;
                    user.lastPopularityReset = new Date().toDateString();
                    await user.save();
                    message = 'ì¼ì¼ ì¸ê¸°ë„ í•œë„ê°€ ë¦¬ì…‹ë˜ì—ˆìŠµë‹ˆë‹¤.';
                    break;
                    
                case 'check':
                    const today = new Date().toDateString();
                    const isToday = user.lastPopularityReset === today;
                    message = `í˜„ì¬ ì¸ê¸°ë„: ${user.popularity}ì \n` +
                             `ì˜¤ëŠ˜ ë°›ì€ ì¸ê¸°ë„: +${isToday ? user.dailyPopularityGain : 0}/10\n` +
                             `ì˜¤ëŠ˜ ìƒì€ ì¸ê¸°ë„: ${isToday ? user.dailyPopularityLoss : 0}/10`;
                    break;
            }
            
            const embed = new EmbedBuilder()
                .setColor('#FFD700')
                .setTitle('ì¸ê¸°ë„ í…ŒìŠ¤íŠ¸')
                .setDescription(message)
                .setTimestamp();
                
            await interaction.reply({ embeds: [embed], flags: 64 });
        }
        
        else if (commandName === 'ì „íˆ¬ë ¥ìˆ˜ì •') {
            if (!isDeveloper(interaction.user.id)) {
                await interaction.reply({ content: 'ê´€ë¦¬ìë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ëª…ë ¹ì–´ì…ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            const user = await getUser(interaction.user.id);
            const statType = interaction.options.getString('íƒ€ì…');
            
            if (statType === 'check') {
                const combatPower = calculateCombatPower(user);
                const embed = new EmbedBuilder()
                    .setColor('#e74c3c')
                    .setTitle('âš”ï¸ ì „íˆ¬ë ¥ ì •ë³´')
                    .setDescription(`**${user.nickname}**ë‹˜ì˜ ì „íˆ¬ë ¥ ì •ë³´`)
                    .addFields(
                        { name: 'ì´ ì „íˆ¬ë ¥', value: `${combatPower}`, inline: true },
                        { name: 'ğŸ’ª í˜', value: `${user.stats.strength}`, inline: true },
                        { name: 'ğŸƒ ë¯¼ì²©', value: `${user.stats.agility}`, inline: true },
                        { name: 'ğŸ§  ì§€ëŠ¥', value: `${user.stats.intelligence}`, inline: true },
                        { name: 'â¤ï¸ ì²´ë ¥', value: `${user.stats.vitality}`, inline: true },
                        { name: 'ğŸ€ í–‰ìš´', value: `${user.stats.luck}`, inline: true }
                    );
                await interaction.reply({ embeds: [embed], flags: 64 });
            } else {
                user.stats[statType] += 10;
                await user.save();
                
                const statNames = {
                    strength: 'ğŸ’ª í˜',
                    agility: 'ğŸƒ ë¯¼ì²©',
                    intelligence: 'ğŸ§  ì§€ëŠ¥',
                    vitality: 'â¤ï¸ ì²´ë ¥',
                    luck: 'ğŸ€ í–‰ìš´'
                };
                
                const newCombatPower = calculateCombatPower(user);
                await interaction.reply({ 
                    content: `${statNames[statType]}ì´ 10 ì¦ê°€í–ˆìŠµë‹ˆë‹¤! ì „íˆ¬ë ¥: ${newCombatPower}`, 
                    flags: 64 
                });
            }
        }
        
        else if (commandName === 'ì´ë©”ì¼í…ŒìŠ¤íŠ¸') {
            try {
                // ë¨¼ì € ì‘ë‹µì„ ì§€ì—°ì‹œì¼œ ì‹œê°„ ì œí•œ ë¬¸ì œ í•´ê²°
                await interaction.deferReply({ flags: 64 });
                
                const testCode = generateVerificationCode();
                const emailSent = await sendVerificationEmail('sup.kimhunter@gmail.com', testCode);
                
                if (emailSent) {
                    const embed = new EmbedBuilder()
                        .setColor('#00ff00')
                        .setTitle('ì´ë©”ì¼ í…ŒìŠ¤íŠ¸ ì„±ê³µ!')
                        .setDescription('í…ŒìŠ¤íŠ¸ ì´ë©”ì¼ì´ ì„±ê³µì ìœ¼ë¡œ ì „ì†¡ë˜ì—ˆìŠµë‹ˆë‹¤.')
                        .addFields(
                            { name: 'ìˆ˜ì‹  ì´ë©”ì¼', value: 'sup.kimhunter@gmail.com', inline: true },
                            { name: 'í…ŒìŠ¤íŠ¸ ì½”ë“œ', value: testCode, inline: true },
                            { name: 'ì „ì†¡ ì‹œê°„', value: new Date().toLocaleString('ko-KR'), inline: true }
                        );
                    
                    await interaction.editReply({ embeds: [embed] });
                } else {
                    await interaction.editReply({ content: 'ì´ë©”ì¼ ì „ì†¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤!' });
                }
            } catch (error) {
                console.error('ì´ë©”ì¼ í…ŒìŠ¤íŠ¸ ì˜¤ë¥˜:', error);
                if (interaction.deferred) {
                    await interaction.editReply({ content: 'ì´ë©”ì¼ í…ŒìŠ¤íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤!' });
                } else {
                    await interaction.reply({ content: 'ì´ë©”ì¼ í…ŒìŠ¤íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤!', flags: 64 });
                }
            }
        }
        
        else if (commandName === 'íšŒì›ê°€ì…ì±„ë„ì„¤ì •') {
            try {
                await interaction.deferReply({ flags: 64 });
                
                const SIGNUP_CHANNEL_ID = '1380684353998426122';
                const signupChannel = await client.channels.fetch(SIGNUP_CHANNEL_ID);
                
                if (signupChannel) {
                    const signupAttachment = new AttachmentBuilder(path.join(__dirname, 'resource', 'kim_join.png'), { name: 'kim_join.png' });
                    
                    const signupEmbed = new EmbedBuilder()
                        .setColor('#ff6b6b')
                        .setTitle('ê°•í™”ì™• ê¹€í—Œí„° íšŒì›ê°€ì…')
                        .setDescription('í™˜ì˜í•©ë‹ˆë‹¤! ê°•í™”ì™• ê¹€í—Œí„°ì˜ ì„¸ê³„ë¡œ ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤.\n\nê²Œì„ì„ ì‹œì‘í•˜ê¸° ìœ„í•´ íšŒì›ê°€ì…ì„ ì§„í–‰í•´ì£¼ì„¸ìš”.\n\n**íšŒì›ê°€ì… í˜œíƒ:**\nâ€¢ ê°€ì… ì¦‰ì‹œ 1,000G ì§€ê¸‰\nâ€¢ ê²½í—˜ì¹˜ ë¶€ìŠ¤í„° ë° ì´ˆë³´ì ë¬´ê¸° ì œê³µ\nâ€¢ ì¼ì¼ë³´ìƒ ë° ë‹¤ì–‘í•œ ê²Œì„ ì»¨í…ì¸  ì´ìš© ê°€ëŠ¥')
                        .setImage('attachment://kim_join.png')
                        .addFields(
                            { name: 'ğŸ“§ ì´ë©”ì¼ ë¬¸ì˜', value: 'sup.kimhunter@gmail.com', inline: true },
                            { name: 'ğŸ’¬ ë””ìŠ¤ì½”ë“œ ë¬¸ì˜', value: 'JRY_10004', inline: true },
                            { name: 'ğŸ« í‹°ì¼“ ë¬¸ì˜', value: 'ì¶”í›„ ë²„íŠ¼ë§í¬ ìƒì„± ì˜ˆì •', inline: true }
                        )
                        .setFooter({ text: 'ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ íšŒì›ê°€ì…ì„ ì§„í–‰í•˜ì„¸ìš”!' });

                    const signupRow = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId('register')
                                .setLabel('íšŒì›ê°€ì…')
                                .setStyle(ButtonStyle.Primary)
                        );

                    await signupChannel.send({ embeds: [signupEmbed], components: [signupRow], files: [signupAttachment] });
                    
                    await interaction.editReply({ content: 'íšŒì›ê°€ì… ì±„ë„ì— ì•ˆë‚´ ë©”ì‹œì§€ë¥¼ ì„±ê³µì ìœ¼ë¡œ ê²Œì‹œí–ˆìŠµë‹ˆë‹¤!' });
                } else {
                    await interaction.editReply({ content: 'íšŒì›ê°€ì… ì±„ë„ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!' });
                }
            } catch (error) {
                console.error('íšŒì›ê°€ì… ì±„ë„ ì„¤ì • ì˜¤ë¥˜:', error);
                if (interaction.deferred) {
                    await interaction.editReply({ content: 'íšŒì›ê°€ì… ì±„ë„ ì„¤ì • ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤!' });
                } else {
                    await interaction.reply({ content: 'íšŒì›ê°€ì… ì±„ë„ ì„¤ì • ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤!', flags: 64 });
                }
            }
        }
        
        // ê°•í™” ëª…ë ¹ì–´ ì²˜ë¦¬
        else if (commandName === 'ê°•í™”' || commandName === 'ì§‘ì¤‘ë ¥' || commandName === 'ì¶•ë³µë°›ì€ë‚ ') {
            const slotName = interaction.options.getString('ì¥ë¹„ìŠ¬ë¡¯');
            const useProtection = interaction.options.getBoolean('ë³´í˜¸ê¶Œì‚¬ìš©') || false;
            const user = await getUser(interaction.user.id);
            
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            // ìƒˆë¡œìš´ ì¸ë²¤í† ë¦¬ ì‹œìŠ¤í…œìœ¼ë¡œ ì¥ì°© ì•„ì´í…œ í™•ì¸
            const equipment = getEquippedItem(user, slotName);
            if (!equipment) {
                await interaction.reply({ content: `${slotName} ìŠ¬ë¡¯ì— ì¥ì°©ëœ ì¥ë¹„ê°€ ì—†ìŠµë‹ˆë‹¤!`, flags: 64 });
                return;
            }
            
            if (equipment.enhanceLevel >= 30) {
                await interaction.reply({ content: 'ì´ë¯¸ ìµœëŒ€ ê°•í™” ë‹¨ê³„(30ê°•)ì…ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            // ë³´í˜¸ê¶Œ ì‚¬ìš© ì¡°ê±´ ì²´í¬ (20ê°• ì´ìƒ)
            if (useProtection) {
                if (equipment.enhanceLevel < 20) {
                    await interaction.reply({ content: 'ë³´í˜¸ê¶Œì€ 20ì„± ì´ìƒë¶€í„° ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!', flags: 64 });
                    return;
                }
                if (user.protectionScrolls < 1) {
                    await interaction.reply({ content: 'ë³´ìœ í•œ ë³´í˜¸ê¶Œì´ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
                    return;
                }
            }
            
            // ì•„ì´í…œ ë ˆë²¨ ê°€ì ¸ì˜¤ê¸°
            const itemLevel = ITEM_LEVELS[equipment.setName] || ITEM_LEVELS[equipment.name] || 1;
            const currentStar = equipment.enhanceLevel || 0;
            const cost = calculateEnhanceCost(itemLevel, currentStar);
            
            if (user.gold < cost) {
                await interaction.reply({ 
                    content: `ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤! í•„ìš”: ${cost}G, ë³´ìœ : ${user.gold}G`, 
                    flags: 64 
                });
                return;
            }
            
            // ê°•í™” ì‹œë„
            const rates = ENHANCEMENT_RATES[currentStar];
            const isFocusMode = commandName === 'ì§‘ì¤‘ë ¥';
            const isBlessedDay = commandName === 'ì¶•ë³µë°›ì€ë‚ ';
            
            const result = attemptEnhanceWithProtection(rates, isFocusMode, isBlessedDay, currentStar, useProtection);
            user.gold -= cost;
            
            // ë³´í˜¸ê¶Œ ì‚¬ìš©ì‹œ ì°¨ê°
            if (useProtection && (result === 'destroy' || result === 'fail')) {
                user.protectionScrolls -= 1;
            }
            
            // ê°•í™” í†µê³„ ì—…ë°ì´íŠ¸
            user.enhanceStats.totalAttempts += 1;
            user.enhanceStats.totalCost += cost;
            
            let resultEmbed;
            
            if (result === 'success') {
                equipment.enhanceLevel += 1;
                user.enhanceStats.successCount += 1;
                user.enhanceStats.maxEnhanceLevel = Math.max(user.enhanceStats.maxEnhanceLevel, equipment.enhanceLevel);
                
                // ì‹ ì‹ ì‹œìŠ¤í…œ: getEquippedItemì´ ì´ë¯¸ ì¸ë²¤í† ë¦¬ì˜ ì‹¤ì œ ì•„ì´í…œì„ ì°¸ì¡°í•˜ë¯€ë¡œ ë³„ë„ ì—…ë°ì´íŠ¸ ë¶ˆí•„ìš”
                
                resultEmbed = new EmbedBuilder()
                    .setColor('#00ff00')
                    .setTitle('ğŸ‰ ê°•í™” ì„±ê³µ!')
                    .setDescription(`**${equipment.name}**ì´(ê°€) ê°•í™”ë˜ì—ˆìŠµë‹ˆë‹¤!`)
                    .addFields(
                        { name: 'ê°•í™” ê²°ê³¼', value: `+${currentStar} â†’ **+${equipment.enhanceLevel}**ê°•`, inline: true },
                        { name: 'ì‚¬ìš© ê³¨ë“œ', value: `${cost}G`, inline: true },
                        { name: 'ì”ì—¬ ê³¨ë“œ', value: `${user.gold}G`, inline: true }
                    );
                    
                // ê°•í™”ì™• ì—…ë°ì´íŠ¸ (10ì„± ì´ìƒì¼ ë•Œ)
                if (equipment.enhanceLevel >= 10) {
                    await updateEnhanceKingRole(interaction.guild);
                }
                
                // ì£¼ì‹ ì‹œì¥ ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±°
                triggerEnhancementEvent(equipment.enhanceLevel, true);
                
            } else if (result === 'fail') {
                resultEmbed = new EmbedBuilder()
                    .setColor('#ffaa00')
                    .setTitle('ğŸ’« ê°•í™” ì‹¤íŒ¨')
                    .setDescription(`**${equipment.name}** ê°•í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.`)
                    .addFields(
                        { name: 'ê°•í™” ê²°ê³¼', value: `+${currentStar} (ë³€í™”ì—†ìŒ)`, inline: true },
                        { name: 'ì‚¬ìš© ê³¨ë“œ', value: `${cost}G`, inline: true },
                        { name: 'ì”ì—¬ ê³¨ë“œ', value: `${user.gold}G`, inline: true }
                    );
                
                // ì£¼ì‹ ì‹œì¥ ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±° (ì‹¤íŒ¨)
                triggerEnhancementEvent(equipment.enhanceLevel, false);
                    
            } else { // destroy
                const oldLevel = equipment.enhanceLevel;
                equipment.enhanceLevel = Math.max(0, equipment.enhanceLevel - 1);
                user.enhanceStats.destroyCount += 1;
                
                // ì‹ ì‹ ì‹œìŠ¤í…œ: getEquippedItemì´ ì´ë¯¸ ì¸ë²¤í† ë¦¬ì˜ ì‹¤ì œ ì•„ì´í…œì„ ì°¸ì¡°í•˜ë¯€ë¡œ ë³„ë„ ì—…ë°ì´íŠ¸ ë¶ˆí•„ìš”
                
                resultEmbed = new EmbedBuilder()
                    .setColor('#ff0000')
                    .setTitle('ğŸ’¥ ê°•í™” íŒŒê´´!')
                    .setDescription(`**${equipment.name}**ì´(ê°€) íŒŒê´´ë˜ì–´ ê°•í™” ë‹¨ê³„ê°€ ê°ì†Œí–ˆìŠµë‹ˆë‹¤!`)
                    .addFields(
                        { name: 'ê°•í™” ê²°ê³¼', value: `+${oldLevel} â†’ **+${equipment.enhanceLevel}**ğŸ’€`, inline: true },
                        { name: 'ì‚¬ìš© ê³¨ë“œ', value: `${cost}G`, inline: true },
                        { name: 'ì”ì—¬ ê³¨ë“œ', value: `${user.gold}G`, inline: true }
                    );
                
                // ì£¼ì‹ ì‹œì¥ ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±° (íŒŒê´´)
                triggerEnhancementEvent(oldLevel, false);
            }
            
            // ì´ë²¤íŠ¸ íš¨ê³¼ í‘œì‹œ
            if (isFocusMode) {
                resultEmbed.setFooter({ text: 'ğŸŒŸ ì§‘ì¤‘ë ¥ ì´ë²¤íŠ¸ ì ìš© (ì„±ê³µë¥  +5%)' });
            } else if (isBlessedDay && currentStar >= 15 && currentStar <= 22) {
                resultEmbed.setFooter({ text: 'ğŸ ì¶•ë³µë°›ì€ë‚  ì´ë²¤íŠ¸ ì ìš© (íŒŒê´´ìœ¨ -30%)' });
            }
            
            await user.save();
            await interaction.reply({ embeds: [resultEmbed] });
        }
        
        else if (commandName === 'ê°•í™”ë­í‚¹') {
            await interaction.deferReply();
            
            try {
                const users = await User.find({ registered: true });
                const rankingData = [];
                
                for (const user of users) {
                    let maxEnhance = 0;
                    let topItem = null;
                    
                    // ì°©ìš© ì¥ë¹„ì—ì„œ ìµœê³  ê°•í™” ì°¾ê¸°
                    for (const [slot, equipment] of Object.entries(user.equipment)) {
                        if (equipment && equipment.enhanceLevel > maxEnhance) {
                            maxEnhance = equipment.enhanceLevel;
                            topItem = equipment;
                        }
                    }
                    
                    if (maxEnhance > 0) {
                        rankingData.push({
                            nickname: user.nickname,
                            enhanceLevel: maxEnhance,
                            itemName: topItem.name,
                            totalAttempts: user.enhanceStats.totalAttempts || 0
                        });
                    }
                }
                
                // ê°•í™” ë ˆë²¨ìˆœìœ¼ë¡œ ì •ë ¬
                rankingData.sort((a, b) => b.enhanceLevel - a.enhanceLevel);
                
                const embed = new EmbedBuilder()
                    .setColor('#ffd700')
                    .setTitle('âš”ï¸ ê°•í™” ë­í‚¹ TOP 10')
                    .setDescription('ìµœê³  ê°•í™” ì¥ë¹„ ê¸°ì¤€ ë­í‚¹');
                
                let rankText = '';
                for (let i = 0; i < Math.min(10, rankingData.length); i++) {
                    const data = rankingData[i];
                    const medal = i === 0 ? 'ğŸ¥‡' : i === 1 ? 'ğŸ¥ˆ' : i === 2 ? 'ğŸ¥‰' : `${i + 1}ìœ„`;
                    rankText += `${medal} **${data.nickname}** - ${data.itemName} +${data.enhanceLevel}â­\n`;
                }
                
                if (rankText === '') {
                    rankText = 'ì•„ì§ ê°•í™”í•œ ì‚¬ìš©ìê°€ ì—†ìŠµë‹ˆë‹¤.';
                }
                
                embed.addFields({ name: 'ë­í‚¹', value: rankText, inline: false });
                
                await interaction.editReply({ embeds: [embed] });
                
            } catch (error) {
                console.error('ê°•í™”ë­í‚¹ ì¡°íšŒ ì˜¤ë¥˜:', error);
                await interaction.editReply({ content: 'ë­í‚¹ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤!' });
            }
        }
        
        else if (commandName === 'ì˜ë¢°') {
            // ì¿¨íƒ€ì„ ì²´í¬
            const cooldownMinutes = checkQuestCooldown(interaction.user.id);
            if (cooldownMinutes) {
                await interaction.reply({ 
                    content: `â° ì˜ë¢° ì¿¨íƒ€ì„ì´ **${cooldownMinutes}ë¶„** ë‚¨ì•˜ìŠµë‹ˆë‹¤!`, 
                    flags: 64 
                });
                return;
            }

            // ëœë¤ ì˜ë¢° ì„ íƒ
            const quest = getRandomQuest();
            
            const questEmbed = new EmbedBuilder()
                .setColor('#f39c12')
                .setTitle(`${quest.emoji} ${quest.title}`)
                .setDescription(`**${quest.name}**\n\n"${quest.description}"`)
                .setFooter({ text: 'ì˜ë¢°ë¥¼ ìˆ˜ë½í•˜ì‹œê² ìŠµë‹ˆê¹Œ?' });

            if (quest.type === 'scam') {
                questEmbed.setColor('#e74c3c');
            }

            const questButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId(`accept_quest_${quest.id}`)
                        .setLabel('âœ… ìˆ˜ë½')
                        .setStyle(ButtonStyle.Success),
                    new ButtonBuilder()
                        .setCustomId('decline_quest')
                        .setLabel('âŒ ê±°ì ˆ')
                        .setStyle(ButtonStyle.Danger)
                );

            await interaction.reply({ 
                embeds: [questEmbed], 
                components: [questButtons], 
                flags: 64 
            });
        }
        
        else if (commandName === 'ì£¼ì‹') {
            const user = await getUser(interaction.user.id);
            
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            // ë ˆë²¨ 20 ì´ìƒ ì œí•œ
            if (user.level < 20) {
                await interaction.reply({ 
                    content: `ì£¼ì‹ ì‹œì¥ì€ **ë ˆë²¨ 20 ì´ìƒ**ë¶€í„° ì´ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤! (í˜„ì¬ ë ˆë²¨: ${user.level})`, 
                    flags: 64 
                });
                return;
            }
            
            // í”Œë ˆì´ì–´ í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì ¸ì˜¤ê¸°
            const portfolio = await getPlayerPortfolio(interaction.user.id);
            
            // ìƒìœ„ 5ê°œ ê¸°ì—… ì •ë³´ ìˆ˜ì§‘
            const allCompanies = [];
            
            // ì§€ì—­ ê¸°ì—…ë“¤ ì¶”ê°€
            for (const region of Object.values(STOCK_MARKET.regions)) {
                region.companies.forEach(company => {
                    allCompanies.push({
                        ...company,
                        region: region.name
                    });
                });
            }
            
            // ì²´ì¸ ê¸°ì—…ë“¤ ì¶”ê°€
            STOCK_MARKET.chains.forEach(company => {
                allCompanies.push({
                    ...company,
                    region: 'ğŸŒ ì „ì§€ì—­'
                });
            });
            
            // ê°€ê²© ìˆœìœ¼ë¡œ ì •ë ¬
            allCompanies.sort((a, b) => b.price - a.price);
            const topCompanies = allCompanies.slice(0, 10);
            
            // í¬íŠ¸í´ë¦¬ì˜¤ ì´ ê°€ì¹˜ ê³„ì‚°
            let totalPortfolioValue = portfolio.cash;
            let portfolioText = `ğŸ’° í˜„ê¸ˆ: ${portfolio.cash.toLocaleString()}<:currency_emoji:1377404064316522778>\n\n`;
            
            if (portfolio.stocks.size > 0) {
                portfolioText += 'ğŸ“ˆ **ë³´ìœ  ì£¼ì‹:**\n';
                for (const [companyId, holding] of portfolio.stocks) {
                    const company = findCompany(companyId);
                    if (company) {
                        const currentValue = company.price * holding.shares;
                        const profit = currentValue - (holding.avgPrice * holding.shares);
                        const profitPercent = ((profit / (holding.avgPrice * holding.shares)) * 100).toFixed(1);
                        
                        portfolioText += `â€¢ ${company.name}: ${holding.shares}ì£¼ `;
                        portfolioText += `(${profitPercent >= 0 ? '+' : ''}${profitPercent}%)\n`;
                        
                        totalPortfolioValue += currentValue;
                    }
                }
            } else {
                portfolioText += 'ğŸ“Š ë³´ìœ  ì£¼ì‹ì´ ì—†ìŠµë‹ˆë‹¤.\n';
            }
            
            portfolioText += `\nğŸ’ **ì´ ìì‚°**: ${totalPortfolioValue.toLocaleString()}<:currency_emoji:1377404064316522778>`;
            
            // ìƒìœ„ ê¸°ì—… ëª©ë¡ ìƒì„±
            let marketText = '';
            topCompanies.forEach((company, index) => {
                const changeIcon = company.change > 0 ? 'ğŸ“ˆ' : company.change < 0 ? 'ğŸ“‰' : 'â¡ï¸';
                const changeColor = company.change > 0 ? '+' : '';
                marketText += `${index + 1}. **${company.name}**\n`;
                marketText += `   ${company.price.toLocaleString()}<:currency_emoji:1377404064316522778> ${changeIcon} ${changeColor}${company.change.toFixed(1)}%\n`;
                marketText += `   ${company.region} | ê±°ë˜ëŸ‰: ${company.volume.toLocaleString()}\n\n`;
            });
            
            const stockEmbed = new EmbedBuilder()
                .setColor('#2ecc71')
                .setTitle('ğŸ“Š ê¹€í—Œí„° ì£¼ì‹ ì‹œì¥')
                .setDescription(`**${user.nickname}**ë‹˜ì˜ íˆ¬ì í˜„í™©\n\n${portfolioText}`)
                .addFields(
                    { 
                        name: 'ğŸ† ìƒìœ„ ê¸°ì—… ìˆœìœ„', 
                        value: marketText || 'ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...', 
                        inline: false 
                    }
                )
                .setFooter({ 
                    text: 'ì‹¤ì‹œê°„ ì£¼ê°€ëŠ” NPC ê°ì •, í”Œë ˆì´ì–´ í–‰ë™, ì‹œê°„ëŒ€ë³„ ì´ë²¤íŠ¸ì— ì˜í–¥ì„ ë°›ìŠµë‹ˆë‹¤!' 
                });
            
            // ì£¼ì‹ ê´€ë ¨ ë²„íŠ¼ë“¤ (2ì¤„ë¡œ ë°°ì¹˜)
            const stockButtons1 = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('stock_regions')
                        .setLabel('ğŸŒ ì§€ì—­ë³„ ê¸°ì—…')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('stock_chains')
                        .setLabel('ğŸ¢ ì²´ì¸ ê¸°ì—…')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('stock_portfolio')
                        .setLabel('ğŸ’¼ ë‚´ í¬íŠ¸í´ë¦¬ì˜¤')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            const stockButtons2 = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('stock_news')
                        .setLabel('ğŸ“° ì‹œì¥ ë‰´ìŠ¤')
                        .setStyle(ButtonStyle.Secondary),
                    new ButtonBuilder()
                        .setCustomId('stock_chart')
                        .setLabel('ğŸ“Š ì‹¤ì‹œê°„ ì°¨íŠ¸')
                        .setStyle(ButtonStyle.Success),
                    new ButtonBuilder()
                        .setCustomId('stock_analysis')
                        .setLabel('ğŸ” ì‹œì¥ ë¶„ì„')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            await interaction.reply({ 
                embeds: [stockEmbed], 
                components: [stockButtons1, stockButtons2], 
                flags: 64 
            });
        }
        
        else if (commandName === 'ê°•í™”í†µê³„') {
            const user = await getUser(interaction.user.id);
            
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            const stats = user.enhanceStats;
            const successRate = stats.totalAttempts > 0 ? ((stats.successCount / stats.totalAttempts) * 100).toFixed(1) : 0;
            const destroyRate = stats.totalAttempts > 0 ? ((stats.destroyCount / stats.totalAttempts) * 100).toFixed(1) : 0;
            
            const embed = new EmbedBuilder()
                .setColor('#9b59b6')
                .setTitle(`ğŸ“Š ${user.nickname}ë‹˜ì˜ ê°•í™” í†µê³„`)
                .addFields(
                    { name: 'ğŸ¯ ì´ ì‹œë„ íšŸìˆ˜', value: `${stats.totalAttempts}íšŒ`, inline: true },
                    { name: 'âœ… ì„±ê³µ íšŸìˆ˜', value: `${stats.successCount}íšŒ`, inline: true },
                    { name: 'ğŸ’¥ íŒŒê´´ íšŸìˆ˜', value: `${stats.destroyCount}íšŒ`, inline: true },
                    { name: 'ğŸ“ˆ ì„±ê³µë¥ ', value: `${successRate}%`, inline: true },
                    { name: 'ğŸ’€ íŒŒê´´ìœ¨', value: `${destroyRate}%`, inline: true },
                    { name: 'â­ ìµœê³  ê°•í™”', value: `+${stats.maxEnhanceLevel}ê°•`, inline: true },
                    { name: 'ğŸ’° ì´ ì‚¬ìš© ê³¨ë“œ', value: `${stats.totalCost.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: false }
                );
            
            await interaction.reply({ embeds: [embed], flags: 64 });
        }
        
        // ğŸª ì•„ì´í…œ ê²½ë§¤ì¥ ëª…ë ¹ì–´
        else if (commandName === 'ê²½ë§¤ì¥') {
            const user = await getUser(interaction.user.id);
            
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            // ë ˆë²¨ ì œí•œ (ë ˆë²¨ 10 ì´ìƒ)
            if (user.level < 10) {
                await interaction.reply({ 
                    content: `ê²½ë§¤ì¥ì€ **ë ˆë²¨ 10 ì´ìƒ**ë¶€í„° ì´ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤! (í˜„ì¬ ë ˆë²¨: ${user.level})`, 
                    flags: 64 
                });
                return;
            }
            
            // í˜„ì¬ í™œì„± ê²½ë§¤ ìˆ˜ ê³„ì‚°
            const activeListings = Array.from(AUCTION_HOUSE.listings.values())
                .filter(listing => listing.status === 'active' && Date.now() < listing.endTime);
            
            // í˜„ì¬ ì‹œì¥ ì´ë²¤íŠ¸ ì •ë³´
            let eventText = '';
            if (currentMarketEvent) {
                const remainingHours = Math.ceil((currentMarketEvent.startTime + currentMarketEvent.duration - Date.now()) / (60 * 60 * 1000));
                eventText = `\n\nğŸŒŸ **ì‹œì¥ ì´ë²¤íŠ¸**: ${currentMarketEvent.name} (${remainingHours}ì‹œê°„ ë‚¨ìŒ)`;
            }
            
            const auctionEmbed = new EmbedBuilder()
                .setColor('#f39c12')
                .setTitle('ğŸª ì•„ì´í…œ ê²½ë§¤ì¥')
                .setDescription(`**ê°•í™”ì™• ê¹€í—Œí„° ê²½ë§¤ì¥**ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!\n\ní”Œë ˆì´ì–´ë“¤ ê°„ì˜ ì•„ì´í…œ ê±°ë˜ë¥¼ í†µí•´ ì‹œì¥ ê²½ì œë¥¼ ì¦ê²¨ë³´ì„¸ìš”!${eventText}`)
                .addFields(
                    { name: 'ğŸ“Š ì‹œì¥ í˜„í™©', value: `í™œì„± ê²½ë§¤: ${activeListings.length}ê°œ`, inline: true },
                    { name: 'ğŸ’° ë³´ìœ  ê³¨ë“œ', value: `${user.gold.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true },
                    { name: 'ğŸ’ ì¸ë²¤í† ë¦¬', value: `${user.inventory.length}/${user.maxInventorySlots}`, inline: true }
                );

            const auctionButtons1 = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('auction_browse')
                        .setLabel('ğŸ” ê²½ë§¤ ë‘˜ëŸ¬ë³´ê¸°')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('auction_sell')
                        .setLabel('ğŸ’° ì•„ì´í…œ íŒë§¤')
                        .setStyle(ButtonStyle.Success),
                    new ButtonBuilder()
                        .setCustomId('auction_my_listings')
                        .setLabel('ğŸ“‹ ë‚´ ê²½ë§¤')
                        .setStyle(ButtonStyle.Secondary)
                );

            const auctionButtons2 = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('auction_market_price')
                        .setLabel('ğŸ“ˆ ì‹œì„¸ ì¡°íšŒ')
                        .setStyle(ButtonStyle.Secondary),
                    new ButtonBuilder()
                        .setCustomId('auction_hot_items')
                        .setLabel('ğŸ”¥ ì¸ê¸° ì•„ì´í…œ')
                        .setStyle(ButtonStyle.Danger),
                    new ButtonBuilder()
                        .setCustomId('auction_trade_history')
                        .setLabel('ğŸ“Š ê±°ë˜ ë‚´ì—­')
                        .setStyle(ButtonStyle.Secondary)
                );

            await interaction.reply({ 
                embeds: [auctionEmbed], 
                components: [auctionButtons1, auctionButtons2], 
                flags: 64 
            });
        }
        
        // ğŸ² ì‹ ë¹„í•œ ìƒì ëª…ë ¹ì–´ (ë¯¸ì¶œì‹œ)
        else if (commandName === 'ì‹ ë¹„í•œìƒì') {
            await interaction.reply({ 
                content: 'ğŸš§ **ì‹ ë¹„í•œ ìƒì ì‹œìŠ¤í…œ**ì€ ì•„ì§ ì¤€ë¹„ì¤‘ì…ë‹ˆë‹¤!\n\nê³§ ë©‹ì§„ ê¸°ëŠ¥ìœ¼ë¡œ ì—…ë°ì´íŠ¸ ì˜ˆì •ì´ë‹ˆ ì¡°ê¸ˆë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”! âœ¨', 
                flags: 64 
            });
        }
        
        // ğŸ”§ ê´€ë¦¬ì ì „ìš© ëª…ë ¹ì–´ë“¤
        else if (commandName === 'ì¹´ìš´íŠ¸ë‹¤ìš´') {
            // ê´€ë¦¬ì ê¶Œí•œ ì²´í¬
            if (!isAdmin(interaction.user.id)) {
                await interaction.reply({ content: 'âŒ ê´€ë¦¬ìë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ëª…ë ¹ì–´ì…ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            const subcommand = interaction.options.getSubcommand();
            
            if (subcommand === 'ì‹œì‘') {
                const hours = interaction.options.getInteger('ì‹œê°„');
                const channel = interaction.options.getChannel('ì±„ë„');
                
                // ê¸°ì¡´ ì¹´ìš´íŠ¸ë‹¤ìš´ ì¤‘ì§€
                if (openCountdown.interval) {
                    clearInterval(openCountdown.interval);
                }
                
                // ìƒˆ ì¹´ìš´íŠ¸ë‹¤ìš´ ì„¤ì •
                openCountdown.isActive = true;
                openCountdown.launchTime = new Date(Date.now() + hours * 60 * 60 * 1000);
                openCountdown.channelId = channel.id;
                
                // ì´ˆê¸° ì¹´ìš´íŠ¸ë‹¤ìš´ ê³„ì‚°
                const remaining = openCountdown.launchTime - Date.now();
                const remainingDays = Math.floor(remaining / (1000 * 60 * 60 * 24));
                const remainingHours = Math.floor((remaining % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const remainingMinutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
                const remainingSeconds = Math.floor((remaining % (1000 * 60)) / 1000);
                
                // ì¹´ìš´íŠ¸ë‹¤ìš´ ë””ìŠ¤í”Œë ˆì´ ìƒì„±
                const countdownDisplay = remainingDays > 0 
                    ? `\`\`\`fix\n${String(remainingDays).padStart(2, '0')}ì¼ ${String(remainingHours).padStart(2, '0')}:${String(remainingMinutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}\n\`\`\``
                    : `\`\`\`fix\n${String(remainingHours).padStart(2, '0')}:${String(remainingMinutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}\n\`\`\``;
                
                // ì§„í–‰ë¥  ë°” ìƒì„±
                const totalTime = hours * 60 * 60 * 1000; // ì„¤ì •í•œ ì‹œê°„
                openCountdown.totalTime = totalTime; // ì €ì¥
                const elapsed = totalTime - remaining;
                const progress = Math.max(0, Math.min(100, (elapsed / totalTime) * 100));
                const barLength = 20;
                const filledLength = Math.floor((progress / 100) * barLength);
                const progressBar = 'ğŸŸ©'.repeat(filledLength) + 'â¬œ'.repeat(barLength - filledLength);
                
                // ì´ˆê¸° ì‹œê³„ ì´ë¯¸ì§€ ìƒì„±
                const clockBuffer = await createCountdownClock(remaining);
                
                // ì´ˆê¸° ì¹´ìš´íŠ¸ë‹¤ìš´ ë©”ì‹œì§€ ìƒì„±
                const countdownEmbed = new EmbedBuilder()
                    .setColor('#ff0000')
                    .setTitle('ğŸš€ ê¹€í—Œí„° RPG ì •ì‹ ì˜¤í”ˆ ì¹´ìš´íŠ¸ë‹¤ìš´!')
                    .setDescription('**ëª¨ë“  ê¸°ëŠ¥ì´ ì ê²¨ìˆìŠµë‹ˆë‹¤!**\nì˜¤í”ˆ ì‹œê°„ê¹Œì§€ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”!')
                    .addFields(
                        { name: 'â° ì˜¤í”ˆ ì˜ˆì • ì‹œê°„', value: `<t:${Math.floor(openCountdown.launchTime.getTime() / 1000)}:F>`, inline: false },
                        { name: 'ğŸ• ì‹¤ì‹œê°„ ì¹´ìš´íŠ¸ë‹¤ìš´', value: countdownDisplay, inline: false },
                        { name: 'ğŸ“Š ì§„í–‰ë¥ ', value: `${progressBar} ${progress.toFixed(1)}%`, inline: false }
                    )
                    .setImage('attachment://countdown.png')
                    .setFooter({ text: 'ğŸ® ì˜¤í”ˆ í›„ ëª¨ë“  ê¸°ëŠ¥ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!' })
                    .setTimestamp();
                
                const files = [];
                if (clockBuffer) {
                    files.push(new AttachmentBuilder(clockBuffer, { name: 'countdown.png' }));
                }
                
                const message = await channel.send({ embeds: [countdownEmbed], files });
                openCountdown.messageId = message.id;
                
                // ì—…ë°ì´íŠ¸ ì¹´ìš´í„° (ì´ë¯¸ì§€ ì—…ë°ì´íŠ¸ ì£¼ê¸° ì¡°ì ˆìš©)
                let updateCounter = 0;
                
                // 1ì´ˆë§ˆë‹¤ ì—…ë°ì´íŠ¸
                openCountdown.interval = setInterval(async () => {
                    try {
                        const remaining = openCountdown.launchTime - Date.now();
                        updateCounter++;
                        
                        if (remaining <= 0) {
                            // ì¹´ìš´íŠ¸ë‹¤ìš´ ì¢…ë£Œ
                            clearInterval(openCountdown.interval);
                            openCountdown.isActive = false;
                            
                            // ì¶•í•˜ ì´ë¯¸ì§€ ìƒì„±
                            const celebrationBuffer = await createCelebrationImage();
                            
                            const launchEmbed = new EmbedBuilder()
                                .setColor('#00ff00')
                                .setTitle('ğŸ‰ ê¹€í—Œí„° RPG ì •ì‹ ì˜¤í”ˆ!')
                                .setDescription('**ê²Œì„ì´ ì˜¤í”ˆë˜ì—ˆìŠµë‹ˆë‹¤!**\nì´ì œ ëª¨ë“  ê¸°ëŠ¥ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!')
                                .setImage('attachment://celebration.png')
                                .setFooter({ text: 'ğŸ® ì¦ê±°ìš´ ê²Œì„ ë˜ì„¸ìš”!' })
                                .setTimestamp();
                            
                            const files = [];
                            if (celebrationBuffer) {
                                files.push(new AttachmentBuilder(celebrationBuffer, { name: 'celebration.png' }));
                            }
                            
                            await message.edit({ embeds: [launchEmbed], files });
                            
                            // ì „ì²´ ê³µì§€
                            await channel.send('@everyone ğŸŠ **ê¹€í—Œí„° RPGê°€ ì •ì‹ ì˜¤í”ˆë˜ì—ˆìŠµë‹ˆë‹¤!**');
                        } else {
                            // ì¹´ìš´íŠ¸ë‹¤ìš´ ì—…ë°ì´íŠ¸
                            const updateDays = Math.floor(remaining / (1000 * 60 * 60 * 24));
                            const updateHours = Math.floor((remaining % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                            const updateMinutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
                            const updateSeconds = Math.floor((remaining % (1000 * 60)) / 1000);
                            
                            // ì¹´ìš´íŠ¸ë‹¤ìš´ ë””ìŠ¤í”Œë ˆì´ ì—…ë°ì´íŠ¸
                            let countdownDisplay;
                            if (updateDays > 0) {
                                countdownDisplay = `\`\`\`fix\n${String(updateDays).padStart(2, '0')}ì¼ ${String(updateHours).padStart(2, '0')}:${String(updateMinutes).padStart(2, '0')}:${String(updateSeconds).padStart(2, '0')}\n\`\`\``;
                            } else if (updateHours > 0) {
                                countdownDisplay = `\`\`\`fix\n${String(updateHours).padStart(2, '0')}:${String(updateMinutes).padStart(2, '0')}:${String(updateSeconds).padStart(2, '0')}\n\`\`\``;
                            } else {
                                // 1ì‹œê°„ ë¯¸ë§Œì¼ ë•Œ ë” í° ë””ìŠ¤í”Œë ˆì´
                                countdownDisplay = `\`\`\`css\n[${String(updateMinutes).padStart(2, '0')}:${String(updateSeconds).padStart(2, '0')}]\n\`\`\``;
                            }
                            
                            // ë§ˆì§€ë§‰ ì¹´ìš´íŠ¸ë‹¤ìš´ íš¨ê³¼
                            let specialEffect = '';
                            if (remaining < 60000 && remaining > 30000) {
                                // 1ë¶„ ë¯¸ë§Œ
                                specialEffect = '\nâ° **ê³§ ì˜¤í”ˆë©ë‹ˆë‹¤!**';
                            } else if (remaining < 30000 && remaining > 10000) {
                                // 30ì´ˆ ë¯¸ë§Œ
                                specialEffect = '\nğŸ”¥ **30ì´ˆ ë‚¨ì•˜ìŠµë‹ˆë‹¤!** ğŸ”¥';
                            } else if (remaining < 11000 && remaining > 0) {
                                // 10ì´ˆ ë¯¸ë§Œ
                                const finalSeconds = Math.ceil(remaining / 1000);
                                const emojis = ['ğŸš¨', 'âš¡', 'ğŸ’¥', 'ğŸ¯', 'ğŸ”¥'];
                                const emoji = emojis[finalSeconds % emojis.length];
                                specialEffect = `\n${emoji} **${finalSeconds}** ${emoji}`;
                                
                                // 5ì´ˆ ë¯¸ë§Œì¼ ë•Œ ì¶”ê°€ íš¨ê³¼
                                if (finalSeconds <= 5) {
                                    specialEffect += '\n' + 'ğŸ‰'.repeat(finalSeconds);
                                }
                            }
                            
                            // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
                            const totalTime = openCountdown.totalTime;
                            const elapsed = totalTime - remaining;
                            const progress = Math.max(0, Math.min(100, (elapsed / totalTime) * 100));
                            const barLength = 20;
                            const filledLength = Math.floor((progress / 100) * barLength);
                            const progressBar = 'ğŸŸ©'.repeat(filledLength) + 'â¬œ'.repeat(barLength - filledLength);
                            
                            // ìƒ‰ìƒ ë³€ê²½ (ë‚¨ì€ ì‹œê°„ì— ë”°ë¼)
                            let embedColor = '#ff0000'; // ë¹¨ê°•
                            if (remaining < 60 * 60 * 1000) embedColor = '#ff6600'; // ì£¼í™© (1ì‹œê°„ ë¯¸ë§Œ)
                            if (remaining < 10 * 60 * 1000) embedColor = '#ffff00'; // ë…¸ë‘ (10ë¶„ ë¯¸ë§Œ)
                            if (remaining < 60 * 1000) embedColor = '#00ff00'; // ì´ˆë¡ (1ë¶„ ë¯¸ë§Œ)
                            
                            // ì„ë² ë“œ ì—…ë°ì´íŠ¸
                            const description = specialEffect 
                                ? `**ëª¨ë“  ê¸°ëŠ¥ì´ ì ê²¨ìˆìŠµë‹ˆë‹¤!**\nì˜¤í”ˆ ì‹œê°„ê¹Œì§€ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”!${specialEffect}`
                                : '**ëª¨ë“  ê¸°ëŠ¥ì´ ì ê²¨ìˆìŠµë‹ˆë‹¤!**\nì˜¤í”ˆ ì‹œê°„ê¹Œì§€ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”!';
                            
                            const updatedEmbed = new EmbedBuilder()
                                .setColor(embedColor)
                                .setTitle('ğŸš€ ê¹€í—Œí„° RPG ì •ì‹ ì˜¤í”ˆ ì¹´ìš´íŠ¸ë‹¤ìš´!')
                                .setDescription(description)
                                .addFields(
                                    { name: 'â° ì˜¤í”ˆ ì˜ˆì • ì‹œê°„', value: `<t:${Math.floor(openCountdown.launchTime.getTime() / 1000)}:F>`, inline: false },
                                    { name: 'ğŸ• ì‹¤ì‹œê°„ ì¹´ìš´íŠ¸ë‹¤ìš´', value: countdownDisplay, inline: false },
                                    { name: 'ğŸ“Š ì§„í–‰ë¥ ', value: `${progressBar} ${progress.toFixed(1)}%`, inline: false }
                                )
                                .setFooter({ text: 'ğŸ® ì˜¤í”ˆ í›„ ëª¨ë“  ê¸°ëŠ¥ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!' })
                                .setTimestamp();
                            
                            // 10ì´ˆë§ˆë‹¤ ë˜ëŠ” ì²˜ìŒì—ë§Œ ì´ë¯¸ì§€ ì—…ë°ì´íŠ¸
                            if (updateCounter % 10 === 1) {
                                const newClockBuffer = await createCountdownClock(remaining);
                                updatedEmbed.setImage('attachment://countdown.png');
                                
                                const files = [];
                                if (newClockBuffer) {
                                    files.push(new AttachmentBuilder(newClockBuffer, { name: 'countdown.png' }));
                                }
                                
                                await message.edit({ embeds: [updatedEmbed], files });
                            } else {
                                // í…ìŠ¤íŠ¸ë§Œ ì—…ë°ì´íŠ¸ (ì´ë¯¸ì§€ëŠ” ìœ ì§€)
                                updatedEmbed.setImage(message.embeds[0].image?.url || 'attachment://countdown.png');
                                await message.edit({ embeds: [updatedEmbed] });
                            }
                        }
                    } catch (error) {
                        console.error('ì¹´ìš´íŠ¸ë‹¤ìš´ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:', error);
                    }
                }, 1000); // 1ì´ˆë§ˆë‹¤ ì—…ë°ì´íŠ¸
                
                await interaction.reply({ content: `âœ… ${hours}ì‹œê°„ ì¹´ìš´íŠ¸ë‹¤ìš´ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤!`, flags: 64 });
                
            } else if (subcommand === 'ì¤‘ì§€') {
                if (openCountdown.interval) {
                    clearInterval(openCountdown.interval);
                }
                openCountdown.isActive = false;
                openCountdown.interval = null;
                
                await interaction.reply({ content: 'âœ… ì¹´ìš´íŠ¸ë‹¤ìš´ì´ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤!', flags: 64 });
            }
        }
        
        else if (commandName === 'ê²Œì„ë°ì´í„°ì´ˆê¸°í™”') {
            // ê´€ë¦¬ì ê¶Œí•œ ì²´í¬
            if (!isAdmin(interaction.user.id)) {
                await interaction.reply({ content: 'âŒ ê´€ë¦¬ìë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ëª…ë ¹ì–´ì…ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            try {
                // ëª¨ë“  ê²Œì„ ë°ì´í„° ì´ˆê¸°í™”
                AUCTION_HOUSE.listings.clear();
                AUCTION_HOUSE.priceHistory.clear();
                AUCTION_HOUSE.marketVolume.clear();
                AUCTION_HOUSE.topItems = [];
                AUCTION_HOUSE.events = [];
                
                currentWeather = null;
                dailyFortune = null;
                activeMissions.clear();
                lastMarketUpdate = 0;
                currentMarketEvent = null;
                
                // íŒŒì¼ì—ë„ ì €ì¥
                saveGameData();
                
                await interaction.reply({ 
                    content: 'âœ… **ê²Œì„ ë°ì´í„°ê°€ ì™„ì „íˆ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤!**\n\në‹¤ìŒ ë°ì´í„°ê°€ ì´ˆê¸°í™”ë¨:\nâ€¢ ê²½ë§¤ì¥ ë°ì´í„°\nâ€¢ ë‚ ì”¨ ì •ë³´\nâ€¢ ëœë¤ ì´ë²¤íŠ¸\nâ€¢ ì‹œì¥ ì´ë²¤íŠ¸', 
                    flags: 64 
                });
                
                console.log(`ê²Œì„ ë°ì´í„° ì´ˆê¸°í™” ì‹¤í–‰ë¨ - ê´€ë¦¬ì: ${interaction.user.tag}`);
                
            } catch (error) {
                console.error('ê²Œì„ ë°ì´í„° ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
                await interaction.reply({ content: 'âŒ ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤!', flags: 64 });
            }
        }
        
        // ğŸ”® ì—ë„ˆì§€ ì¡°ê° ì‹œìŠ¤í…œ ëª…ë ¹ì–´ë“¤
        else if (commandName === 'ì—ë„ˆì§€ì±„êµ´') {
            const user = await getUser(interaction.user.id);
            
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            // ì¿¨íƒ€ì„ ì²´í¬
            const now = Date.now();
            if (user.energyFragments.lastMine) {
                const timeSinceLastMine = now - new Date(user.energyFragments.lastMine).getTime();
                const cooldownRemaining = ENERGY_FRAGMENT_SYSTEM.MINE_COOLDOWN - timeSinceLastMine;
                
                if (cooldownRemaining > 0) {
                    const remainingSeconds = Math.ceil(cooldownRemaining / 1000);
                    const minutes = Math.floor(remainingSeconds / 60);
                    const seconds = remainingSeconds % 60;
                    
                    await interaction.reply({ 
                        content: `â° ì±„êµ´ ì¿¨íƒ€ì„ì´ **${minutes}ë¶„ ${seconds}ì´ˆ** ë‚¨ì•˜ìŠµë‹ˆë‹¤!`, 
                        flags: 64 
                    });
                    return;
                }
            }
            
            // ê³¨ë“œ ì²´í¬
            if (user.gold < ENERGY_FRAGMENT_SYSTEM.MINE_COST) {
                await interaction.reply({ 
                    content: `ğŸ’¸ ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤! í•„ìš”: ${ENERGY_FRAGMENT_SYSTEM.MINE_COST}G, ë³´ìœ : ${user.gold}G`, 
                    flags: 64 
                });
                return;
            }
            
            // ì±„êµ´ ì‹¤í–‰
            user.gold -= ENERGY_FRAGMENT_SYSTEM.MINE_COST;
            user.energyFragments.lastMine = new Date();
            
            // ì¡°ê° íšë“ (Map ì²˜ë¦¬)
            const fragments = new Map(user.energyFragments.fragments);
            const currentLevel1 = fragments.get('1') || 0;
            fragments.set('1', currentLevel1 + 1);
            user.energyFragments.fragments = fragments;
            
            // ìµœê³  ë ˆë²¨ ì—…ë°ì´íŠ¸
            if (user.energyFragments.highestLevel === 0) {
                user.energyFragments.highestLevel = 1;
            }
            
            await user.save();
            
            const fragmentInfo = getFragmentInfo(1);
            // ìœµí•© ê°€ëŠ¥í•œ ì¡°ê° í™•ì¸
            const allFragments = new Map(user.energyFragments.fragments);
            let fusibleFragments = [];
            
            for (const [level, count] of allFragments.entries()) {
                if (count >= 2) {
                    const levelNum = parseInt(level);
                    const info = getFragmentInfo(levelNum);
                    fusibleFragments.push(`${info.emoji} ${levelNum}ë‹¨ê³„ (${count}ê°œ)`);
                }
            }
            
            // í˜„ì¬ ìµœê³  ë ˆë²¨ ì¡°ê° í‘œì‹œ
            let highestLevelText = `ğŸ”¸ Lv.1 (${currentLevel1 + 1}ê°œ)`;
            if (allFragments.size > 0) {
                const sortedLevels = Array.from(allFragments.keys())
                    .map(k => parseInt(k))
                    .sort((a, b) => b - a);
                const highest = sortedLevels[0];
                const highestInfo = getFragmentInfo(highest);
                const highestCount = allFragments.get(highest.toString());
                highestLevelText = `${highestInfo.emoji} Lv.${highest} (${highestCount}ê°œ)`;
            }
            
            const embed = new EmbedBuilder()
                .setColor('#FFD700')
                .setTitle('â›ï¸ ì—ë„ˆì§€ ì±„êµ´ ì„±ê³µ!')
                .setDescription(`${fragmentInfo.emoji} **${fragmentInfo.name}** 1ê°œë¥¼ íšë“í–ˆìŠµë‹ˆë‹¤!`)
                .addFields(
                    { name: 'ğŸ’° ì‚¬ìš© ê³¨ë“œ', value: `${ENERGY_FRAGMENT_SYSTEM.MINE_COST}G`, inline: true },
                    { name: 'ğŸ’µ ë‚¨ì€ ê³¨ë“œ', value: `${user.gold.toLocaleString()}G`, inline: true },
                    { name: 'â° ì¿¨íƒ€ì„', value: '2ë¶„', inline: true },
                    { name: 'ğŸ”„ ìœµí•© ê°€ëŠ¥ ì¡°ê°', value: fusibleFragments.length > 0 ? fusibleFragments.join('\n') : 'ì—†ìŒ', inline: false },
                    { name: 'â­ ìµœê³  ë³´ìœ  ì¡°ê°', value: highestLevelText, inline: false }
                )
                .setFooter({ text: 'ğŸ’¡ /ì¡°ê°ìœµí•©ìœ¼ë¡œ ë” ë†’ì€ ë‹¨ê³„ë¡œ ìœµí•©í•˜ì„¸ìš”!' });
                
            await interaction.reply({ embeds: [embed] });
        }
        
        else if (commandName === 'ë‚´ì¡°ê°') {
            const user = await getUser(interaction.user.id);
            
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            const fragments = new Map(user.energyFragments.fragments);
            
            // ë³´ìœ  ì¡°ê°ì´ ì—†ëŠ” ê²½ìš°
            if (fragments.size === 0) {
                const embed = new EmbedBuilder()
                    .setColor('#ff6b6b')
                    .setTitle('ğŸ’ ì—ë„ˆì§€ ì¡°ê° ë³´ê´€í•¨')
                    .setDescription('ë³´ìœ í•œ ì—ë„ˆì§€ ì¡°ê°ì´ ì—†ìŠµë‹ˆë‹¤!')
                    .setFooter({ text: 'ğŸ’¡ /ì—ë„ˆì§€ì±„êµ´ë¡œ ì¡°ê°ì„ íšë“í•˜ì„¸ìš”!' });
                    
                await interaction.reply({ embeds: [embed], flags: 64 });
                return;
            }
            
            // ì¡°ê° ì •ë ¬ ë° í‘œì‹œ
            const sortedFragments = Array.from(fragments.entries())
                .sort((a, b) => parseInt(a[0]) - parseInt(b[0]));
            
            let fragmentText = '';
            let totalFragments = 0;
            let totalCombatPower = 0;
            
            for (const [level, count] of sortedFragments) {
                const levelNum = parseInt(level);
                const info = getFragmentInfo(levelNum);
                const combatPower = calculateCombatPowerFromFragment(levelNum) * count;
                totalCombatPower += combatPower;
                totalFragments += count;
                
                fragmentText += `${info.emoji} **${levelNum}ë‹¨ê³„** - ${info.name}\n`;
                fragmentText += `   ë³´ìœ : ${count}ê°œ | ì „íˆ¬ë ¥: ${combatPower.toLocaleString()}\n\n`;
            }
            
            const embed = new EmbedBuilder()
                .setColor('#00CED1')
                .setTitle('ğŸ’ ì—ë„ˆì§€ ì¡°ê° ë³´ê´€í•¨')
                .setDescription(`**${user.nickname}**ë‹˜ì˜ ì—ë„ˆì§€ ì¡°ê° í˜„í™©`)
                .addFields(
                    { name: 'ğŸ“¦ ë³´ìœ  ì¡°ê°', value: fragmentText || 'ì—†ìŒ', inline: false },
                    { name: 'ğŸ“Š í†µê³„', value: `ì´ ì¡°ê°: ${totalFragments}ê°œ\nì „íˆ¬ë ¥ í•©ê³„: ${totalCombatPower.toLocaleString()}\nìµœê³  ë ˆë²¨: ${user.energyFragments.highestLevel}ë‹¨ê³„`, inline: true },
                    { name: 'ğŸ”§ ìœµí•© ì •ë³´', value: `ì˜¤ëŠ˜ ìœµí•©: ${user.energyFragments.dailyFusions}/20íšŒ\nì‹¤íŒ¨ ìŠ¤íƒ: ${user.energyFragments.failureStack}/10\nì—°ì† ì„±ê³µ: ${user.energyFragments.consecutiveSuccess}íšŒ`, inline: true }
                )
                .setFooter({ text: 'ğŸ’¡ ê°™ì€ ë‹¨ê³„ ì¡°ê° 2ê°œë¥¼ ëª¨ì•„ì„œ /ì¡°ê°ìœµí•©ìœ¼ë¡œ ìƒìœ„ ë‹¨ê³„ë¡œ ì—…ê·¸ë ˆì´ë“œí•˜ì„¸ìš”!' });
                
            await interaction.reply({ embeds: [embed], flags: 64 });
        }
        
        else if (commandName === 'ì¡°ê°ìœµí•©') {
            const user = await getUser(interaction.user.id);
            
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            // ì¼ì¼ ìœµí•© ì œí•œ ì²´í¬
            const today = new Date().toDateString();
            if (user.energyFragments.dailyFusionDate !== today) {
                user.energyFragments.dailyFusions = 0;
                user.energyFragments.dailyFusionDate = today;
            }
            
            // ë¬´ì œí•œ ìœµí•©ê¶Œ ì‚¬ìš© ê°€ëŠ¥ ì²´í¬
            const hasTicket = user.energyFragments.fusionTickets > 0;
            
            if (!hasTicket && user.energyFragments.dailyFusions >= ENERGY_FRAGMENT_SYSTEM.DAILY_FUSION_LIMIT) {
                await interaction.reply({ 
                    content: `ğŸš« ì˜¤ëŠ˜ì˜ ìœµí•© íšŸìˆ˜ë¥¼ ëª¨ë‘ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤! (${ENERGY_FRAGMENT_SYSTEM.DAILY_FUSION_LIMIT}/20íšŒ)\nğŸ’¡ ë‚´ì¼ ë‹¤ì‹œ ì‹œë„í•˜ê±°ë‚˜ ìœµí•©ê¶Œì„ ì‚¬ìš©í•˜ì„¸ìš”!`, 
                    flags: 64 
                });
                return;
            }
            
            await interaction.deferReply();
            
            const fragments = new Map(user.energyFragments.fragments);
            let fusionResults = [];
            let totalCost = 0;
            let fusionsPerformed = 0;
            
            // ìœµí•© ê°€ëŠ¥í•œ ì¡°ê° ì°¾ê¸° (ë‚®ì€ ë ˆë²¨ë¶€í„°)
            const sortedLevels = Array.from(fragments.keys())
                .map(k => parseInt(k))
                .sort((a, b) => a - b);
            
            for (const level of sortedLevels) {
                while (fragments.get(level.toString()) >= 2) {
                    // ì¼ì¼ ì œí•œ ì²´í¬
                    if (!hasTicket && user.energyFragments.dailyFusions + fusionsPerformed >= ENERGY_FRAGMENT_SYSTEM.DAILY_FUSION_LIMIT) {
                        break;
                    }
                    
                    const count = fragments.get(level.toString());
                    const cost = calculateFusionCost(level);
                    
                    // ê³¨ë“œ ì²´í¬
                    if (user.gold < cost) {
                        fusionResults.push({
                            level,
                            result: 'no_gold',
                            cost
                        });
                        break;
                    }
                    
                    // ìœµí•© ì‹œë„
                    user.gold -= cost;
                    totalCost += cost;
                    fragments.set(level.toString(), count - 2);
                    
                    // ì„±ê³µ í™•ë¥  ê³„ì‚°
                    let successRate = getSuccessRate(level);
                    
                    // ê°•í™” ì¥ë¹„ ë³´ë„ˆìŠ¤
                    let enhanceBonus = 0;
                    for (const equipment of Object.values(user.equipment)) {
                        if (equipment && equipment.enhanceLevel >= 20) {
                            if (equipment.enhanceLevel >= 30) enhanceBonus = 15;
                            else if (equipment.enhanceLevel >= 25) enhanceBonus = 10;
                            else enhanceBonus = 5;
                            break;
                        }
                    }
                    successRate += enhanceBonus;
                    
                    // ë­í‚¹ ë³´ë„ˆìŠ¤
                    successRate += user.energyFragments.permanentSuccessBonus;
                    successRate += user.energyFragments.weeklyRankingBonus;
                    
                    // ì‹¤íŒ¨ ìŠ¤íƒ ì²´í¬
                    const guaranteedSuccess = user.energyFragments.failureStack >= ENERGY_FRAGMENT_SYSTEM.FAILURE_STACK_REQUIRED;
                    
                    const roll = Math.random() * 100;
                    const success = guaranteedSuccess || roll < successRate;
                    
                    if (success) {
                        // ì„±ê³µ
                        const newLevel = level + 1;
                        const currentCount = fragments.get(newLevel.toString()) || 0;
                        fragments.set(newLevel.toString(), currentCount + 1);
                        
                        user.energyFragments.successfulFusions++;
                        user.energyFragments.consecutiveSuccess++;
                        user.energyFragments.failureStack = 0;
                        
                        // ìµœê³  ë ˆë²¨ ì—…ë°ì´íŠ¸
                        if (newLevel > user.energyFragments.highestLevel) {
                            user.energyFragments.highestLevel = newLevel;
                        }
                        
                        // ê³¨ë“œ ë³´ìƒ
                        const reward = newLevel * 500;
                        user.gold += reward;
                        
                        fusionResults.push({
                            level,
                            newLevel,
                            result: 'success',
                            cost,
                            reward,
                            guaranteedSuccess
                        });
                        
                        // 100ë‹¨ê³„ ë‹¬ì„±!
                        if (newLevel === 100) {
                            // 100ë‹¨ê³„ íŠ¹ë³„ ë³´ìƒ
                            user.gold += 1000000; // 100ë§Œ ê³¨ë“œ ë³´ìƒ
                            user.energyFragments.permanentSuccessBonus += 10; // ì˜êµ¬ ì„±ê³µë¥  10% ì¶”ê°€
                            
                            // íŠ¹ë³„ ì¹­í˜¸ ë¶€ì—¬
                            if (!user.emblem || user.emblem !== 'ì—ë„ˆì§€ì˜ ì‹ ') {
                                user.emblem = 'ì—ë„ˆì§€ì˜ ì‹ ';
                            }
                            
                            // ì„œë²„ ì „ì²´ ê³µì§€
                            const announceChannel = interaction.guild.channels.cache.find(ch => ch.name === 'ê³µì§€' || ch.name === 'general');
                            if (announceChannel) {
                                const announceEmbed = new EmbedBuilder()
                                    .setColor('#FFD700')
                                    .setTitle('ğŸŒŸ ì „ì„¤ì˜ 100ë‹¨ê³„ ì—ë„ˆì§€ ì¡°ê° ë‹¬ì„±! ğŸŒŸ')
                                    .setDescription(`**${user.nickname}**ë‹˜ì´ ìµœì´ˆë¡œ 100ë‹¨ê³„ ì—ë„ˆì§€ ì¡°ê°ì„ ì™„ì„±í–ˆìŠµë‹ˆë‹¤!`)
                                    .addFields(
                                        { name: 'ğŸ† ë³´ìƒ', value: '100ë§Œ ê³¨ë“œ + ì˜êµ¬ ì„±ê³µë¥  10% + ì¹­í˜¸: ì—ë„ˆì§€ì˜ ì‹ ', inline: false }
                                    )
                                    .setTimestamp();
                                
                                announceChannel.send({ embeds: [announceEmbed] });
                            }
                        }
                    } else {
                        // ì‹¤íŒ¨
                        const criticalFail = Math.random() * 100 < ENERGY_FRAGMENT_SYSTEM.CRITICAL_FAIL_CHANCE;
                        
                        if (criticalFail) {
                            // ëŒ€ì‹¤íŒ¨ - 1ë‹¨ê³„ë¡œ
                            const currentLevel1 = fragments.get('1') || 0;
                            fragments.set('1', currentLevel1 + 1);
                            fusionResults.push({
                                level,
                                result: 'critical_fail',
                                cost
                            });
                        } else {
                            // ì¼ë°˜ ì‹¤íŒ¨
                            const dropAmount = Math.floor(Math.random() * 
                                (ENERGY_FRAGMENT_SYSTEM.FAIL_DROP.max - ENERGY_FRAGMENT_SYSTEM.FAIL_DROP.min + 1)) + 
                                ENERGY_FRAGMENT_SYSTEM.FAIL_DROP.min;
                            const newLevel = Math.max(1, level - dropAmount);
                            const currentCount = fragments.get(newLevel.toString()) || 0;
                            fragments.set(newLevel.toString(), currentCount + 1);
                            
                            fusionResults.push({
                                level,
                                newLevel,
                                result: 'fail',
                                cost,
                                dropAmount
                            });
                        }
                        
                        // ì‹¤íŒ¨ ìŠ¤íƒ
                        if (Math.random() * 100 < ENERGY_FRAGMENT_SYSTEM.FAILURE_STACK_CHANCE) {
                            user.energyFragments.failureStack++;
                        }
                        
                        user.energyFragments.consecutiveSuccess = 0;
                    }
                    
                    user.energyFragments.totalFusions++;
                    fusionsPerformed++;
                    
                    if (!hasTicket) {
                        user.energyFragments.dailyFusions++;
                    }
                }
            }
            
            // ë¹ˆ ì¡°ê° ì œê±°
            for (const [key, value] of fragments.entries()) {
                if (value === 0) {
                    fragments.delete(key);
                }
            }
            
            user.energyFragments.fragments = fragments;
            user.energyFragments.totalInvested += totalCost;
            
            // ìœµí•©ê¶Œ ì‚¬ìš©
            if (hasTicket && fusionsPerformed > 0) {
                user.energyFragments.fusionTickets--;
            }
            
            await user.save();
            
            // ê²°ê³¼ í‘œì‹œ
            if (fusionResults.length === 0) {
                const embed = new EmbedBuilder()
                    .setColor('#ff6b6b')
                    .setTitle('ğŸ”„ ìœµí•© ë¶ˆê°€')
                    .setDescription('ìœµí•© ê°€ëŠ¥í•œ ì¡°ê°ì´ ì—†ìŠµë‹ˆë‹¤!\nê°™ì€ ë‹¨ê³„ ì¡°ê°ì„ 2ê°œ ì´ìƒ ëª¨ì•„ì£¼ì„¸ìš”.')
                    .setFooter({ text: 'ğŸ’¡ /ì—ë„ˆì§€ì±„êµ´ë¡œ ë” ë§ì€ ì¡°ê°ì„ íšë“í•˜ì„¸ìš”!' });
                    
                await interaction.editReply({ embeds: [embed] });
                return;
            }
            
            // ê²°ê³¼ ì„ë² ë“œ ìƒì„±
            let resultText = '';
            let totalReward = 0;
            let successCount = 0;
            
            for (const result of fusionResults) {
                const info = getFragmentInfo(result.level);
                
                if (result.result === 'success') {
                    const newInfo = getFragmentInfo(result.newLevel);
                    resultText += `âœ… ${info.emoji} ${result.level}ë‹¨ê³„ â†’ ${newInfo.emoji} **${result.newLevel}ë‹¨ê³„** ì„±ê³µ!\n`;
                    resultText += `   ğŸ’° ë¹„ìš©: ${result.cost}G | ë³´ìƒ: ${result.reward}G\n`;
                    if (result.guaranteedSuccess) {
                        resultText += `   ğŸ¯ ì‹¤íŒ¨ ìŠ¤íƒ 10ê°œë¡œ ì„±ê³µ í™•ì •!\n`;
                    }
                    totalReward += result.reward;
                    successCount++;
                } else if (result.result === 'fail') {
                    const newInfo = getFragmentInfo(result.newLevel);
                    resultText += `âŒ ${info.emoji} ${result.level}ë‹¨ê³„ â†’ ${newInfo.emoji} ${result.newLevel}ë‹¨ê³„ ì‹¤íŒ¨ (-${result.dropAmount})\n`;
                    resultText += `   ğŸ’¸ ë¹„ìš©: ${result.cost}G\n`;
                } else if (result.result === 'critical_fail') {
                    resultText += `ğŸ’¥ ${info.emoji} ${result.level}ë‹¨ê³„ â†’ ğŸ”¸ 1ë‹¨ê³„ ëŒ€ì‹¤íŒ¨!\n`;
                    resultText += `   ğŸ’¸ ë¹„ìš©: ${result.cost}G\n`;
                } else if (result.result === 'no_gold') {
                    resultText += `ğŸ’¸ ${info.emoji} ${result.level}ë‹¨ê³„ ìœµí•© ë¶ˆê°€ - ê³¨ë“œ ë¶€ì¡± (í•„ìš”: ${result.cost}G)\n`;
                }
                resultText += '\n';
            }
            
            const embed = new EmbedBuilder()
                .setColor(successCount > 0 ? '#00ff00' : '#ff6b6b')
                .setTitle('ğŸ”„ ìë™ ìœµí•© ê²°ê³¼')
                .setDescription(`**${fusionResults.length}íšŒ** ìœµí•© ì‹œë„`)
                .addFields(
                    { name: 'ğŸ“Š ìœµí•© ë‚´ì—­', value: resultText || 'ì—†ìŒ', inline: false },
                    { name: 'ğŸ’° ë¹„ìš©/ìˆ˜ìµ', value: `ì‚¬ìš©: ${totalCost.toLocaleString()}G\níšë“: ${totalReward.toLocaleString()}G\nìˆœìµ: ${(totalReward - totalCost).toLocaleString()}G`, inline: true },
                    { name: 'ğŸ“ˆ í†µê³„', value: `ì„±ê³µ: ${successCount}/${fusionResults.length}íšŒ\nì‹¤íŒ¨ ìŠ¤íƒ: ${user.energyFragments.failureStack}/10\në‚¨ì€ ìœµí•©: ${hasTicket ? 'ë¬´ì œí•œ' : `${ENERGY_FRAGMENT_SYSTEM.DAILY_FUSION_LIMIT - user.energyFragments.dailyFusions}/20íšŒ`}`, inline: true }
                )
                .setFooter({ text: 'ğŸ’¡ ì‹¤íŒ¨ ìŠ¤íƒ 10ê°œ ëª¨ìœ¼ë©´ ë‹¤ìŒ ìœµí•©ì´ ì„±ê³µ í™•ì •!' });
                
            await interaction.editReply({ embeds: [embed] });
        }
        
        else if (commandName === 'ê²°íˆ¬') {
            await interaction.deferReply({ flags: 64 });
            
            const user = await getUser(interaction.user.id);
            
            if (!user || !user.registered) {
                await interaction.editReply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!' });
                return;
            }

            const result = await pvpSystem.joinQueue(interaction.user.id, user, interaction.channel);
            
            if (result.success) {
                const embed = new EmbedBuilder()
                    .setColor('#ff6b6b')
                    .setTitle('âš”ï¸ PVP ë§¤ì¹˜ë©”ì´í‚¹')
                    .setDescription(result.message)
                    .addFields(
                        { name: 'ğŸ’³ ë³´ìœ  ê²°íˆ¬ê¶Œ', value: `${result.tickets || user.pvp.duelTickets}/20`, inline: true },
                        { name: 'ğŸ† í˜„ì¬ ë ˆì´íŒ…', value: `${user.pvp.rating} (${user.pvp.tier})`, inline: true }
                    )
                    .setFooter({ text: 'ë§¤ì¹˜ê°€ ì„±ì‚¬ë˜ë©´ ìë™ìœ¼ë¡œ ì „íˆ¬ê°€ ì‹œì‘ë©ë‹ˆë‹¤!' });

                const cancelButton = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('cancel_pvp_queue')
                            .setLabel('âŒ ë§¤ì¹˜ë©”ì´í‚¹ ì·¨ì†Œ')
                            .setStyle(ButtonStyle.Danger)
                    );

                await interaction.editReply({ 
                    embeds: [embed], 
                    components: [cancelButton]
                });
            } else {
                await interaction.editReply({ content: `âŒ ${result.message}` });
            }
        }
        
        else if (commandName === 'ê²°íˆ¬ì •ë³´') {
            await interaction.deferReply({ flags: 64 });
            
            const user = await getUser(interaction.user.id);
            
            if (!user || !user.registered) {
                await interaction.editReply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!' });
                return;
            }

            const pvpInfo = await pvpSystem.getPVPInfo(user);
            
            let matchHistoryText = '';
            if (pvpInfo.matchHistory.length > 0) {
                pvpInfo.matchHistory.slice(0, 5).forEach((match, index) => {
                    const resultEmoji = match.result === 'win' ? 'ğŸ†' : 'ğŸ’”';
                    const ratingText = match.ratingChange > 0 ? `+${match.ratingChange}` : `${match.ratingChange}`;
                    matchHistoryText += `${resultEmoji} vs ${match.opponent} (${ratingText})\n`;
                });
            } else {
                matchHistoryText = 'ì•„ì§ ê²°íˆ¬ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.';
            }

            const embed = new EmbedBuilder()
                .setColor('#ff6b6b')
                .setTitle(`âš”ï¸ ${user.nickname}ë‹˜ì˜ PVP ì •ë³´`)
                .addFields(
                    { name: `${pvpInfo.tierEmoji} í‹°ì–´`, value: `${pvpInfo.tier}`, inline: true },
                    { name: 'ğŸ† ë ˆì´íŒ…', value: `${pvpInfo.rating}`, inline: true },
                    { name: 'ğŸ’³ ê²°íˆ¬ê¶Œ', value: `${pvpInfo.duelTickets}/20`, inline: true },
                    { name: 'ğŸ“Š ì „ì ', value: `${pvpInfo.wins}ìŠ¹ ${pvpInfo.losses}íŒ¨ (${pvpInfo.winRate}%)`, inline: true },
                    { name: 'ğŸ”¥ ì—°ìŠ¹', value: `${pvpInfo.winStreak}ì—°ìŠ¹ (ìµœê³ : ${pvpInfo.maxWinStreak})`, inline: true },
                    { name: 'ğŸŒŸ ìµœê³  ë ˆì´íŒ…', value: `${pvpInfo.highestRating}`, inline: true },
                    { name: 'ğŸ“œ ìµœê·¼ ê²½ê¸°', value: matchHistoryText, inline: false }
                )
                .setFooter({ text: 'ê²°íˆ¬ê¶Œì€ 1ì‹œê°„ë§ˆë‹¤ 1ì¥ì”© ì¬ìƒì„±ë©ë‹ˆë‹¤!' });

            await interaction.editReply({ embeds: [embed] });
        }
        
        else if (commandName === 'ë­í‚¹') {
            try {
                await interaction.deferReply({ flags: 64 });
                
                const topUsers = await User.find({ registered: true })
                    .sort({ 'pvp.rating': -1 })
                    .limit(10);

                const tierEmoji = {
                    'Bronze': 'ğŸ¥‰',
                    'Silver': 'ğŸ¥ˆ', 
                    'Gold': 'ğŸ¥‡',
                    'Platinum': 'ğŸ’',
                    'Master': 'ğŸŒŸ',
                    'Grandmaster': 'ğŸ‘‘',
                    'Challenger': 'ğŸ†'
                };

                let rankingText = '';
                topUsers.forEach((user, index) => {
                    const tier = pvpSystem.getTierByRating(user.pvp.rating);
                    const emoji = tierEmoji[tier] || 'ğŸ¥‰';
                    const winRate = user.pvp.totalDuels > 0 ? 
                        ((user.pvp.wins / user.pvp.totalDuels) * 100).toFixed(1) : 0;
                    
                    rankingText += `**${index + 1}.** ${emoji} ${user.nickname}\n`;
                    rankingText += `ã€€ã€€ë ˆì´íŒ…: ${user.pvp.rating} | ìŠ¹ë¥ : ${winRate}% (${user.pvp.wins}ìŠ¹ ${user.pvp.losses}íŒ¨)\n\n`;
                });

                const embed = new EmbedBuilder()
                    .setColor('#FFD700')
                    .setTitle('ğŸ† PVP ë­í‚¹')
                    .setDescription(rankingText || 'ì•„ì§ PVP ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.')
                    .setFooter({ text: 'ë ˆì´íŒ…ì€ ELO ì‹œìŠ¤í…œì„ ê¸°ë°˜ìœ¼ë¡œ ê³„ì‚°ë©ë‹ˆë‹¤!' });

                await interaction.editReply({ embeds: [embed] });
            } catch (error) {
                console.error('ë­í‚¹ ì¡°íšŒ ì˜¤ë¥˜:', error);
                if (interaction.deferred) {
                    await interaction.editReply({ content: 'ë­í‚¹ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤!' });
                } else {
                    await interaction.reply({ content: 'ë­í‚¹ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤!', flags: 64 });
                }
            }
        }
        
        else if (commandName === 'ë‚´ì „íˆ¬ë ¥') {
            const user = await getUser(interaction.user.id);
            
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            // ê¸°ë³¸ ì „íˆ¬ë ¥ ê³„ì‚°
            const baseCombatPower = calculateCombatPower(user);
            
            // ì—ë„ˆì§€ ì¡°ê° ì „íˆ¬ë ¥
            const fragments = new Map(user.energyFragments.fragments);
            let fragmentCombatPower = 0;
            let highestFragment = 0;
            
            for (const [level, count] of fragments.entries()) {
                const levelNum = parseInt(level);
                fragmentCombatPower += calculateCombatPowerFromFragment(levelNum) * count;
                if (levelNum > highestFragment) {
                    highestFragment = levelNum;
                }
            }
            
            const totalCombatPower = baseCombatPower + fragmentCombatPower;
            
            // ëª¨í—˜ê°€ ë“±ê¸‰ ê²°ì •
            let adventurerRank = 'ê²¬ìŠµ ëª¨í—˜ê°€';
            let rankEmoji = 'ğŸ”¸';
            
            if (highestFragment >= 76) {
                adventurerRank = 'ê·¸ëœë“œë§ˆìŠ¤í„°';
                rankEmoji = 'ğŸŒŒ';
            } else if (highestFragment >= 51) {
                adventurerRank = 'ë§ˆìŠ¤í„° ëª¨í—˜ê°€';
                rankEmoji = 'â­';
            } else if (highestFragment >= 26) {
                adventurerRank = 'ì—˜ë¦¬íŠ¸ ëª¨í—˜ê°€';
                rankEmoji = 'ğŸ’';
            } else if (highestFragment >= 11) {
                adventurerRank = 'ìˆ™ë ¨ ëª¨í—˜ê°€';
                rankEmoji = 'ğŸ’ ';
            }
            
            if (highestFragment === 100) {
                adventurerRank = 'ğŸ”¥ ê°•í™”ì˜ ì‹  ğŸ”¥';
                rankEmoji = 'âœ¨';
            }
            
            const embed = new EmbedBuilder()
                .setColor('#FFD700')
                .setTitle('âš”ï¸ ì „íˆ¬ë ¥ ì •ë³´')
                .setDescription(`**${user.nickname}**ë‹˜ì˜ ì „íˆ¬ë ¥ ìƒì„¸ ì •ë³´`)
                .addFields(
                    { name: 'ğŸ“Š ê¸°ë³¸ ì „íˆ¬ë ¥', value: `${baseCombatPower.toLocaleString()}`, inline: true },
                    { name: 'ğŸ’ ì¡°ê° ì „íˆ¬ë ¥', value: `${fragmentCombatPower.toLocaleString()}`, inline: true },
                    { name: 'âš”ï¸ ì´ ì „íˆ¬ë ¥', value: `**${totalCombatPower.toLocaleString()}**`, inline: true },
                    { name: `${rankEmoji} ëª¨í—˜ê°€ ë“±ê¸‰`, value: adventurerRank, inline: true },
                    { name: 'ğŸ† ìµœê³  ì¡°ê°', value: `${highestFragment}ë‹¨ê³„`, inline: true },
                    { name: 'ğŸ“ˆ ì„±ê³µë¥  ë³´ë„ˆìŠ¤', value: `+${user.energyFragments.permanentSuccessBonus + user.energyFragments.weeklyRankingBonus}%`, inline: true }
                );
                
            // ì¹­í˜¸ ì •ë³´
            if (highestFragment === 10) embed.addFields({ name: 'ğŸ­ íšë“ ì¹­í˜¸', value: 'ì—ë„ˆì§€ ìˆ˜ì§‘ê°€', inline: false });
            else if (highestFragment === 25) embed.addFields({ name: 'ğŸ­ íšë“ ì¹­í˜¸', value: 'ë§ˆë²• ìœµí•©ì‚¬', inline: false });
            else if (highestFragment === 50) embed.addFields({ name: 'ğŸ­ íšë“ ì¹­í˜¸', value: 'í¬ë¦¬ìŠ¤íƒˆ ë§ˆìŠ¤í„°', inline: false });
            else if (highestFragment === 75) embed.addFields({ name: 'ğŸ­ íšë“ ì¹­í˜¸', value: 'ë³„ë¹›ì˜ í˜„ì', inline: false });
            else if (highestFragment === 99) embed.addFields({ name: 'ğŸ­ íšë“ ì¹­í˜¸', value: 'ì°½ì¡°ì˜ ì‚¬ë„', inline: false });
            else if (highestFragment === 100) embed.addFields({ name: 'ğŸ­ íšë“ ì¹­í˜¸', value: 'âœ¨ ê¶ê·¹ì˜ ê°•í™”ì™• âœ¨', inline: false });
            
            await interaction.reply({ embeds: [embed], flags: 64 });
        }
        
        else if (commandName === 'ìœµí•©ë­í‚¹') {
            await interaction.deferReply();
            
            try {
                const users = await User.find({ 
                    registered: true,
                    'energyFragments.highestLevel': { $gt: 0 }
                }).sort({ 'energyFragments.highestLevel': -1, 'energyFragments.totalFusions': -1 }).limit(50);
                
                if (users.length === 0) {
                    const embed = new EmbedBuilder()
                        .setColor('#ff6b6b')
                        .setTitle('ğŸ† ìœµí•© ë­í‚¹')
                        .setDescription('ì•„ì§ ì—ë„ˆì§€ ì¡°ê°ì„ ë³´ìœ í•œ ì‚¬ìš©ìê°€ ì—†ìŠµë‹ˆë‹¤!');
                        
                    await interaction.editReply({ embeds: [embed] });
                    return;
                }
                
                // ë­í‚¹ ë°ì´í„° ìƒì„±
                let rankingText = '';
                let userRank = null;
                
                for (let i = 0; i < Math.min(10, users.length); i++) {
                    const rankedUser = users[i];
                    const medal = i === 0 ? 'ğŸ¥‡' : i === 1 ? 'ğŸ¥ˆ' : i === 2 ? 'ğŸ¥‰' : `${i + 1}ìœ„`;
                    const fragmentInfo = getFragmentInfo(rankedUser.energyFragments.highestLevel);
                    
                    rankingText += `${medal} **${rankedUser.nickname}**\n`;
                    rankingText += `   ${fragmentInfo.emoji} ${rankedUser.energyFragments.highestLevel}ë‹¨ê³„ | ìœµí•© ${rankedUser.energyFragments.totalFusions}íšŒ\n\n`;
                    
                    if (rankedUser.discordId === interaction.user.id) {
                        userRank = i + 1;
                    }
                }
                
                // ë‚´ ìˆœìœ„ ì°¾ê¸°
                if (!userRank) {
                    const myIndex = users.findIndex(u => u.discordId === interaction.user.id);
                    if (myIndex !== -1) {
                        userRank = myIndex + 1;
                    }
                }
                
                const embed = new EmbedBuilder()
                    .setColor('#FFD700')
                    .setTitle('ğŸ† ì´ë²ˆ ì£¼ ìœµí•© ë­í‚¹')
                    .setDescription('ìµœê³  ë‹¨ê³„ ê¸°ì¤€ TOP 10')
                    .addFields(
                        { name: 'ğŸ“Š ìˆœìœ„', value: rankingText || 'ë°ì´í„° ì—†ìŒ', inline: false }
                    );
                    
                if (userRank) {
                    embed.addFields({ name: 'ğŸ¯ ë‚´ ìˆœìœ„', value: `${userRank}ìœ„`, inline: true });
                }
                
                embed.setFooter({ text: 'ğŸ ë§¤ì£¼ ì¼ìš”ì¼ ìì •ì— ë­í‚¹ ë³´ìƒì´ ì§€ê¸‰ë©ë‹ˆë‹¤!' });
                
                await interaction.editReply({ embeds: [embed] });
                
            } catch (error) {
                console.error('ìœµí•©ë­í‚¹ ì¡°íšŒ ì˜¤ë¥˜:', error);
                await interaction.editReply({ content: 'ë­í‚¹ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤!' });
            }
        }
        
        else if (commandName === 'ìœµí•©ìˆ˜ë™') {
            const user = await getUser(interaction.user.id);
            
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            // ì¼ì¼ ìœµí•© ì œí•œ ì²´í¬
            const today = new Date().toDateString();
            if (user.energyFragments.dailyFusionDate !== today) {
                user.energyFragments.dailyFusions = 0;
                user.energyFragments.dailyFusionDate = today;
            }
            
            // ë¬´ì œí•œ ìœµí•©ê¶Œ ì‚¬ìš© ê°€ëŠ¥ ì²´í¬
            const hasTicket = user.energyFragments.fusionTickets > 0;
            
            if (!hasTicket && user.energyFragments.dailyFusions >= ENERGY_FRAGMENT_SYSTEM.DAILY_FUSION_LIMIT) {
                await interaction.reply({ 
                    content: `ğŸš« ì˜¤ëŠ˜ì˜ ìœµí•© íšŸìˆ˜ë¥¼ ëª¨ë‘ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤! (${ENERGY_FRAGMENT_SYSTEM.DAILY_FUSION_LIMIT}/20íšŒ)\nğŸ’¡ ë‚´ì¼ ë‹¤ì‹œ ì‹œë„í•˜ê±°ë‚˜ ìœµí•©ê¶Œì„ ì‚¬ìš©í•˜ì„¸ìš”!`, 
                    flags: 64 
                });
                return;
            }
            
            const fragments = new Map(user.energyFragments.fragments);
            
            // ìœµí•© ê°€ëŠ¥í•œ ì¡°ê° ì°¾ê¸°
            const fusibleFragments = [];
            for (const [level, count] of fragments.entries()) {
                if (count >= 2) {
                    const levelNum = parseInt(level);
                    const info = getFragmentInfo(levelNum);
                    const cost = calculateFusionCost(levelNum);
                    const successRate = getSuccessRate(levelNum);
                    
                    // ê°•í™” ë³´ë„ˆìŠ¤ ê³„ì‚°
                    let enhanceBonus = 0;
                    for (const equipment of Object.values(user.equipment)) {
                        if (equipment && equipment.enhanceLevel >= 20) {
                            if (equipment.enhanceLevel >= 30) enhanceBonus = 15;
                            else if (equipment.enhanceLevel >= 25) enhanceBonus = 10;
                            else enhanceBonus = 5;
                            break;
                        }
                    }
                    
                    const finalSuccessRate = Math.min(100, successRate + enhanceBonus + user.energyFragments.permanentSuccessBonus + user.energyFragments.weeklyRankingBonus);
                    
                    fusibleFragments.push({
                        level: levelNum,
                        count,
                        info,
                        cost,
                        successRate: finalSuccessRate
                    });
                }
            }
            
            if (fusibleFragments.length === 0) {
                const embed = new EmbedBuilder()
                    .setColor('#ff6b6b')
                    .setTitle('ğŸ¯ ìˆ˜ë™ ìœµí•©')
                    .setDescription('ìœµí•© ê°€ëŠ¥í•œ ì¡°ê°ì´ ì—†ìŠµë‹ˆë‹¤!\nê°™ì€ ë‹¨ê³„ ì¡°ê°ì„ 2ê°œ ì´ìƒ ëª¨ì•„ì£¼ì„¸ìš”.')
                    .setFooter({ text: 'ğŸ’¡ /ì—ë„ˆì§€ì±„êµ´ë¡œ ë” ë§ì€ ì¡°ê°ì„ íšë“í•˜ì„¸ìš”!' });
                    
                await interaction.reply({ embeds: [embed], flags: 64 });
                return;
            }
            
            // ì„ íƒ ë©”ë‰´ ìƒì„± (ìµœëŒ€ 25ê°œ)
            const selectOptions = fusibleFragments.slice(0, 25).map(frag => ({
                label: `${frag.info.name} (Lv.${frag.level})`,
                description: `ë³´ìœ : ${frag.count}ê°œ | ë¹„ìš©: ${frag.cost.toLocaleString()}G | ì„±ê³µë¥ : ${frag.successRate}%`,
                value: `manual_fusion_${frag.level}`,
                emoji: frag.info.emoji
            }));
            
            const selectMenu = new StringSelectMenuBuilder()
                .setCustomId('manual_fusion_select')
                .setPlaceholder('ìœµí•©í•  ì¡°ê°ì„ ì„ íƒí•˜ì„¸ìš”')
                .addOptions(selectOptions);
            
            const row = new ActionRowBuilder().addComponents(selectMenu);
            
            // ì‹¤íŒ¨ ìŠ¤íƒ ì •ë³´
            const stackInfo = user.energyFragments.failureStack >= ENERGY_FRAGMENT_SYSTEM.FAILURE_STACK_REQUIRED ? 
                'ğŸ¯ **ë‹¤ìŒ ìœµí•© ì„±ê³µ í™•ì •!**' : 
                `ì‹¤íŒ¨ ìŠ¤íƒ: ${user.energyFragments.failureStack}/10`;
            
            const embed = new EmbedBuilder()
                .setColor('#00CED1')
                .setTitle('ğŸ¯ ìˆ˜ë™ ìœµí•©')
                .setDescription(`**${user.nickname}**ë‹˜, ìœµí•©í•  ì¡°ê°ì„ ì„ íƒí•˜ì„¸ìš”!`)
                .addFields(
                    { name: 'ğŸ“Š ìœµí•© ìƒíƒœ', value: `ì˜¤ëŠ˜ ìœµí•©: ${user.energyFragments.dailyFusions}/20íšŒ\n${stackInfo}\nì—°ì† ì„±ê³µ: ${user.energyFragments.consecutiveSuccess}íšŒ`, inline: true },
                    { name: 'ğŸ’° ë³´ìœ  ê³¨ë“œ', value: `${user.gold.toLocaleString()}G`, inline: true },
                    { name: 'ğŸ« ìœµí•©ê¶Œ', value: `${user.energyFragments.fusionTickets}ê°œ`, inline: true }
                )
                .setFooter({ text: 'ğŸ’¡ ë†’ì€ ë‹¨ê³„ì¼ìˆ˜ë¡ ì„±ê³µë¥ ì´ ë‚®ì•„ì§‘ë‹ˆë‹¤!' });
                
            await interaction.reply({ embeds: [embed], components: [row], flags: 64 });
        }
        
        else if (commandName === 'í™€ì§') {
            const user = await getUser(interaction.user.id);
            
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }

            await oddEvenGame.showMonsterBattleMenu(interaction);
        }
        
        else if (commandName === 'ì£¼ì‹ë³µêµ¬') {
            // ì£¼ì‹ ë°ì´í„° ë³µêµ¬ ëª…ë ¹ì–´ (ê´€ë¦¬ì ì „ìš©)
            if (interaction.user.id !== '1123609568397836309') { // ë³¸ì¸ ë””ìŠ¤ì½”ë“œ IDë¡œ ë³€ê²½
                await interaction.reply({ content: 'âŒ ê´€ë¦¬ìë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ëª…ë ¹ì–´ì…ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            const targetUser = interaction.options.getUser('ìœ ì €');
            const companyId = interaction.options.getString('ê¸°ì—…');
            const shares = interaction.options.getInteger('ìˆ˜ëŸ‰');
            const avgPrice = interaction.options.getInteger('í‰ê· ê°€');
            
            try {
                const user = await User.findOne({ discordId: targetUser.id });
                if (!user) {
                    await interaction.reply({ content: 'âŒ ìœ ì €ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
                    return;
                }
                
                if (!user.stockPortfolio) {
                    user.stockPortfolio = { stocks: new Map(), totalInvested: 0, lastUpdate: new Date() };
                }
                
                // ì£¼ì‹ ë³µêµ¬
                user.stockPortfolio.stocks.set(companyId, {
                    shares: shares,
                    avgPrice: avgPrice
                });
                
                await user.save();
                
                const company = findCompany(companyId);
                const companyName = company ? company.name : companyId;
                
                await interaction.reply({
                    content: `âœ… **${user.nickname}**ë‹˜ì˜ ì£¼ì‹ì´ ë³µêµ¬ë˜ì—ˆìŠµë‹ˆë‹¤!\nğŸ¢ ${companyName}: ${shares}ì£¼ (í‰ê· ê°€: ${avgPrice.toLocaleString()}ê³¨ë“œ)`,
                    flags: 64
                });
                
            } catch (error) {
                console.error('ì£¼ì‹ ë³µêµ¬ ì˜¤ë¥˜:', error);
                await interaction.reply({ content: 'âŒ ì£¼ì‹ ë³µêµ¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤!', flags: 64 });
            }
        }
        
        else if (commandName === 'ìœ ë¬¼íƒì‚¬') {
            const user = await getUser(interaction.user.id);
            
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            // ë ˆë²¨ ì œí•œ (ë ˆë²¨ 15 ì´ìƒ)
            if (user.level < 15) {
                await interaction.reply({ 
                    content: `ìœ ë¬¼íƒì‚¬ëŠ” **ë ˆë²¨ 15 ì´ìƒ**ë¶€í„° ì´ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤! (í˜„ì¬ ë ˆë²¨: ${user.level})`, 
                    flags: 64 
                });
                return;
            }
            
            await showArtifactExplorationMenu(interaction, user);
        }
        
        else if (commandName === 'ëˆì§€ê¸‰') {
            // ê´€ë¦¬ì ê¶Œí•œ ì²´í¬
            if (!isAdmin(interaction.user.id)) {
                await interaction.reply({ 
                    content: 'âŒ ì´ ëª…ë ¹ì–´ëŠ” ê´€ë¦¬ìë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!', 
                    flags: 64 
                });
                return;
            }
            
            const targetUser = interaction.options.getUser('ìœ ì €');
            const amount = interaction.options.getInteger('ê¸ˆì•¡');
            
            try {
                const user = await getUser(targetUser.id);
                
                if (!user || !user.registered) {
                    await interaction.reply({ 
                        content: 'âŒ í•´ë‹¹ ìœ ì €ë¥¼ ì°¾ì„ ìˆ˜ ì—†ê±°ë‚˜ ê°€ì…í•˜ì§€ ì•Šì€ ìœ ì €ì…ë‹ˆë‹¤!', 
                        flags: 64 
                    });
                    return;
                }
                
                // ê³¨ë“œ ì§€ê¸‰
                user.gold += amount;
                await user.save();
                
                const embed = new EmbedBuilder()
                    .setColor('#2ecc71')
                    .setTitle('ğŸ’° ê³¨ë“œ ì§€ê¸‰ ì™„ë£Œ')
                    .setDescription(`**${targetUser.username}**ë‹˜ì—ê²Œ **${amount.toLocaleString()} ê³¨ë“œ**ë¥¼ ì§€ê¸‰í–ˆìŠµë‹ˆë‹¤!`)
                    .addFields(
                        { name: 'ğŸ’µ ì§€ê¸‰ ê¸ˆì•¡', value: `${amount.toLocaleString()} ê³¨ë“œ`, inline: true },
                        { name: 'ğŸ’° í˜„ì¬ ë³´ìœ  ê³¨ë“œ', value: `${user.gold.toLocaleString()} ê³¨ë“œ`, inline: true }
                    )
                    .setTimestamp();
                
                await interaction.reply({ embeds: [embed] });
                
                // ë¡œê·¸ ë‚¨ê¸°ê¸°
                console.log(`[ê´€ë¦¬ì ê³¨ë“œ ì§€ê¸‰] ${interaction.user.username}(${interaction.user.id})ê°€ ${targetUser.username}(${targetUser.id})ì—ê²Œ ${amount} ê³¨ë“œ ì§€ê¸‰`);
                
            } catch (error) {
                console.error('ê³¨ë“œ ì§€ê¸‰ ì˜¤ë¥˜:', error);
                await interaction.reply({ 
                    content: 'âŒ ê³¨ë“œ ì§€ê¸‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤!', 
                    flags: 64 
                });
            }
        }
        
        else if (commandName === 'ë³´ìŠ¤') {
            // ê´€ë¦¬ì ê¶Œí•œ ì²´í¬
            if (!isAdmin(interaction.user.id)) {
                await interaction.reply({ 
                    content: 'âŒ ì´ ëª…ë ¹ì–´ëŠ” ê´€ë¦¬ìë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!', 
                    flags: 64 
                });
                return;
            }
            
            const subcommand = interaction.options.getSubcommand();
            
            if (subcommand === 'ìŠ¤í°') {
                const bossId = interaction.options.getString('ë³´ìŠ¤');
                const channel = interaction.channel;
                
                // ì´ë¯¸ ë³´ìŠ¤ê°€ ìˆëŠ”ì§€ ì²´í¬
                if (BOSS_SYSTEM.activeBoss) {
                    await interaction.reply({ 
                        content: 'âŒ ì´ë¯¸ í™œì„±í™”ëœ ë³´ìŠ¤ê°€ ìˆìŠµë‹ˆë‹¤!', 
                        flags: 64 
                    });
                    return;
                }
                
                // íŠ¹ì • ë³´ìŠ¤ ìŠ¤í°
                if (bossId) {
                    const boss = BOSS_SYSTEM.bosses.find(b => b.id === bossId);
                    if (boss) {
                        BOSS_SYSTEM.activeBoss = {
                            ...boss,
                            currentHp: boss.hp,
                            spawnTime: Date.now(),
                            endTime: Date.now() + BOSS_SYSTEM.spawnSettings.duration,
                            channelId: channel.id
                        };
                    }
                } else {
                    // ëœë¤ ë³´ìŠ¤ ìŠ¤í°
                    await spawnBoss(channel);
                    await interaction.reply({ 
                        content: 'âœ… ë³´ìŠ¤ê°€ ìŠ¤í°ë˜ì—ˆìŠµë‹ˆë‹¤!', 
                        flags: 64 
                    });
                    return;
                }
                
                // ë³´ìŠ¤ ì¶œí˜„ ì•Œë¦¼ (íŠ¹ì • ë³´ìŠ¤)
                const boss = BOSS_SYSTEM.activeBoss;
                const bossEmbed = new EmbedBuilder()
                    .setColor('#ff0000')
                    .setTitle('ğŸš¨ ë³´ìŠ¤ ì¶œí˜„ ì•Œë¦¼! ğŸš¨')
                    .setDescription(`**${boss.emoji} ${boss.name}**ì´(ê°€) ë‚˜íƒ€ë‚¬ìŠµë‹ˆë‹¤!`)
                    .addFields(
                        { name: 'âš”ï¸ ë ˆë²¨', value: `${boss.level}`, inline: true },
                        { name: 'â¤ï¸ HP', value: `${boss.hp.toLocaleString()}`, inline: true },
                        { name: 'ğŸ¯ ìš”êµ¬ ë ˆë²¨', value: `${boss.requiredLevel}`, inline: true }
                    )
                    .setFooter({ text: '30ë¶„ í›„ ì‚¬ë¼ì§‘ë‹ˆë‹¤! ì„œë‘˜ëŸ¬ íŒŒí‹°ë¥¼ êµ¬ì„±í•˜ì„¸ìš”!' })
                    .setTimestamp();
                
                const bossButtons = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('boss_challenge')
                            .setLabel('ğŸ—¡ï¸ ë³´ìŠ¤ ë„ì „í•˜ê¸°')
                            .setStyle(ButtonStyle.Danger),
                        new ButtonBuilder()
                            .setCustomId('boss_info')
                            .setLabel('ğŸ“Š ë³´ìŠ¤ ì •ë³´')
                            .setStyle(ButtonStyle.Secondary),
                        new ButtonBuilder()
                            .setCustomId('boss_participants')
                            .setLabel('ğŸ‘¥ ì°¸ê°€ì ëª©ë¡')
                            .setStyle(ButtonStyle.Primary)
                    );
                
                await channel.send({
                    content: '@everyone',
                    embeds: [bossEmbed],
                    components: [bossButtons]
                });
                
                await interaction.reply({ 
                    content: `âœ… **${boss.name}**ì´(ê°€) ìŠ¤í°ë˜ì—ˆìŠµë‹ˆë‹¤!`, 
                    flags: 64 
                });
                
                // 30ë¶„ í›„ ë³´ìŠ¤ ì‚¬ë¼ì§
                setTimeout(async () => {
                    if (BOSS_SYSTEM.activeBoss && !BOSS_SYSTEM.battleState.isActive) {
                        BOSS_SYSTEM.activeBoss = null;
                        await channel.send('â° ë³´ìŠ¤ê°€ ì‚¬ë¼ì¡ŒìŠµë‹ˆë‹¤... ë‹¤ìŒ ê¸°íšŒë¥¼ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”!');
                    }
                }, BOSS_SYSTEM.spawnSettings.duration);
            }
            
            else if (subcommand === 'ì¢…ë£Œ') {
                if (!BOSS_SYSTEM.activeBoss) {
                    await interaction.reply({ 
                        content: 'âŒ í˜„ì¬ í™œì„±í™”ëœ ë³´ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤!', 
                        flags: 64 
                    });
                    return;
                }
                
                const bossName = BOSS_SYSTEM.activeBoss.name;
                BOSS_SYSTEM.activeBoss = null;
                BOSS_SYSTEM.participants.clear();
                BOSS_SYSTEM.damageDealt.clear();
                BOSS_SYSTEM.battleState.isActive = false;
                
                await interaction.reply({ 
                    content: `âœ… **${bossName}** ë³´ìŠ¤ê°€ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤!`, 
                    flags: 64 
                });
            }
            
            else if (subcommand === 'ì •ë³´') {
                if (!BOSS_SYSTEM.activeBoss) {
                    await interaction.reply({ 
                        content: 'âŒ í˜„ì¬ í™œì„±í™”ëœ ë³´ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤!', 
                        flags: 64 
                    });
                    return;
                }
                
                const boss = BOSS_SYSTEM.activeBoss;
                const remainingTime = Math.max(0, boss.endTime - Date.now());
                const minutes = Math.floor(remainingTime / 60000);
                const seconds = Math.floor((remainingTime % 60000) / 1000);
                
                const statusEmbed = new EmbedBuilder()
                    .setColor('#0099ff')
                    .setTitle('ğŸ“Š ë³´ìŠ¤ ìƒíƒœ')
                    .addFields(
                        { name: 'ğŸ¯ ë³´ìŠ¤', value: `${boss.emoji} ${boss.name} (Lv.${boss.level})`, inline: true },
                        { name: 'â¤ï¸ HP', value: `${boss.currentHp.toLocaleString()} / ${boss.hp.toLocaleString()}`, inline: true },
                        { name: 'â±ï¸ ë‚¨ì€ ì‹œê°„', value: `${minutes}ë¶„ ${seconds}ì´ˆ`, inline: true },
                        { name: 'ğŸ‘¥ ì°¸ê°€ì', value: `${BOSS_SYSTEM.participants.size}ëª…`, inline: true },
                        { name: 'âš”ï¸ ì „íˆ¬ ìƒíƒœ', value: BOSS_SYSTEM.battleState.isActive ? 'ì „íˆ¬ ì¤‘' : 'ëŒ€ê¸° ì¤‘', inline: true }
                    );
                
                await interaction.reply({ embeds: [statusEmbed], flags: 64 });
            }
        }
        
        else if (commandName === 'ë…ë²„ì„¯') {
            const user = await getUser(interaction.user.id);
            
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            const difficulty = interaction.options.getString('ë‚œì´ë„') || 'solo';
            await mushroomGame.startGame(interaction, user, difficulty);
        }
        
    } catch (error) {
        console.error('ëª…ë ¹ì–´ ì²˜ë¦¬ ì˜¤ë¥˜:', error);
        try {
            if (!interaction.replied && !interaction.deferred) {
                await interaction.reply({ content: 'ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤!', flags: 64 });
            } else if (interaction.deferred) {
                await interaction.editReply({ content: 'ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤!' });
            }
        } catch (replyError) {
            console.error('ì˜¤ë¥˜ ì‘ë‹µ ì‹¤íŒ¨:', replyError);
        }
    }
});

// ë²„íŠ¼ í´ë¦­ ë° ì„ íƒ ë©”ë‰´ ì²˜ë¦¬
client.on('interactionCreate', async (interaction) => {
    // ëª¨ë“  ë²„íŠ¼ í´ë¦­ì„ ë¡œê¹…
    if (interaction.isButton()) {
        console.log(`ğŸ”´ ë²„íŠ¼ í´ë¦­ë¨: ${interaction.customId}`);
    }
    
    if (!interaction.isButton() && !interaction.isStringSelectMenu()) return;
    
    // equip_item_selectëŠ” ë‹¤ë¥¸ í•¸ë“¤ëŸ¬ì—ì„œ ì²˜ë¦¬í•˜ë¯€ë¡œ ì œì™¸
    if (interaction.customId === 'equip_item_select') {
        console.log(`ğŸŸ¡ ì²« ë²ˆì§¸ í•¸ë“¤ëŸ¬ì—ì„œ equip_item_select ì œì™¸`);
        return;
    }
    
    if (interaction.customId && interaction.customId.includes('equip')) {
        console.log(`ğŸŸ¢ ì²« ë²ˆì§¸ í•¸ë“¤ëŸ¬ì—ì„œ equip ì²˜ë¦¬: ${interaction.customId}`);
    }

    // ê°œë°œ ëª¨ë“œì—ì„œ ì±„ë„ ì œí•œ
    if (DEV_MODE && DEV_CHANNEL_IDS.length > 0 && !DEV_CHANNEL_IDS.includes(interaction.channelId)) {
        console.log(`ì±„ë„ ë¶ˆì¼ì¹˜ - í˜„ì¬: ${interaction.channelId}, í—ˆìš©ëœ ê°œë°œ ì±„ë„ë“¤: ${DEV_CHANNEL_IDS.join(', ')}`);
        await interaction.reply({ content: 'ê°œë°œ ëª¨ë“œì—ì„œëŠ” ì§€ì •ëœ ì±„ë„ì—ì„œë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤!', flags: 64 });
        return;
    }

    const user = await getUser(interaction.user.id);
    if (!user) {
        await interaction.reply({ content: 'ìœ ì € ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
        return;
    }
    const now = Date.now();

    try {
        // ì£¼ì‹ ë§¤ìˆ˜ ë²„íŠ¼ ì²˜ë¦¬ (ìµœìš°ì„  ì²˜ë¦¬)
        if (interaction.customId.startsWith('buy_stock_')) {
            const companyId = interaction.customId.replace('buy_stock_', '');
            const company = findCompany(companyId);
            
            if (!company) {
                await interaction.reply({ content: 'ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê¸°ì—…ì…ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            // ë§¤ìˆ˜ ëª¨ë‹¬ ìƒì„±
            const buyModal = new ModalBuilder()
                .setCustomId(`buy_modal_${companyId}`)
                .setTitle(`${company.name} ì£¼ì‹ ë§¤ìˆ˜`);
            
            const sharesInput = new TextInputBuilder()
                .setCustomId('shares')
                .setLabel('ë§¤ìˆ˜í•  ì£¼ì‹ ìˆ˜ëŸ‰')
                .setStyle(TextInputStyle.Short)
                .setPlaceholder('1 ~ 1000')
                .setRequired(true)
                .setMaxLength(4);
            
            const actionRow = new ActionRowBuilder().addComponents(sharesInput);
            buyModal.addComponents(actionRow);
            
            await interaction.showModal(buyModal);
            return;
        }
        
        // ì£¼ì‹ ë§¤ë„ ë²„íŠ¼ ì²˜ë¦¬ (ìµœìš°ì„  ì²˜ë¦¬)
        else if (interaction.customId.startsWith('sell_stock_')) {
            const companyId = interaction.customId.replace('sell_stock_', '');
            const company = findCompany(companyId);
            const portfolio = await getPlayerPortfolio(interaction.user.id);
            
            if (!company) {
                await interaction.reply({ content: 'ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê¸°ì—…ì…ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            if (!portfolio.stocks.has(companyId)) {
                await interaction.reply({ content: 'ë³´ìœ í•˜ì§€ ì•Šì€ ì£¼ì‹ì…ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            const holding = portfolio.stocks.get(companyId);
            
            // ë§¤ë„ ëª¨ë‹¬ ìƒì„±
            const sellModal = new ModalBuilder()
                .setCustomId(`sell_modal_${companyId}`)
                .setTitle(`${company.name} ì£¼ì‹ ë§¤ë„`);
            
            const sharesInput = new TextInputBuilder()
                .setCustomId('shares')
                .setLabel('ë§¤ë„í•  ì£¼ì‹ ìˆ˜ëŸ‰')
                .setStyle(TextInputStyle.Short)
                .setPlaceholder(`1 ~ ${holding.shares}`)
                .setRequired(true)
                .setMaxLength(4);
            
            const actionRow = new ActionRowBuilder().addComponents(sharesInput);
            sellModal.addComponents(actionRow);
            
            await interaction.showModal(sellModal);
            return;
        }
        
        
        // ë©”ì¸í™”ë©´ì˜ ê²Œì„í•˜ê¸° ë²„íŠ¼ ì²˜ë¦¬
        else if (interaction.customId === 'game_start') {
            const user = await getUser(interaction.user.id);
            if (!user) {
                await interaction.reply({ content: 'ìœ ì € ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            // ê²Œì„ ì±„ë„ ì•ˆë‚´ ë©”ì‹œì§€
            const gameGuideEmbed = new EmbedBuilder()
                .setColor('#00ff00')
                .setTitle('ê²Œì„ ì‹œì‘!')
                .setDescription(`**${user.nickname || interaction.user.username}**ë‹˜, ê²Œì„ì„ ì‹œì‘í•©ë‹ˆë‹¤!\n\nê²Œì„ ì±„ë„ì—ì„œ \`/ê²Œì„\` ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•˜ì—¬ ê²Œì„ì„ í”Œë ˆì´í•˜ì„¸ìš”.\n\n**ê²Œì„ ì±„ë„ë¡œ ì´ë™í•˜ì—¬ ë³¸ê²©ì ì¸ ëª¨í—˜ì„ ì‹œì‘í•´ë³´ì„¸ìš”!**`)
                .addFields(
                    { name: 'ëª…ë ¹ì–´ ì•ˆë‚´', value: '`/ê²Œì„` - ê²Œì„ ë©”ë‰´ ì—´ê¸°', inline: true },
                    { name: 'í˜„ì¬ ìƒíƒœ', value: `ê³¨ë“œ: ${user.gold.toLocaleString()}${goldEmoji}\në ˆë²¨: Lv.${user.level}`, inline: true }
                )
                .setFooter({ text: 'ê²Œì„ ì±„ë„ì—ì„œ ë” ë§ì€ ê¸°ëŠ¥ì„ ì´ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!' });

            await interaction.reply({ embeds: [gameGuideEmbed], flags: 64 });
        }
        
        else if (interaction.customId === 'support_info') {
            // í›„ì› ì•ˆë‚´ (ì¶”í›„ êµ¬í˜„)
            const supportEmbed = new EmbedBuilder()
                .setColor('#ffaa00')
                .setTitle('í›„ì› ì•ˆë‚´')
                .setDescription('í›„ì› ê¸°ëŠ¥ì€ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤.\n\nê°œë°œìë¥¼ ì‘ì›í•´ì£¼ì‹œëŠ” ë§ˆìŒì— ê°ì‚¬ë“œë¦½ë‹ˆë‹¤!')
                .setFooter({ text: 'ê³§ í›„ì› ì‹œìŠ¤í…œì´ ì¶”ê°€ë  ì˜ˆì •ì…ë‹ˆë‹¤.' });
                
            await interaction.reply({ embeds: [supportEmbed], flags: 64 });
        }
        
        
        else if (interaction.customId === 'hunting') {
            // ê°œë°œìëŠ” ëª¨ë“  ì‚¬ëƒ¥í„° ì ‘ê·¼ ê°€ëŠ¥, ì¼ë°˜ ìœ ì €ëŠ” ì–¸ë½ëœ ì‚¬ëƒ¥í„°ë§Œ
            const availableAreas = isDeveloper(interaction.user.id) ? 
                huntingAreas : 
                huntingAreas.filter(area => user.unlockedAreas.includes(area.id));

            if (availableAreas.length === 0) {
                await interaction.reply({ content: 'ì‚¬ìš© ê°€ëŠ¥í•œ ì‚¬ëƒ¥í„°ê°€ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }

            // ì‚¬ëƒ¥í„° í˜ì´ì§€ë„¤ì´ì…˜ (í•œ í˜ì´ì§€ì— 3ê°œì”©)
            const areasPerPage = 3;
            const totalPages = Math.ceil(availableAreas.length / areasPerPage);
            const currentPage = 0; // ì²« í˜ì´ì§€ë¶€í„° ì‹œì‘

            const startIndex = currentPage * areasPerPage;
            const endIndex = startIndex + areasPerPage;
            const currentAreas = availableAreas.slice(startIndex, endIndex);

            // ì‚¬ëƒ¥í„° ì„ íƒ ì„ë² ë“œ
            const huntingEmbed = new EmbedBuilder()
                .setColor('#8b0000')
                .setTitle('âš”ï¸ ì‚¬ëƒ¥í„° ì„ íƒ')
                .setDescription(`**${user.nickname}**ë‹˜ì˜ ì‚¬ëƒ¥í„° ëª©ë¡\n\ní˜„ì¬ ë ˆë²¨: **Lv.${user.level}**`)
                .setFooter({ text: `í˜ì´ì§€ ${currentPage + 1}/${totalPages} | ì‚¬ëƒ¥í„°ë¥¼ ì„ íƒí•˜ì„¸ìš”!` });

            // ì‚¬ëƒ¥í„°ë³„ í•„ë“œ ì¶”ê°€
            currentAreas.forEach(area => {
                const monsterNames = area.monsters.map(m => m.name).join(', ');
                huntingEmbed.addFields({
                    name: `${area.name} ${area.levelRange}`,
                    value: `ì¶œí˜„ëª¬ìŠ¤í„°: ${monsterNames}`,
                    inline: true
                });
            });

            // ì‚¬ëƒ¥í„° ë²„íŠ¼ë“¤
            const huntingButtons = new ActionRowBuilder();
            currentAreas.forEach(area => {
                huntingButtons.addComponents(
                    new ButtonBuilder()
                        .setCustomId(`hunt_area_${area.id}`)
                        .setLabel(area.name)
                        .setStyle(ButtonStyle.Primary)
                );
            });

            // ë„¤ë¹„ê²Œì´ì…˜ ë²„íŠ¼
            const navButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('hunt_prev_page')
                        .setLabel('â—€ ì´ì „')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(currentPage === 0),
                    new ButtonBuilder()
                        .setCustomId('hunt_page_info')
                        .setLabel(`${currentPage + 1}/${totalPages}`)
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(true),
                    new ButtonBuilder()
                        .setCustomId('hunt_next_page')
                        .setLabel('ë‹¤ìŒ â–¶')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(currentPage >= totalPages - 1),
                    new ButtonBuilder()
                        .setCustomId('back_to_game_menu')
                        .setLabel('ğŸ® ê²Œì„ ë©”ë‰´')
                        .setStyle(ButtonStyle.Success)
                );

            const components = [huntingButtons];
            if (totalPages > 1) components.push(navButtons);
            else {
                // í˜ì´ì§€ê°€ 1ê°œë©´ ê²Œì„ ë©”ë‰´ ë²„íŠ¼ë§Œ ì¶”ê°€
                const backOnly = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('back_to_game_menu')
                            .setLabel('ğŸ® ê²Œì„ ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸°')
                            .setStyle(ButtonStyle.Success)
                    );
                components.push(backOnly);
            }

            await interaction.reply({ embeds: [huntingEmbed], components, flags: 64 });
        }
        
        else if (interaction.customId === 'ranking') {
            try {
                // ê° ë­í‚¹ë³„ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
                const [levelRanking, goldRanking, popularityRanking] = await Promise.all([
                    User.find({ registered: true }).sort({ level: -1, exp: -1 }).limit(5),
                    User.find({ registered: true }).sort({ gold: -1 }).limit(5),
                    User.find({ registered: true, popularity: { $gt: 0 } }).sort({ popularity: -1 }).limit(5)
                ]);
                
                // ë ˆë²¨ ë­í‚¹ í¬ë§·
                let levelText = '';
                levelRanking.forEach((user, index) => {
                    const medal = index === 0 ? 'ğŸ¥‡' : index === 1 ? 'ğŸ¥ˆ' : index === 2 ? 'ğŸ¥‰' : `${index + 1}.`;
                    levelText += `${medal} **${user.nickname}** - Lv.${user.level} (${user.exp}/${user.level * 100})\n`;
                });
                
                // ê³¨ë“œ ë­í‚¹ í¬ë§·
                let goldText = '';
                goldRanking.forEach((user, index) => {
                    const medal = index === 0 ? 'ğŸ¥‡' : index === 1 ? 'ğŸ¥ˆ' : index === 2 ? 'ğŸ¥‰' : `${index + 1}.`;
                    goldText += `${medal} **${user.nickname}** - ${user.gold.toLocaleString()}${goldEmoji}\n`;
                });
                
                // ì¸ê¸°ë„ ë­í‚¹ í¬ë§·
                let popularityText = '';
                if (popularityRanking.length === 0) {
                    popularityText = 'ì•„ì§ ì¸ê¸°ë„ë¥¼ ê°€ì§„ ì‚¬ìš©ìê°€ ì—†ìŠµë‹ˆë‹¤.';
                } else {
                    popularityRanking.forEach((user, index) => {
                        const medal = index === 0 ? 'ğŸ‘‘' : index === 1 ? 'ğŸ¥ˆ' : index === 2 ? 'ğŸ¥‰' : `${index + 1}.`;
                        const crown = index === 0 ? ' (ì¸ê¸°ì™•)' : '';
                        popularityText += `${medal} **${user.nickname}** - ì¸ê¸°ë„ ${user.popularity}${crown}\n`;
                    });
                }
                
                const rankingEmbed = new EmbedBuilder()
                    .setColor('#daa520')
                    .setTitle('ğŸ† ì „ì²´ ë­í‚¹')
                    .setDescription('ê° ë¶„ì•¼ì˜ ìµœê°•ìë“¤ì„ í™•ì¸í•´ë³´ì„¸ìš”!')
                    .addFields(
                        { name: 'â­ ë ˆë²¨ ë­í‚¹ TOP 5', value: levelText || 'ë“±ë¡ëœ ì‚¬ìš©ìê°€ ì—†ìŠµë‹ˆë‹¤.', inline: false },
                        { name: 'ğŸ’° ê³¨ë“œ ë­í‚¹ TOP 5', value: goldText || 'ë“±ë¡ëœ ì‚¬ìš©ìê°€ ì—†ìŠµë‹ˆë‹¤.', inline: false },
                        { name: 'â¤ï¸ ì¸ê¸°ë„ ë­í‚¹ TOP 5', value: popularityText, inline: false }
                    )
                    .setFooter({ text: 'ë­í‚¹ì€ ì‹¤ì‹œê°„ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤!' })
                    .setTimestamp();
                    
                await interaction.reply({ embeds: [rankingEmbed], flags: 64 });
            } catch (error) {
                console.error('ë­í‚¹ ì¡°íšŒ ì˜¤ë¥˜:', error);
                await interaction.reply({ content: 'ë­í‚¹ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', flags: 64 });
            }
        }
        
        else if (interaction.customId === 'racing') {
            // ë ˆì´ì‹± ë©”ë‰´ í‘œì‹œ
            const raceStatus = raceSystem.getRaceStatus();
            
            let statusText = `**ğŸ ì™„ì „ ìš´ë¹¨ ë ˆì´ì‹±! ğŸ²**\n\n`;
            statusText += `ğŸ’° **í˜„ì¬ ìƒê¸ˆí’€**: ${raceStatus.totalPot.toLocaleString()}<:currency_emoji:1377404064316522778>\n`;
            statusText += `ğŸ‘¥ **ì°¸ê°€ì**: ${raceStatus.playerCount}/${raceSystem.maxPlayers}ëª…\n\n`;
            
            if (raceStatus.isRacing) {
                statusText += `ğŸƒâ€â™‚ï¸ **ë ˆì´ìŠ¤ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤!**\nì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.`;
            } else if (raceStatus.playerCount === 0) {
                statusText += `ğŸ¯ **ëŒ€ê¸° ì¤‘ì¸ ì°¸ê°€ìê°€ ì—†ìŠµë‹ˆë‹¤.**\nì²« ë²ˆì§¸ ì°¸ê°€ìê°€ ë˜ì–´ë³´ì„¸ìš”!`;
            } else {
                statusText += `â° **${raceStatus.playerCount >= raceSystem.minPlayers ? 'ê³§ ì‹œì‘ë©ë‹ˆë‹¤!' : `ìµœì†Œ ${raceSystem.minPlayers}ëª… í•„ìš”`}**\n`;
                
                // í˜„ì¬ ì°¸ê°€ì ëª©ë¡
                if (raceStatus.players.length > 0) {
                    const realPlayers = raceStatus.players.filter(p => !p.isBot);
                    const botPlayers = raceStatus.players.filter(p => p.isBot);
                    
                    statusText += `\n**í˜„ì¬ ì°¸ê°€ì (${realPlayers.length}ëª…):**\n`;
                    realPlayers.forEach((p, i) => {
                        statusText += `${i + 1}. ${p.nickname} - ${p.betAmount.toLocaleString()}<:currency_emoji:1377404064316522778>\n`;
                    });
                    
                    if (botPlayers.length > 0) {
                        statusText += `\n**ğŸ¤– ë´‡ ì°¸ê°€ì (${botPlayers.length}ëª…):**\n`;
                        botPlayers.forEach((p, i) => {
                            statusText += `${i + 1}. ${p.nickname} - ${p.betAmount.toLocaleString()}<:currency_emoji:1377404064316522778>\n`;
                        });
                    }
                }
            }
            
            const racingEmbed = new EmbedBuilder()
                .setColor('#FFD700')
                .setTitle('ğŸ ê¹€í—Œí„° ë ˆì´ì‹± ì„¼í„°')
                .setDescription(statusText)
                .addFields(
                    { name: 'ğŸ’¡ ê·œì¹™', value: 'â€¢ ë² íŒ…ê¸ˆìœ¼ë¡œ ì°¸ê°€\nâ€¢ ìš°ìŠ¹ìê°€ ì „ì²´ ìƒê¸ˆ ë…ì‹\nâ€¢ ì™„ì „ ëœë¤! ìŠ¤íƒ¯/ë ˆë²¨ ë¬´ê´€!\nâ€¢ ğŸ¤– ë´‡ ìš°ìŠ¹ì‹œ ì‹¤ì œ í”Œë ˆì´ì–´ê°€ ìƒê¸ˆ íšë“', inline: true },
                    { name: 'ğŸ’° ë² íŒ… ë²”ìœ„', value: `${raceSystem.minBet.toLocaleString()}~${raceSystem.maxBet.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true },
                    { name: 'â° ë§¤ì¹­ ì‹œìŠ¤í…œ', value: `â€¢ ìµœì†Œ ${raceSystem.minPlayers}ëª… ì‹œ 1ë¶„ í›„ ì‹œì‘\nâ€¢ 1ë¶„ê°„ ì°¸ê°€ì ë¶€ì¡±ì‹œ ë´‡ ìë™ ì¶”ê°€`, inline: true }
                )
                .setFooter({ text: 'ğŸ² ì™„ì „ ìš´ë¹¨! ëˆ„êµ¬ë‚˜ ìš°ìŠ¹ ê°€ëŠ¥!' });
            
            // ì°¸ê°€ ì—¬ë¶€ í™•ì¸
            const isParticipating = raceStatus.players.some(p => p.userId === interaction.user.id);
            
            const racingButtons = new ActionRowBuilder();
            
            if (!raceStatus.isRacing) {
                if (!isParticipating && !raceStatus.isFull) {
                    // ì°¸ê°€ ë²„íŠ¼ë“¤
                    racingButtons.addComponents(
                        new ButtonBuilder()
                            .setCustomId('join_race_1000')
                            .setLabel('ğŸ¯ 1,000ê³¨ë“œ')
                            .setStyle(ButtonStyle.Primary)
                            .setDisabled(user.gold < 1000),
                        new ButtonBuilder()
                            .setCustomId('join_race_5000')
                            .setLabel('ğŸ’ 5,000ê³¨ë“œ')
                            .setStyle(ButtonStyle.Success)
                            .setDisabled(user.gold < 5000),
                        new ButtonBuilder()
                            .setCustomId('join_race_custom')
                            .setLabel('ğŸ’° ì§ì ‘ ì…ë ¥')
                            .setStyle(ButtonStyle.Secondary)
                            .setDisabled(user.gold < raceSystem.minBet)
                    );
                } else if (isParticipating) {
                    // ë‚˜ê°€ê¸° ë²„íŠ¼
                    racingButtons.addComponents(
                        new ButtonBuilder()
                            .setCustomId('leave_race')
                            .setLabel('âŒ ë ˆì´ìŠ¤ ë‚˜ê°€ê¸°')
                            .setStyle(ButtonStyle.Danger)
                    );
                }
            }
            
            // í†µê³„ ë²„íŠ¼ì€ í•­ìƒ í‘œì‹œ
            const statsButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('racing_stats')
                        .setLabel('ğŸ“Š ë‚´ ë ˆì´ì‹± í†µê³„')
                        .setStyle(ButtonStyle.Secondary),
                    new ButtonBuilder()
                        .setCustomId('racing_ranking')
                        .setLabel('ğŸ† ë ˆì´ì‹± ë­í‚¹')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            const components = [];
            if (racingButtons.components.length > 0) components.push(racingButtons);
            components.push(statsButton);
            
            await interaction.reply({ 
                embeds: [racingEmbed], 
                components,
                flags: 64 
            });
        }
        
        else if (interaction.customId === 'daily') {
            const today = new Date().toDateString();
            const yesterday = new Date(Date.now() - 86400000).toDateString();
            
            // ì¶œì„ì²´í¬ ì—¬ë¶€ í™•ì¸
            if (user.lastDaily === today) {
                await interaction.reply({ content: 'ì˜¤ëŠ˜ì€ ì´ë¯¸ ì¶œì„ì²´í¬ë¥¼ í–ˆìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }

            // ì—°ì† ì¶œì„ ì²´í¬
            if (user.lastDaily === yesterday) {
                user.attendanceStreak += 1;
            } else {
                user.attendanceStreak = 1;
            }

            // ì£¼ê°„ ì¶œì„ ì²´í¬ (ì£¼ ì‹œì‘ ì²´í¬)
            const now = new Date();
            const weekStart = new Date(now);
            weekStart.setDate(now.getDate() - now.getDay()); // ì¼ìš”ì¼ ì‹œì‘
            weekStart.setHours(0, 0, 0, 0);
            
            if (!user.weekStart || user.weekStart < weekStart) {
                user.weeklyAttendance = [false, false, false, false, false, false, false];
                user.weekStart = weekStart;
            }
            
            user.weeklyAttendance[now.getDay()] = true;

            // ì´ë¯¸ì§€ ì²¨ë¶€
            const dailyAttachment = new AttachmentBuilder(path.join(__dirname, 'resource', 'kim_daily.gif'), { name: 'kim_daily.gif' });

            // ë³´ìƒ ì˜µì…˜ë“¤
            const rewards = [
                { name: 'ğŸ’° 500G', gold: 500, exp: 0, item: null },
                { name: 'ğŸ’° 1000G', gold: 1000, exp: 0, item: null },
                { name: 'ğŸ’° 2000G', gold: 2000, exp: 0, item: null },
                { name: 'âœ¨ ê²½í—˜ì¹˜ ë¶€ìŠ¤í„°', gold: 0, exp: 500, item: null },
                { name: 'ğŸ ë¯¸ìŠ¤í„°ë¦¬ ë°•ìŠ¤', gold: 1500, exp: 100, item: 'mystery_box' }
            ];

            // ì´ˆê¸° ë£°ë › í‘œì‹œ
            const rouletteEmbed = new EmbedBuilder()
                .setColor('#ffaa00')
                .setTitle('ğŸ¡ ì¶œì„ ì²´í¬ ë³´ìƒ ëŒë ¤ëŒë ¤ ëŒë¦¼íŒ!')
                .setDescription(`**${user.nickname || interaction.user.username}**ë‹˜ì˜ ì¶œì„ ì²´í¬!\\n\\nì—°ì† ì¶œì„: **${user.attendanceStreak}ì¼** ğŸ”¥`)
                .addFields(
                    { name: 'ì£¼ê°„ ì¶œì„ í˜„í™©', value: `${user.weeklyAttendance.map((attended, i) => {
                        const days = ['ì¼', 'ì›”', 'í™”', 'ìˆ˜', 'ëª©', 'ê¸ˆ', 'í† '];
                        return attended ? `${days[i]}âœ…` : `${days[i]}âŒ`;
                    }).join(' ')} (${user.weeklyAttendance.filter(x => x).length}/7)`, inline: false },
                )
                .setImage('attachment://kim_daily.gif')
                .setFooter({ text: 'ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ ëŒë¦¼íŒì„ ëŒë¦¬ì„¸ìš”!' });

            const row = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('spin_roulette')
                        .setLabel('ğŸ¡ ëŒë¦¼íŒ ëŒë¦¬ê¸°!')
                        .setStyle(ButtonStyle.Primary)
                );

            await interaction.reply({ embeds: [rouletteEmbed], components: [row], files: [dailyAttachment], flags: 64 });
        }
        
        else if (interaction.customId === 'spin_roulette') {
            // ë¨¼ì € ì‘ë‹µ ì§€ì—° ì²˜ë¦¬
            await interaction.deferUpdate();
            
            // ëŒë¦¼íŒ ì• ë‹ˆë©”ì´ì…˜
            const rewards = [
                { name: 'ğŸ’° 500G + âœ¨ 100EXP', gold: 500, exp: 100 },
                { name: 'ğŸ’° 1000G + âœ¨ 200EXP', gold: 1000, exp: 200 },
                { name: 'ğŸ’° 1500G + âœ¨ 300EXP', gold: 1500, exp: 300 },
                { name: 'ğŸ’° 2000G + âœ¨ 400EXP', gold: 2000, exp: 400 },
                { name: 'ğŸ’° 2500G + âœ¨ 500EXP', gold: 2500, exp: 500 }
            ];

            const selectedReward = rewards[Math.floor(Math.random() * rewards.length)];
            const rewardIndex = rewards.indexOf(selectedReward);

            // ì• ë‹ˆë©”ì´ì…˜ í”„ë ˆì„ë“¤
            const frames = [
                'â“ ğŸ â“ â“ â“',
                'â“ â“ ğŸ â“ â“',
                'â“ â“ â“ ğŸ â“',
                'â“ â“ â“ â“ ğŸ',
                'ğŸ â“ â“ â“ â“'
            ];

            // ìµœì¢… ê²°ê³¼ í”„ë ˆì„
            const finalFrame = rewards.map((r, i) => i === rewardIndex ? 'ğŸ‰' : 'âŒ').join(' ');

            // 1ë‹¨ê³„: ëŒë¦¬ëŠ” ì¤‘ GIF
            const turntableAttachment = new AttachmentBuilder(path.join(__dirname, 'resource', 'kim_turntable.gif'), { name: 'kim_turntable.gif' });

            // GIFì™€ í•¨ê»˜ ëŒë¦¼íŒ ì‹œì‘ í‘œì‹œ
            const gifEmbed = new EmbedBuilder()
                .setColor('#ffaa00')
                .setTitle('ğŸ¡ ëŒë¦¼íŒ ëŒë¦¬ëŠ” ì¤‘...')
                .setDescription(`ì—°ì† ì¶œì„: **${user.attendanceStreak}ì¼** ğŸ”¥`)
                .setImage('attachment://kim_turntable.gif');

            await interaction.editReply({ embeds: [gifEmbed], components: [], files: [turntableAttachment] });
            
            // GIF ì¬ìƒ ì‹œê°„ (4ì´ˆ)
            await new Promise(resolve => setTimeout(resolve, 4000));

            // ìµœì¢… ê²°ê³¼ í‘œì‹œ
            user.gold += selectedReward.gold;
            user.exp += selectedReward.exp;
            user.lastDaily = new Date().toDateString();
            
            // ë ˆë²¨ì—… ì²´í¬
            const { leveledUp, levelsGained, oldLevel } = processLevelUp(user);
            
            // ì—°ì† ì¶œì„ ë³´ë„ˆìŠ¤
            let streakBonus = '';
            if (user.attendanceStreak >= 7) {
                const bonusGold = 1000;
                user.gold += bonusGold;
                streakBonus = `\\nğŸ”¥ **7ì¼ ì—°ì† ì¶œì„ ë³´ë„ˆìŠ¤**: +${bonusGold}G`;
            }
            
            // ì£¼ê°„ ë¯¸ì…˜ ì™„ë£Œ ì²´í¬
            let weeklyBonus = '';
            if (user.weeklyAttendance.filter(x => x).length === 7) {
                const weeklyGold = 5000;
                user.gold += weeklyGold;
                weeklyBonus = `\\nğŸ† **ì£¼ê°„ ë¯¸ì…˜ ì™„ë£Œ**: +${weeklyGold}G`;
            }
            
            // ì¶œì„ ë°ì´í„° ë³€ê²½ ì‚¬í•­ì„ MongoDBê°€ ì¸ì‹í•˜ë„ë¡ markModified í˜¸ì¶œ
            user.markModified('lastDaily');
            user.markModified('attendanceStreak');
            user.markModified('weeklyAttendance');
            user.markModified('weekStart');
            
            // ì €ì¥ ì „ ë¡œê·¸
            console.log(`[ì¶œì„] ${user.nickname} ì €ì¥ ì „ - ì—°ì†: ${user.attendanceStreak}, ì£¼ê°„: ${user.weeklyAttendance}`);
            
            try {
                await user.save();
                console.log(`[ì¶œì„] ${user.nickname} ì €ì¥ ì„±ê³µ!`);
            } catch (saveError) {
                console.error(`[ì¶œì„] ${user.nickname} ì €ì¥ ì‹¤íŒ¨:`, saveError);
                // ì¬ì‹œë„
                try {
                    await user.save();
                    console.log(`[ì¶œì„] ${user.nickname} ì¬ì‹œë„ ì €ì¥ ì„±ê³µ!`);
                } catch (retryError) {
                    console.error(`[ì¶œì„] ${user.nickname} ì¬ì‹œë„ë„ ì‹¤íŒ¨:`, retryError);
                }
            }

            // 3ë‹¨ê³„: ë³´ìƒ ê°•ë„ì— ë”°ë¥¸ ê°ì • ë©˜íŠ¸ì™€ ê²°ê³¼ í‘œì‹œ
            const resultAttachment = new AttachmentBuilder(path.join(__dirname, 'resource', 'kim_turntable2.gif'), { name: 'kim_turntable2.gif' });
            
            // ë³´ìƒ ê°•ë„ë³„ ê°ì • ë©˜íŠ¸ ì„¤ì •
            let emotionTitle = '';
            let emotionDescription = '';
            let embedColor = '';
            
            // ë ˆë²¨ì—… ë©”ì‹œì§€ ì¶”ê°€
            const levelUpMessage = leveledUp ? `\n\nğŸ‰ **ë ˆë²¨ì—…!** Lv.${oldLevel} â†’ Lv.${user.level}` : '';
            
            if (selectedReward.gold >= 2000) {
                // ìµœê³  ë³´ìƒ
                emotionTitle = 'ğŸš€ ëŒ€ë°•!! ìµœê³ ì˜ ìš´ì´êµ°ìš”!';
                emotionDescription = `ì™€! **${selectedReward.name}**ì„ ë‹¹ì²¨ì‹œí‚¤ë‹¤ë‹ˆ! ì •ë§ ëŒ€ë‹¨í•´ìš”! ì˜¤ëŠ˜ì€ ë¶„ëª… ì¢‹ì€ ì¼ì´ ê°€ë“í•  ê±°ì˜ˆìš”! âœ¨${levelUpMessage}${streakBonus}${weeklyBonus}`;
                embedColor = '#ffd700'; // ê¸ˆìƒ‰
            } else if (selectedReward.gold >= 1500) {
                // ë†’ì€ ë³´ìƒ
                emotionTitle = 'ğŸ‰ í›Œë¥­í•´ìš”! ì¢‹ì€ ë³´ìƒì´ë„¤ìš”!';
                emotionDescription = `**${selectedReward.name}** ë‹¹ì²¨! ì˜¤ëŠ˜ ìš´ì´ ì¢‹ìœ¼ì‹œë„¤ìš”! ê³„ì† ì´ëŸ° í–‰ìš´ì´ ì´ì–´ì§€ê¸¸ ë°”ë¼ìš”! ğŸ˜Š${levelUpMessage}${streakBonus}${weeklyBonus}`;
                embedColor = '#ff6b6b'; // ë¹¨ê°„ìƒ‰
            } else if (selectedReward.gold >= 1000) {
                // ì¤‘ê°„ ë³´ìƒ
                emotionTitle = 'â­ ì¢‹ì€ ê²°ê³¼ì˜ˆìš”!';
                emotionDescription = `**${selectedReward.name}** ë‹¹ì²¨! ê¾¸ì¤€í•œ ì„±ì¥ê³¼ ê³¨ë“œ íšë“ì´ë„¤ìš”! ğŸ’ª${levelUpMessage}${streakBonus}${weeklyBonus}`;
                embedColor = '#9b59b6'; // ë³´ë¼ìƒ‰
            } else {
                // ì¼ë°˜ ë³´ìƒ
                emotionTitle = 'ğŸ˜Š ì¢‹ì€ ì‹œì‘ì´ì—ìš”!';
                emotionDescription = `**${selectedReward.name}** ë‹¹ì²¨! ê¾¸ì¤€íˆ ëª¨ìœ¼ë©´ í° í˜ì´ ë  ê±°ì˜ˆìš”! ë§¤ì¼ë§¤ì¼ ì¶œì„í•´ì„œ ë” í° ë³´ìƒì„ ë…¸ë ¤ë´ìš”! ğŸ¯${levelUpMessage}${streakBonus}${weeklyBonus}`;
                embedColor = '#3498db'; // íŒŒë€ìƒ‰
            }
            
            const resultEmbed = new EmbedBuilder()
                .setColor(embedColor)
                .setTitle(emotionTitle)
                .setDescription(emotionDescription)
                .addFields(
                    { name: 'ğŸ’° íšë“ ë‚´ì—­', value: `ê³¨ë“œ: +${selectedReward.gold.toLocaleString()}<:currency_emoji:1377404064316522778>\nê²½í—˜ì¹˜: +${selectedReward.exp} EXP`, inline: true },
                    { name: '<:currency_emoji:1377404064316522778> í˜„ì¬ ê³¨ë“œ', value: `${user.gold.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true },
                    { name: 'ğŸ”¥ ì—°ì† ì¶œì„', value: `${user.attendanceStreak}ì¼`, inline: true }
                )
                .setImage('attachment://kim_turntable2.gif')
                .setFooter({ text: 'ë‚´ì¼ë„ ìŠì§€ ë§ê³  ì¶œì„ì²´í¬ í•´ì£¼ì„¸ìš”!' });

            const backButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('back_to_game_menu')
                        .setLabel('ğŸ® ê²Œì„ ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸°')
                        .setStyle(ButtonStyle.Secondary)
                );

            await interaction.editReply({ embeds: [resultEmbed], components: [backButton], files: [resultAttachment] });
        }
        
        // ì‚¬ëƒ¥í„° ì„ íƒ ì²˜ë¦¬
        else if (interaction.customId.startsWith('hunt_area_')) {
            const areaId = parseInt(interaction.customId.split('_')[2]);
            const selectedArea = huntingAreas.find(area => area.id === areaId);
            
            if (!selectedArea) {
                await interaction.reply({ content: 'ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì‚¬ëƒ¥í„°ì…ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            // ì‚¬ëƒ¥ ì‹œì‘ - 3ë‹¨ê³„ í”„ë¡œì„¸ìŠ¤
            // ì‚¬ëƒ¥í„°ë³„ GIF ì„¤ì •
            const huntingGifName = selectedArea.huntingGif || 'kim_hunting.gif'; // ê¸°ë³¸ê°’ ì„¤ì •
            const huntGifAttachment = new AttachmentBuilder(path.join(__dirname, 'resource', huntingGifName), { name: huntingGifName });

            // 1ë‹¨ê³„: ì‚¬ëƒ¥ì¤‘ GIF (2ì´ˆ)
            const huntingMessages = [
                `**${selectedArea.name}**ì—ì„œ ì—´ì‹¬íˆ ì‚¬ëƒ¥ì¤‘ì…ë‹ˆë‹¤...`,
                `**${selectedArea.name}**ì—ì„œ í˜ê²¹ê²Œ ì „íˆ¬ì¤‘ì…ë‹ˆë‹¤...`,
                `**${selectedArea.name}**ì˜ ëª¬ìŠ¤í„°ë“¤ê³¼ ê²©íˆ¬ì¤‘ì…ë‹ˆë‹¤...`,
                `**${selectedArea.name}**ë¥¼ íƒí—˜í•˜ë©° ì‚¬ëƒ¥ì¤‘ì…ë‹ˆë‹¤...`,
                `**${selectedArea.name}**ì—ì„œ ì¹˜ì—´í•œ ì „íˆ¬ë¥¼ ë²Œì´ê³  ìˆìŠµë‹ˆë‹¤...`
            ];
            
            const randomMessage = huntingMessages[Math.floor(Math.random() * huntingMessages.length)];
            
            const huntGifEmbed = new EmbedBuilder()
                .setColor('#ff6b6b')
                .setTitle('âš”ï¸ ì‚¬ëƒ¥ì¤‘...')
                .setDescription(`${randomMessage}\n\ní˜„ì¬ ë ˆë²¨: **Lv.${user.level}**`)
                .setImage(`attachment://${huntingGifName}`);
            
            // Check if interaction has already been replied/deferred
            if (interaction.replied || interaction.deferred) {
                await interaction.editReply({ embeds: [huntGifEmbed], components: [], files: [huntGifAttachment] });
            } else {
                await interaction.update({ embeds: [huntGifEmbed], components: [], files: [huntGifAttachment] });
            }
            
            // ì£¼ì‹ ì‹œì¥ ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±° (ì‚¬ëƒ¥ ì‹œì‘)
            recordPlayerAction('hunt_start');
            
            // 2ì´ˆ ëŒ€ê¸° í›„ ë°”ë¡œ ê²°ê³¼ë¡œ
            await new Promise(resolve => setTimeout(resolve, 2000));

            // ëœë¤ ëª¬ìŠ¤í„° ì„ íƒ (ì‚¬ëƒ¥í„°ì— ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤ë©´ ëª¨ë“  ëª¬ìŠ¤í„° ì‚¬ëƒ¥ ê°€ëŠ¥)
            const availableMonsters = selectedArea.monsters;

            const selectedMonster = availableMonsters[Math.floor(Math.random() * availableMonsters.length)];
            const monsterLevel = Math.floor(Math.random() * (selectedMonster.level[1] - selectedMonster.level[0] + 1)) + selectedMonster.level[0];

            // ì „íˆ¬ë ¥ ê³„ì‚°
            const userPower = calculateCombatPower(user);
            const monsterPower = calculateMonsterPower(selectedMonster, monsterLevel);
            
            // ìŠ¹ë¦¬ í™•ë¥  ê³„ì‚° (ì „íˆ¬ë ¥ ì°¨ì´ì— ë”°ë¼)
            const powerDiff = userPower - monsterPower;
            let winRate = 50; // ê¸°ë³¸ 50%
            
            if (powerDiff > 0) {
                winRate = Math.min(95, 50 + (powerDiff / 10)); // ìµœëŒ€ 95%
            } else {
                winRate = Math.max(5, 50 + (powerDiff / 15)); // ìµœì†Œ 5%
            }
            
            const battleResult = Math.random() * 100 <= winRate;

            // ì „íˆ¬ ê²°ê³¼ ê³„ì‚°
            const baseExp = Math.floor(Math.random() * (selectedMonster.exp[1] - selectedMonster.exp[0] + 1)) + selectedMonster.exp[0];
            const baseGold = Math.floor(Math.random() * (selectedMonster.gold[1] - selectedMonster.gold[0] + 1)) + selectedMonster.gold[0];
            
            // ë ˆë²¨ ì°¨ì´ì— ë”°ë¥¸ ë³´ìƒ ì¡°ì •
            const levelDiff = user.level - monsterLevel;
            let expMultiplier = 1;
            let goldMultiplier = 1;
            
            if (levelDiff > 5) {
                expMultiplier = 0.5; // ë„ˆë¬´ ì‰¬ìš´ ëª¬ìŠ¤í„°
                goldMultiplier = 0.7;
            } else if (levelDiff < -5) {
                expMultiplier = 1.5; // ì–´ë ¤ìš´ ëª¬ìŠ¤í„°
                goldMultiplier = 1.3;
            }

            const finalExp = Math.floor(baseExp * expMultiplier);
            const finalGold = Math.floor(baseGold * goldMultiplier);

            // ë ˆì–´ë„ì— ë”°ë¥¸ ë³´ë„ˆìŠ¤
            let rarityBonus = 1;
            let rarityEmoji = '';
            switch (selectedMonster.rarity) {
                case 'ë ˆì–´':
                    rarityBonus = 1.2;
                    rarityEmoji = 'âœ¨';
                    break;
                case 'ì—í”½':
                    rarityBonus = 1.5;
                    rarityEmoji = 'ğŸŒŸ';
                    break;
                case 'ìœ ë‹ˆí¬':
                    rarityBonus = 2.0;
                    rarityEmoji = 'ğŸ’';
                    break;
                case 'ë ˆì „ë“œ':
                    rarityBonus = 3.0;
                    rarityEmoji = 'ğŸ‘‘';
                    break;
                default:
                    rarityEmoji = 'âš”ï¸';
            }

            user.lastHunt = Date.now();
            
            // GIF íŒŒì¼ ì¤€ë¹„
            const winGifAttachment = new AttachmentBuilder(path.join(__dirname, 'resource', 'kim_hunting_win.gif'), { name: 'kim_hunting_win.gif' });
            const loseGifAttachment = new AttachmentBuilder(path.join(__dirname, 'resource', 'kim_hunting_lose.gif'), { name: 'kim_hunting_lose.gif' });
            
            let resultEmbed;
            
            if (battleResult) {
                // ìŠ¹ë¦¬ ì‹œ
                const bonusExp = Math.floor(finalExp * (rarityBonus - 1));
                const bonusGold = Math.floor(finalGold * (rarityBonus - 1));

                // ë ˆë²¨ë³„ ê³¨ë“œ í˜ë„í‹° ì ìš© (ì¸í”Œë ˆì´ì…˜ ë°©ì§€)
                let goldPenalty = 1.0;
                if (user.level >= 61) goldPenalty = 0.6;        // -40%
                else if (user.level >= 41) goldPenalty = 0.7;   // -30%  
                else if (user.level >= 21) goldPenalty = 0.8;   // -20%
                
                const adjustedGold = Math.floor(finalGold * goldPenalty);
                const adjustedBonusGold = Math.floor(bonusGold * goldPenalty);

                // ìœ ì € ë°ì´í„° ì—…ë°ì´íŠ¸
                user.exp += finalExp + bonusExp;
                user.gold += adjustedGold + adjustedBonusGold;
                
                // í€˜ìŠ¤íŠ¸ ì§„í–‰ë„ ì—…ë°ì´íŠ¸
                const completedQuests = checkQuestProgress(user, 'daily', 'kill', { monsterType: selectedMonster.type || 'any' });
                if (selectedMonster.isBoss) {
                    checkQuestProgress(user, 'weekly', 'kill_boss');
                }

                // ì—ë„ˆì§€ ì¡°ê° ë“œë ì²´í¬ (0.1% í™•ë¥ )
                let energyFragmentDrop = null;
                if (Math.random() < 0.001) { // 0.1% í™•ë¥ 
                    // ëª¬ìŠ¤í„° ë ˆë²¨ì— ë”°ë¥¸ ì¡°ê° ë‹¨ê³„ ê²°ì •
                    let fragmentTier = 1;
                    if (monsterLevel >= 50) fragmentTier = 5;
                    else if (monsterLevel >= 40) fragmentTier = 4;
                    else if (monsterLevel >= 30) fragmentTier = 3;
                    else if (monsterLevel >= 20) fragmentTier = 2;
                    
                    // ì¡°ê° ê°œìˆ˜ (1~3ê°œ)
                    const fragmentCount = Math.floor(Math.random() * 3) + 1;
                    
                    // ê¸°ì¡´ ë³´ìœ ëŸ‰ì— ì¶”ê°€
                    const currentCount = user.energyFragments.fragments.get(fragmentTier.toString()) || 0;
                    user.energyFragments.fragments.set(fragmentTier.toString(), currentCount + fragmentCount);
                    
                    energyFragmentDrop = { tier: fragmentTier, count: fragmentCount };
                }

                // ì•„ì´í…œ ë“œë¡­ ì²´í¬
                let droppedItems = [];
                const monsterDrops = DROP_ITEMS[selectedMonster.name] || [];
                
                // í–‰ìš´ ìŠ¤íƒ¯ì— ë”°ë¥¸ ë“œë¡­ë¥  ë³´ë„ˆìŠ¤ (í–‰ìš´ 1ë‹¹ +0.05%)
                const luckBonus = (user.stats.luck - 10) * 0.05;
                
                // ëª¬ìŠ¤í„°ë³„ ë“œë¡­ í™•ì¸
                for (const dropData of monsterDrops) {
                    const finalDropRate = dropData.dropRate + luckBonus;
                    if (Math.random() * 100 < finalDropRate) {
                        // ì•„ì´í…œ ìƒì„±
                        const itemPrice = Math.floor(Math.random() * (dropData.price[1] - dropData.price[0] + 1)) + dropData.price[0];
                        const uniqueItemId = `drop_${selectedMonster.name}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                        
                        const newItem = {
                            id: uniqueItemId,
                            name: dropData.name,
                            type: dropData.type,
                            rarity: dropData.rarity,
                            setName: `${selectedMonster.name} ë“œë¡­`,
                            level: 1,
                            quantity: 1,
                            enhanceLevel: 0,
                            stats: { attack: 0, defense: 0, dodge: 0, luck: 0 },
                            price: itemPrice,
                            description: dropData.effect || 'ì‚¬ëƒ¥ì—ì„œ ì–»ì€ ê·€ì¤‘í•œ ì•„ì´í…œì…ë‹ˆë‹¤.'
                        };
                        
                        // ì¸ë²¤í† ë¦¬ì— ì¶”ê°€
                        const inventoryResult = addItemToInventory(user, newItem);
                        if (inventoryResult.success) {
                            droppedItems.push(dropData);
                        }
                    }
                }
                
                // ì§€ì—­ ê³µí†µ ë“œë¡­ í™•ì¸
                const areaDrops = DROP_ITEMS.ALL_AREAS.filter(item => item.area === selectedArea.id);
                for (const areaDropData of areaDrops) {
                    const finalDropRate = areaDropData.dropRate + luckBonus;
                    if (Math.random() * 100 < finalDropRate) {
                        const itemPrice = Math.floor(Math.random() * (areaDropData.price[1] - areaDropData.price[0] + 1)) + areaDropData.price[0];
                        const uniqueItemId = `area_drop_${selectedArea.id}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                        
                        const newItem = {
                            id: uniqueItemId,
                            name: areaDropData.name,
                            type: areaDropData.type,
                            rarity: areaDropData.rarity,
                            setName: `${selectedArea.name} íŠ¹ì‚°í’ˆ`,
                            level: 1,
                            quantity: 1,
                            enhanceLevel: 0,
                            stats: { attack: 0, defense: 0, dodge: 0, luck: 0 },
                            price: itemPrice,
                            description: `${selectedArea.name}ì—ì„œë§Œ êµ¬í•  ìˆ˜ ìˆëŠ” íŠ¹ë³„í•œ ì•„ì´í…œì…ë‹ˆë‹¤.`
                        };
                        
                        const inventoryResult = addItemToInventory(user, newItem);
                        if (inventoryResult.success) {
                            droppedItems.push(areaDropData);
                        }
                    }
                }

                // ëœë¤ ì¸ì¹´ìš´í„° ì²´í¬ (5% í™•ë¥ )
                let randomEncounter = null;
                if (Math.random() < 0.05) {
                    randomEncounter = checkRandomEncounter();
                }

                // ë ˆë²¨ì—… ì²´í¬
                const { leveledUp, levelsGained, oldLevel } = processLevelUp(user);

                await user.save();

                // ê²°ê³¼ ì„ë² ë“œ (ìŠ¹ë¦¬ GIFì™€ í•¨ê»˜)
                const expBar = generateExpBar(user.exp, user.level * 100, 20);
                const powerDiffText = userPower > monsterPower ? 
                    `ğŸ”¥ **ìš°ì„¸** (+${userPower - monsterPower})` : 
                    userPower < monsterPower ? 
                        `âš ï¸ **ì—´ì„¸** (-${monsterPower - userPower})` : 
                        `âš–ï¸ **ë™ë“±**`;
                
                resultEmbed = new EmbedBuilder()
                    .setColor('#00d4aa')
                    .setTitle(`${rarityEmoji} âš”ï¸ ì „íˆ¬ ìŠ¹ë¦¬! âš”ï¸`)
                    .setDescription(`ğŸ¯ **${selectedMonster.name}** Lv.${monsterLevel} ì²˜ì¹˜ ì™„ë£Œ!${leveledUp ? `\n\nğŸ‰ **ë ˆë²¨ì—…!** Lv.${oldLevel} â†’ Lv.${user.level} ğŸ‰` : ''}`)
                    .addFields(
                        { 
                            name: 'âš”ï¸ ì „íˆ¬ ê²°ê³¼', 
                            value: `ğŸ›¡ï¸ ë‚˜ì˜ ì „íˆ¬ë ¥: **${userPower.toLocaleString()}** | âš”ï¸ ì ì˜ ì „íˆ¬ë ¥: **${monsterPower.toLocaleString()}** | ğŸ“Š ìŠ¹ë¦¬ í™•ë¥ : **${winRate.toFixed(1)}%**\n\n${powerDiffText}`, 
                            inline: false 
                        },
                        { 
                            name: 'ğŸ’ ë³´ìƒ', 
                            value: `âœ¨ ê²½í—˜ì¹˜: +${finalExp.toLocaleString()} EXP${bonusExp > 0 ? ` (+${bonusExp.toLocaleString()} ë³´ë„ˆìŠ¤)` : ''} | <:currency_emoji:1377404064316522778> ê³¨ë“œ: +${adjustedGold.toLocaleString()}${adjustedBonusGold > 0 ? ` (+${adjustedBonusGold.toLocaleString()} ë³´ë„ˆìŠ¤)` : ''}${goldPenalty < 1.0 ? `\nğŸ“‰ ê³ ë ˆë²¨ í˜ë„í‹°: ${Math.round((1-goldPenalty)*100)}% ê³¨ë“œ ê°ì†Œ` : ''}${energyFragmentDrop ? `\nğŸ”® **ì—ë„ˆì§€ ì¡°ê° íšë“!** \`${energyFragmentDrop.tier}ë‹¨ê³„ ì¡°ê° x${energyFragmentDrop.count}\` âœ¨` : ''}${droppedItems.length > 0 ? `\n\nğŸ **ì•„ì´í…œ ë“œë¡­!**\n${droppedItems.map(item => {
                                const rarityEmojis = {
                                    'ì¼ë°˜': 'âšª',
                                    'ê³ ê¸‰': 'ğŸŸ¢', 
                                    'ë ˆì–´': 'ğŸ”µ',
                                    'ì—í”½': 'ğŸŸ£',
                                    'ë ˆì „ë“œë¦¬': 'ğŸŸ¡',
                                    'ì‹ í™”': 'ğŸ”´'
                                };
                                return `${rarityEmojis[item.rarity] || 'âšª'} **${item.name}** (${item.rarity})`;
                            }).join('\n')}` : ''}`, 
                            inline: false 
                        },
                        { 
                            name: 'ğŸ“Š í˜„ì¬ ìƒíƒœ', 
                            value: `ğŸ† ë ˆë²¨: Lv.${user.level} | âœ¨ ê²½í—˜ì¹˜: ${user.exp}/${user.level * 100} EXP | <:currency_emoji:1377404064316522778> ê³¨ë“œ: ${user.gold.toLocaleString()}`, 
                            inline: false 
                        }
                    );
                
                // ëœë¤ ì¸ì¹´ìš´í„° ì •ë³´ ì¶”ê°€
                if (randomEncounter) {
                    resultEmbed.addFields({
                        name: `ğŸ² íŠ¹ë³„ ë§Œë‚¨: ${randomEncounter.name}`,
                        value: randomEncounter.description,
                        inline: false
                    });
                }
                
                resultEmbed.setImage('attachment://kim_hunting_win.gif')
            } else {
                // íŒ¨ë°° ì‹œ
                const defeatMessages = [
                    "ì•„ì´í…œì„ ê°•í™”í•´ì„œ ì´ê¸°ì!",
                    "ë” ê°•í•´ì ¸ì„œ ë‹¤ì‹œ ë„ì „í•˜ì!",
                    "ì¥ë¹„ë¥¼ ì—…ê·¸ë ˆì´ë“œí•˜ê³  ë³µìˆ˜í•˜ì!",
                    "ë ˆë²¨ì—…ì„ í•˜ê³  ë‹¤ì‹œ ì‹¸ìš°ì!",
                    "ëŠ¥ë ¥ì¹˜ë¥¼ ì˜¬ë¦¬ê³  ì¬ë„ì „í•˜ì!",
                    "ë” ì¢‹ì€ ë¬´ê¸°ê°€ í•„ìš”í•´ ë³´ì¸ë‹¤!",
                    "ë°©ì–´êµ¬ë¥¼ ê°•í™”í•˜ê³  ë‹¤ì‹œ ì˜¤ì!",
                    "ì „íˆ¬ë ¥ì„ í‚¤ì›Œì„œ ë³µìˆ˜í•˜ì!",
                    "ìŠ¤í‚¬ì„ ë°°ì›Œì„œ ë‹¤ì‹œ ë„ì „í•˜ì!",
                    "ë” ë§ì€ ê²½í—˜ì´ í•„ìš”í•´ ë³´ì¸ë‹¤!"
                ];
                
                const randomDefeatMessage = defeatMessages[Math.floor(Math.random() * defeatMessages.length)];
                
                // ë²Œê¸ˆ ê³„ì‚° (ëª¬ìŠ¤í„° ë“œë ê³¨ë“œì˜ 1~10ë°°)
                const penalty = Math.floor(Math.random() * 10 + 1) * baseGold;
                const actualPenalty = Math.min(penalty, user.gold); // ë³´ìœ  ê³¨ë“œë¥¼ ì´ˆê³¼í•  ìˆ˜ ì—†ìŒ
                
                user.gold = Math.max(0, user.gold - actualPenalty);
                await user.save();

                // ê²°ê³¼ ì„ë² ë“œ (íŒ¨ë°° GIFì™€ í•¨ê»˜)
                const expBarDefeat = generateExpBar(user.exp, user.level * 100, 20);
                const powerDiffTextDefeat = userPower > monsterPower ? 
                    `ğŸ”¥ **ìš°ì„¸ì˜€ì§€ë§Œ** (+${userPower - monsterPower})` : 
                    userPower < monsterPower ? 
                        `âš ï¸ **ì—´ì„¸** (-${monsterPower - userPower})` : 
                        `âš–ï¸ **ë™ë“±í–ˆì§€ë§Œ**`;
                
                resultEmbed = new EmbedBuilder()
                    .setColor('#ff4757')
                    .setTitle(`ğŸ’¥ âš”ï¸ ì „íˆ¬ íŒ¨ë°°... âš”ï¸`)
                    .setDescription(`ğŸ˜ **${selectedMonster.name}** Lv.${monsterLevel} ì—ê²Œ íŒ¨ë°°...\n\nğŸ’­ **"${randomDefeatMessage}"**`)
                    .addFields(
                        { 
                            name: 'âš”ï¸ ì „íˆ¬ ê²°ê³¼', 
                            value: `ğŸ›¡ï¸ ë‚˜ì˜ ì „íˆ¬ë ¥: **${userPower.toLocaleString()}** | âš”ï¸ ì ì˜ ì „íˆ¬ë ¥: **${monsterPower.toLocaleString()}** | ğŸ“Š ìŠ¹ë¦¬ í™•ë¥ : **${winRate.toFixed(1)}%**\n\n${powerDiffTextDefeat}`, 
                            inline: false 
                        },
                        { 
                            name: 'ğŸ’¸ ì†ì‹¤', 
                            value: `<:currency_emoji:1377404064316522778> ë²Œê¸ˆ: -${actualPenalty.toLocaleString()} | âŒ ëª¬ìŠ¤í„° ë“œë ê³¨ë“œì˜ **${Math.floor(actualPenalty/baseGold)}ë°°** ì†ì‹¤`, 
                            inline: false 
                        },
                        { 
                            name: 'ğŸ“Š í˜„ì¬ ìƒíƒœ', 
                            value: `ğŸ† ë ˆë²¨: Lv.${user.level} | âœ¨ ê²½í—˜ì¹˜: ${user.exp}/${user.level * 100} EXP | <:currency_emoji:1377404064316522778> ê³¨ë“œ: ${user.gold.toLocaleString()}`, 
                            inline: false 
                        },
                        { 
                            name: 'ğŸ’¡ ë‹¤ìŒ ë„ì „ì„ ìœ„í•œ ì¡°ì–¸', 
                            value: `ğŸ¯ ${randomDefeatMessage}\n\nğŸ”§ **ì¶”ì²œ ê°•í™” ë°©ë²•**\nğŸ“ˆ ëŠ¥ë ¥ì¹˜ í¬ì¸íŠ¸ íˆ¬ì\nâš”ï¸ ì¥ë¹„ ê°•í™” ë° êµì²´\nğŸ†™ ë ˆë²¨ì—…ìœ¼ë¡œ ê¸°ë³¸ ëŠ¥ë ¥ì¹˜ ì¦ê°€`, 
                            inline: false 
                        }
                    )
                    .setImage('attachment://kim_hunting_lose.gif')
            }

            const continueButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId(`hunt_area_${areaId}`)
                        .setLabel('ğŸ”„ ê³„ì† ì‚¬ëƒ¥')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('hunting')
                        .setLabel('ğŸ—ºï¸ ì‚¬ëƒ¥í„° ë³€ê²½')
                        .setStyle(ButtonStyle.Secondary),
                    new ButtonBuilder()
                        .setCustomId('back_to_game_menu')
                        .setLabel('ğŸ® ê²Œì„ ë©”ë‰´')
                        .setStyle(ButtonStyle.Success)
                );

            await interaction.editReply({ 
                embeds: [resultEmbed], 
                components: [continueButtons], 
                files: battleResult ? [winGifAttachment] : [loseGifAttachment]
            });
        }
        
        else if (interaction.customId === 'work') {
            // ìš´ë™í•˜ê¸° ë©”ì¸ ë©”ë‰´ í‘œì‹œ
            await showExerciseMenu(interaction, user);
        }
        
        else if (interaction.customId === 'exercise_select') {
            // ìš´ë™ ì„ íƒ ë©”ë‰´
            // deferUpdate ì œê±° - ìƒˆë¡œìš´ ë©”ì‹œì§€ë¡œ ì‘ë‹µ
            
            const availableExercises = [];
            
            // ì‚¬ìš© ê°€ëŠ¥í•œ ìš´ë™ í™•ì¸
            for (const [id, exercise] of Object.entries(EXERCISE_SYSTEM.exercises)) {
                let canUse = false;
                
                if (exercise.requirements === null) {
                    canUse = true;
                } else if (exercise.requirements === 'gym' && user.fitness.memberships.gym.active) {
                    const now = Date.now();
                    if (user.fitness.memberships.gym.expiresAt > now) {
                        canUse = true;
                    }
                } else if (exercise.requirements === 'premium' && user.fitness.memberships.premium.active) {
                    const now = Date.now();
                    if (user.fitness.memberships.premium.expiresAt > now) {
                        canUse = true;
                    }
                }
                
                if (canUse || user.fitness.unlockedExercises.includes(id)) {
                    availableExercises.push(exercise);
                }
            }
            
            const embed = new EmbedBuilder()
                .setColor('#4ecdc4')
                .setTitle('ğŸƒ ìš´ë™ ì„ íƒ')
                .setDescription('ì‹œì‘í•  ìš´ë™ì„ ì„ íƒí•´ì£¼ì„¸ìš”!')
                .addFields({
                    name: 'ğŸ’¦ í˜„ì¬ í”¼ë¡œë„',
                    value: `${user.fitness.fatigue}/100 ${getFatigueBar(user.fitness.fatigue)}`,
                    inline: false
                });
            
            // ì¹´í…Œê³ ë¦¬ë³„ë¡œ ìš´ë™ í‘œì‹œ
            const categories = {
                basic: { name: 'ğŸ’ª ê¸°ë³¸ ìš´ë™', exercises: [] },
                gym: { name: 'ğŸ‹ï¸ í—¬ìŠ¤ì¥ ìš´ë™', exercises: [] },
                premium: { name: 'ğŸŠ í”„ë¦¬ë¯¸ì—„ ìš´ë™', exercises: [] }
            };
            
            availableExercises.forEach(exercise => {
                categories[exercise.category].exercises.push(exercise);
            });
            
            for (const [catId, catData] of Object.entries(categories)) {
                if (catData.exercises.length > 0) {
                    let exerciseList = '';
                    catData.exercises.forEach(ex => {
                        const maxMinutes = Math.floor(ex.maxDuration / 60000);
                        exerciseList += `${ex.emoji} **${ex.name}** - ìµœëŒ€ ${maxMinutes}ë¶„\n`;
                        exerciseList += `   íš¨ê³¼: ${ex.description}\n`;
                        exerciseList += `   ë³´ìƒ: ${ex.rewards.goldPerMinute}G/ë¶„, ${ex.rewards.expPerMinute}EXP/ë¶„\n\n`;
                    });
                    
                    embed.addFields({
                        name: catData.name,
                        value: exerciseList,
                        inline: false
                    });
                }
            }
            
            // ìš´ë™ ì„ íƒ ë²„íŠ¼ë“¤
            const selectOptions = availableExercises.slice(0, 25).map(exercise => ({
                label: exercise.name,
                description: `${exercise.description} - í”¼ë¡œë„ +${Math.round(exercise.fatigueRate * 10)}/10ë¶„`,
                value: `start_exercise_${exercise.id}`,
                emoji: exercise.emoji
            }));
            
            const selectMenu = new StringSelectMenuBuilder()
                .setCustomId('select_exercise_type')
                .setPlaceholder('ìš´ë™ì„ ì„ íƒí•˜ì„¸ìš”')
                .addOptions(selectOptions);
            
            const selectRow = new ActionRowBuilder().addComponents(selectMenu);
            
            const backButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('work')
                        .setLabel('ğŸ”™ ë’¤ë¡œê°€ê¸°')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            await interaction.update({
                embeds: [embed],
                components: [selectRow, backButton]
            });
        }
        
        else if (interaction.customId === 'exercise_equipment') {
            // ìš´ë™ ì¥ë¹„ ë©”ë‰´
            const embed = new EmbedBuilder()
                .setColor('#f39c12')
                .setTitle('ğŸ½ ìš´ë™ ì¥ë¹„')
                .setDescription('ìš´ë™ íš¨ìœ¨ì„ ë†’ì—¬ì£¼ëŠ” ì¥ë¹„ë“¤ì…ë‹ˆë‹¤!')
                .addFields(
                    {
                        name: 'ğŸ‘• ìš´ë™ë³µ',
                        value: Object.entries(EXERCISE_SYSTEM.equipment.clothes).map(([id, item]) => {
                            const equipped = user.fitness.equipment.clothes === id ? ' âœ…' : '';
                            const bonus = ((item.efficiency - 1) * 100).toFixed(0);
                            return `${item.name}${equipped}\níš¨ìœ¨ ${bonus > 0 ? '+' : ''}${bonus}% | ê°€ê²©: ${item.cost.toLocaleString()}G`;
                        }).join('\n\n'),
                        inline: true
                    },
                    {
                        name: 'ğŸ‘Ÿ ìš´ë™í™”',
                        value: Object.entries(EXERCISE_SYSTEM.equipment.shoes).map(([id, item]) => {
                            const equipped = user.fitness.equipment.shoes === id ? ' âœ…' : '';
                            const bonus = ((item.speed - 1) * 100).toFixed(0);
                            return `${item.name}${equipped}\nì†ë„ ${bonus > 0 ? '+' : ''}${bonus}% | ê°€ê²©: ${item.cost.toLocaleString()}G`;
                        }).join('\n\n'),
                        inline: true
                    }
                );
            
            const equipmentButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('buy_clothes_brand')
                        .setLabel('ë¸Œëœë“œ ìš´ë™ë³µ êµ¬ë§¤')
                        .setStyle(ButtonStyle.Primary)
                        .setDisabled(user.fitness.equipment.clothes !== 'basic' || user.gold < 5000),
                    new ButtonBuilder()
                        .setCustomId('buy_clothes_pro')
                        .setLabel('í”„ë¡œ ìš´ë™ë³µ êµ¬ë§¤')
                        .setStyle(ButtonStyle.Primary)
                        .setDisabled(user.fitness.equipment.clothes === 'pro' || user.gold < 20000),
                    new ButtonBuilder()
                        .setCustomId('buy_shoes_running')
                        .setLabel('ëŸ¬ë‹í™” êµ¬ë§¤')
                        .setStyle(ButtonStyle.Primary)
                        .setDisabled(user.fitness.equipment.shoes !== 'basic' || user.gold < 8000),
                    new ButtonBuilder()
                        .setCustomId('buy_shoes_pro')
                        .setLabel('í”„ë¡œ ìš´ë™í™” êµ¬ë§¤')
                        .setStyle(ButtonStyle.Primary)
                        .setDisabled(user.fitness.equipment.shoes === 'pro' || user.gold < 30000)
                );
            
            const backButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('work')
                        .setLabel('ğŸ”™ ìš´ë™ ë©”ë‰´')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            await interaction.update({
                embeds: [embed],
                components: [equipmentButtons, backButton]
            });
        }
        
        else if (interaction.customId === 'exercise_supplements') {
            // ë³´ì¶©ì œ ë©”ë‰´
            const now = Date.now();
            const activeBooster = user.fitness.equipment.activeBooster;
            let activeInfo = 'í˜„ì¬ ì‚¬ìš© ì¤‘ì¸ ë³´ì¶©ì œê°€ ì—†ìŠµë‹ˆë‹¤.';
            
            if (activeBooster.type && activeBooster.expiresAt > now) {
                const remaining = Math.ceil((activeBooster.expiresAt - now) / 60000);
                const supplement = EXERCISE_SYSTEM.supplements[activeBooster.type];
                activeInfo = `${supplement.emoji} **${supplement.name}** ì‚¬ìš© ì¤‘ (${remaining}ë¶„ ë‚¨ìŒ)`;
            }
            
            const embed = new EmbedBuilder()
                .setColor('#e17055')
                .setTitle('ğŸ¥¤ ë³´ì¶©ì œ')
                .setDescription(`ìš´ë™ íš¨ê³¼ë¥¼ ì¦ê°€ì‹œí‚¤ëŠ” ë³´ì¶©ì œì…ë‹ˆë‹¤!\n\n${activeInfo}`)
                .addFields(
                    Object.entries(EXERCISE_SYSTEM.supplements).map(([id, item]) => ({
                        name: `${item.emoji} ${item.name}`,
                        value: `${item.description}\nì§€ì†: ${Math.floor(item.duration / 60000)}ë¶„ | ê°€ê²©: ${item.cost.toLocaleString()}G`,
                        inline: false
                    }))
                );
            
            const supplementButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('use_supplement_protein')
                        .setLabel('ğŸ¥¤ í”„ë¡œí‹´ ì‚¬ìš©')
                        .setStyle(ButtonStyle.Primary)
                        .setDisabled(user.gold < 1000 || (activeBooster.type && activeBooster.expiresAt > now)),
                    new ButtonBuilder()
                        .setCustomId('use_supplement_bcaa')
                        .setLabel('ğŸ’Š BCAA ì‚¬ìš©')
                        .setStyle(ButtonStyle.Primary)
                        .setDisabled(user.gold < 1500 || (activeBooster.type && activeBooster.expiresAt > now)),
                    new ButtonBuilder()
                        .setCustomId('use_supplement_booster')
                        .setLabel('âš¡ ë¶€ìŠ¤í„° ì‚¬ìš©')
                        .setStyle(ButtonStyle.Primary)
                        .setDisabled(user.gold < 2000 || (activeBooster.type && activeBooster.expiresAt > now))
                );
            
            const backButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('work')
                        .setLabel('ğŸ”™ ìš´ë™ ë©”ë‰´')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            await interaction.update({
                embeds: [embed],
                components: [supplementButtons, backButton]
            });
        }
        
        else if (interaction.customId === 'exercise_goals') {
            // ìš´ë™ ëª©í‘œ
            const today = new Date().toDateString();
            if (user.fitness.goals.daily.lastReset !== today) {
                user.fitness.goals.daily.minutes30 = false;
                user.fitness.goals.daily.minutes60 = false;
                user.fitness.goals.daily.minutes180 = false;
                user.fitness.goals.daily.claimed30 = false;
                user.fitness.goals.daily.claimed60 = false;
                user.fitness.goals.daily.claimed180 = false;
                user.fitness.goals.daily.lastReset = today;
                await user.save();
            }
            
            const dailyGoals = [
                { 
                    name: '30ë¶„ ìš´ë™', 
                    completed: user.fitness.goals.daily.minutes30,
                    reward: '500G + 100 EXP'
                },
                { 
                    name: '1ì‹œê°„ ìš´ë™', 
                    completed: user.fitness.goals.daily.minutes60,
                    reward: '1,000G + 300 EXP'
                },
                { 
                    name: '3ì‹œê°„ ìš´ë™', 
                    completed: user.fitness.goals.daily.minutes180,
                    reward: '3,000G + 1,000 EXP'
                }
            ];
            
            const embed = new EmbedBuilder()
                .setColor('#74b9ff')
                .setTitle('ğŸ¯ ìš´ë™ ëª©í‘œ')
                .setDescription('ì¼ì¼ ëª©í‘œë¥¼ ë‹¬ì„±í•˜ê³  ì¶”ê°€ ë³´ìƒì„ ë°›ìœ¼ì„¸ìš”!')
                .addFields(
                    {
                        name: 'ğŸ“… ì¼ì¼ ëª©í‘œ',
                        value: dailyGoals.map(goal => 
                            `${goal.completed ? 'âœ…' : 'â¬œ'} **${goal.name}**\n   ë³´ìƒ: ${goal.reward}`
                        ).join('\n\n'),
                        inline: false
                    },
                    {
                        name: 'ğŸ“Š ì§„í–‰ ìƒí™©',
                        value: `ì˜¤ëŠ˜ ìš´ë™ ì‹œê°„: ${Math.floor(getTodayExerciseTime(user) / 60000)}ë¶„\nì—°ì† ìš´ë™: ${user.fitness.streak}ì¼`,
                        inline: false
                    }
                );
            
            const claimButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('claim_goal_30')
                        .setLabel('30ë¶„ ë³´ìƒ ìˆ˜ë ¹')
                        .setStyle(ButtonStyle.Success)
                        .setDisabled(!user.fitness.goals.daily.minutes30 || user.fitness.goals.daily.claimed30),
                    new ButtonBuilder()
                        .setCustomId('claim_goal_60')
                        .setLabel('1ì‹œê°„ ë³´ìƒ ìˆ˜ë ¹')
                        .setStyle(ButtonStyle.Success)
                        .setDisabled(!user.fitness.goals.daily.minutes60 || user.fitness.goals.daily.claimed60),
                    new ButtonBuilder()
                        .setCustomId('claim_goal_180')
                        .setLabel('3ì‹œê°„ ë³´ìƒ ìˆ˜ë ¹')
                        .setStyle(ButtonStyle.Success)
                        .setDisabled(!user.fitness.goals.daily.minutes180 || user.fitness.goals.daily.claimed180),
                    new ButtonBuilder()
                        .setCustomId('work')
                        .setLabel('ğŸ”™ ìš´ë™ ë©”ë‰´')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            await interaction.update({
                embeds: [embed],
                components: [claimButtons]
            });
        }
        
        else if (interaction.customId === 'exercise_stats') {
            // ìš´ë™ í†µê³„
            const totalMinutes = Math.floor(user.fitness.totalExerciseTime / 60000);
            const totalHours = Math.floor(totalMinutes / 60);
            const remainingMinutes = totalMinutes % 60;
            
            // ìµœê·¼ 7ì¼ ìš´ë™ ê¸°ë¡
            const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
            const recentExercises = user.fitness.exerciseHistory
                .filter(record => new Date(record.date) > sevenDaysAgo)
                .slice(-10);
            
            // ìš´ë™ë³„ í†µê³„
            const exerciseStats = {};
            user.fitness.exerciseHistory.forEach(record => {
                if (!exerciseStats[record.type]) {
                    exerciseStats[record.type] = {
                        count: 0,
                        totalTime: 0,
                        totalGold: 0
                    };
                }
                exerciseStats[record.type].count++;
                exerciseStats[record.type].totalTime += record.duration;
                exerciseStats[record.type].totalGold += record.rewards.gold;
            });
            
            // ê°€ì¥ ë§ì´ í•œ ìš´ë™
            let favoriteExercise = null;
            let maxCount = 0;
            for (const [type, stats] of Object.entries(exerciseStats)) {
                if (stats.count > maxCount) {
                    maxCount = stats.count;
                    favoriteExercise = type;
                }
            }
            
            const embed = new EmbedBuilder()
                .setColor('#00cec9')
                .setTitle('ğŸ“Š ìš´ë™ í†µê³„')
                .setDescription(`**${user.nickname}**ë‹˜ì˜ ìš´ë™ ê¸°ë¡`)
                .addFields(
                    {
                        name: 'â±ï¸ ì´ ìš´ë™ ì‹œê°„',
                        value: `${totalHours}ì‹œê°„ ${remainingMinutes}ë¶„`,
                        inline: true
                    },
                    {
                        name: 'ğŸ’ª í”¼íŠ¸ë‹ˆìŠ¤ ë ˆë²¨',
                        value: `Lv.${user.fitness.level}`,
                        inline: true
                    },
                    {
                        name: 'ğŸ”¥ ìµœì¥ ì—°ì†',
                        value: `${user.fitness.streak}ì¼`,
                        inline: true
                    },
                    {
                        name: 'ğŸƒ ì¦ê²¨í•˜ëŠ” ìš´ë™',
                        value: favoriteExercise ? EXERCISE_SYSTEM.exercises[favoriteExercise].name : 'ì—†ìŒ',
                        inline: true
                    },
                    {
                        name: 'ğŸ’° ì´ íšë“ ê³¨ë“œ',
                        value: `${user.fitness.exerciseHistory.reduce((sum, r) => sum + r.rewards.gold, 0).toLocaleString()}G`,
                        inline: true
                    },
                    {
                        name: 'ğŸ“ˆ ì´ ìš´ë™ íšŸìˆ˜',
                        value: `${user.fitness.exerciseHistory.length}íšŒ`,
                        inline: true
                    }
                );
            
            if (recentExercises.length > 0) {
                const recentList = recentExercises.map(record => {
                    const exercise = EXERCISE_SYSTEM.exercises[record.type];
                    const minutes = Math.floor(record.duration / 60000);
                    return `${exercise.emoji} ${exercise.name} - ${minutes}ë¶„`;
                }).join('\n');
                
                embed.addFields({
                    name: 'ğŸ“… ìµœê·¼ ìš´ë™ ê¸°ë¡',
                    value: recentList,
                    inline: false
                });
            }
            
            const backButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('work')
                        .setLabel('ğŸ”™ ìš´ë™ ë©”ë‰´')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            await interaction.update({
                embeds: [embed],
                components: [backButton]
            });
        }
        
        else if (interaction.customId === 'exercise_membership') {
            // ì´ìš©ê¶Œ ë©”ë‰´ (ë¯¸êµ¬í˜„)
            await interaction.reply({ 
                content: 'ì´ìš©ê¶Œ ì‹œìŠ¤í…œì€ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤!', 
                flags: 64 
            });
        }
        
        else if (interaction.customId === 'ranking') {
            // í†µí•© ë­í‚¹ ë©”ë‰´
            await showRankingMenu(interaction, 0);
        }
        
        // ë­í‚¹ í˜ì´ì§€ ë„¤ë¹„ê²Œì´ì…˜
        else if (interaction.customId.startsWith('ranking_prev_')) {
            const currentPage = parseInt(interaction.customId.replace('ranking_prev_', ''));
            await showRankingMenu(interaction, Math.max(0, currentPage - 1));
        }
        
        else if (interaction.customId.startsWith('ranking_next_')) {
            const currentPage = parseInt(interaction.customId.replace('ranking_next_', ''));
            await showRankingMenu(interaction, currentPage + 1);
        }
        
        else if (interaction.customId === 'ranking_select') {
            // ë­í‚¹ ì¹´í…Œê³ ë¦¬ ì„ íƒ ë©”ë‰´
            const selectOptions = [
                { label: 'ğŸ“ˆ ë ˆë²¨ ë­í‚¹', value: 'ranking_goto_0', emoji: 'ğŸ“ˆ' },
                { label: 'ğŸ’° ë¶€ì ë­í‚¹', value: 'ranking_goto_1', emoji: 'ğŸ’°' },
                { label: 'ğŸ¯ ì‚¬ëƒ¥ ë­í‚¹', value: 'ranking_goto_2', emoji: 'ğŸ¯' },
                { label: 'âš”ï¸ ê°•í™” ë­í‚¹', value: 'ranking_goto_3', emoji: 'âš”ï¸' },
                { label: 'ğŸ† PVP ë­í‚¹', value: 'ranking_goto_4', emoji: 'ğŸ†' },
                { label: 'ğŸ ë ˆì´ì‹± ë­í‚¹', value: 'ranking_goto_5', emoji: 'ğŸ' },
                { label: 'âš¡ ì—ë„ˆì§€ ë­í‚¹', value: 'ranking_goto_6', emoji: 'âš¡' },
                { label: 'ğŸ² í™€ì§ ë­í‚¹', value: 'ranking_goto_7', emoji: 'ğŸ²' },
                { label: 'ğŸº ìœ ë¬¼ ë­í‚¹', value: 'ranking_goto_8', emoji: 'ğŸº' },
                { label: 'ğŸ’ª ìš´ë™ ë­í‚¹', value: 'ranking_goto_9', emoji: 'ğŸ’ª' },
                { label: 'â¤ï¸ ì¸ê¸° ë­í‚¹', value: 'ranking_goto_10', emoji: 'â¤ï¸' },
                { label: 'ğŸ”¥ ì¶œì„ ë­í‚¹', value: 'ranking_goto_11', emoji: 'ğŸ”¥' }
            ];
            
            const selectMenu = new StringSelectMenuBuilder()
                .setCustomId('ranking_category_select')
                .setPlaceholder('ë­í‚¹ ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•˜ì„¸ìš”')
                .addOptions(selectOptions);
            
            const selectRow = new ActionRowBuilder().addComponents(selectMenu);
            
            await interaction.update({ 
                components: [selectRow] 
            });
        }
        
        else if (interaction.customId === 'exercise_status') {
            // ìš´ë™ í˜„í™© í‘œì‹œ
            await interaction.deferUpdate();
            
            const statusEmbed = new EmbedBuilder()
                .setColor('#4ecdc4')
                .setTitle('ğŸ“Š ìš´ë™ í˜„í™©')
                .setDescription(`**${user.nickname}**ë‹˜ì˜ ìš´ë™ ìƒíƒœ`)
                .addFields(
                    { name: 'ğŸ’ª í”¼íŠ¸ë‹ˆìŠ¤ ë ˆë²¨', value: `Lv.${user.fitness.level}`, inline: true },
                    { name: 'âœ¨ í”¼íŠ¸ë‹ˆìŠ¤ ê²½í—˜ì¹˜', value: `${user.fitness.exp}/${getFitnessLevelRequirement(user.fitness.level + 1)}`, inline: true },
                    { name: 'ğŸ’¦ í”¼ë¡œë„', value: `${user.fitness.fatigue}/100`, inline: true },
                    { name: 'â±ï¸ ì´ ìš´ë™ ì‹œê°„', value: `${Math.floor(user.fitness.totalExerciseTime / 60000)}ë¶„`, inline: true },
                    { name: 'ğŸ”¥ ì—°ì† ìš´ë™ì¼', value: `${user.fitness.streak}ì¼`, inline: true },
                    { name: 'ğŸ“… ì˜¤ëŠ˜ ìš´ë™ ì‹œê°„', value: `${user.fitness.dailyExerciseTime}ë¶„`, inline: true }
                );
            
            // ìµœê·¼ ìš´ë™ ê¸°ë¡
            if (user.fitness.exerciseHistory && user.fitness.exerciseHistory.length > 0) {
                const recentExercises = user.fitness.exerciseHistory.slice(-5).reverse();
                let historyText = '';
                recentExercises.forEach(record => {
                    const date = new Date(record.date);
                    const timeStr = `${date.getMonth()+1}/${date.getDate()} ${date.getHours()}:${date.getMinutes().toString().padStart(2, '0')}`;
                    historyText += `${EXERCISE_SYSTEM.exercises[record.exerciseType]?.emoji || 'ğŸƒ'} **${record.exerciseType}** - ${Math.floor(record.duration/60000)}ë¶„ (${timeStr})\n`;
                });
                statusEmbed.addFields({ name: 'ğŸ“ ìµœê·¼ ìš´ë™ ê¸°ë¡', value: historyText || 'ê¸°ë¡ ì—†ìŒ', inline: false });
            }
            
            // í˜„ì¬ ìš´ë™ ìƒíƒœ
            if (user.fitness.currentExercise) {
                const exercise = EXERCISE_SYSTEM.exercises[user.fitness.currentExercise.type];
                const elapsed = Date.now() - user.fitness.currentExercise.startTime;
                const remaining = user.fitness.currentExercise.duration - elapsed;
                
                if (remaining > 0) {
                    statusEmbed.addFields({
                        name: 'ğŸƒ í˜„ì¬ ìš´ë™ ì¤‘',
                        value: `${exercise.emoji} **${exercise.name}** - ë‚¨ì€ ì‹œê°„: ${Math.ceil(remaining/60000)}ë¶„`,
                        inline: false
                    });
                }
            }
            
            const backButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('work')
                        .setLabel('ğŸ”™ ìš´ë™ ë©”ë‰´ë¡œ')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            await interaction.editReply({ 
                embeds: [statusEmbed], 
                components: [backButton] 
            });
        }
        
        else if (interaction.customId === 'exercise_ranking') {
            // ìš´ë™ ë­í‚¹ í˜ì´ì§€ë¡œ ì´ë™
            await showRankingMenu(interaction, 9);
        }
        
        // ì¥ë¹„ êµ¬ë§¤ í•¸ë“¤ëŸ¬ë“¤
        else if (interaction.customId.startsWith('buy_clothes_')) {
            const type = interaction.customId.replace('buy_clothes_', '');
            const item = EXERCISE_SYSTEM.equipment.clothes[type];
            
            if (user.gold < item.cost) {
                await interaction.reply({ content: 'ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            user.gold -= item.cost;
            user.fitness.equipment.clothes = type;
            await user.save();
            
            await interaction.reply({ 
                content: `âœ… **${item.name}**ì„(ë¥¼) êµ¬ë§¤í–ˆìŠµë‹ˆë‹¤! ìš´ë™ íš¨ìœ¨ì´ ì¦ê°€í•©ë‹ˆë‹¤.`, 
                flags: 64 
            });
        }
        
        else if (interaction.customId.startsWith('buy_shoes_')) {
            const type = interaction.customId.replace('buy_shoes_', '');
            const item = EXERCISE_SYSTEM.equipment.shoes[type];
            
            if (user.gold < item.cost) {
                await interaction.reply({ content: 'ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            user.gold -= item.cost;
            user.fitness.equipment.shoes = type;
            await user.save();
            
            await interaction.reply({ 
                content: `âœ… **${item.name}**ì„(ë¥¼) êµ¬ë§¤í–ˆìŠµë‹ˆë‹¤! ìš´ë™ ì†ë„ê°€ ì¦ê°€í•©ë‹ˆë‹¤.`, 
                flags: 64 
            });
        }
        
        // ë³´ì¶©ì œ ì‚¬ìš© í•¸ë“¤ëŸ¬
        else if (interaction.customId.startsWith('use_supplement_')) {
            const type = interaction.customId.replace('use_supplement_', '');
            const supplement = EXERCISE_SYSTEM.supplements[type];
            
            if (user.gold < supplement.cost) {
                await interaction.reply({ content: 'ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            const now = Date.now();
            if (user.fitness.equipment.activeBooster.type && user.fitness.equipment.activeBooster.expiresAt > now) {
                await interaction.reply({ content: 'ì´ë¯¸ ë³´ì¶©ì œë¥¼ ì‚¬ìš© ì¤‘ì…ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            user.gold -= supplement.cost;
            user.fitness.equipment.activeBooster = {
                type: type,
                expiresAt: new Date(now + supplement.duration)
            };
            await user.save();
            
            await interaction.reply({ 
                content: `âœ… ${supplement.emoji} **${supplement.name}**ì„(ë¥¼) ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤!\n${supplement.description}`, 
                flags: 64 
            });
        }
        
        // ëª©í‘œ ë³´ìƒ ìˆ˜ë ¹ í•¸ë“¤ëŸ¬
        else if (interaction.customId.startsWith('claim_goal_')) {
            const goalType = interaction.customId.replace('claim_goal_', '');
            const rewards = {
                '30': { gold: 500, exp: 100 },
                '60': { gold: 1000, exp: 300 },
                '180': { gold: 3000, exp: 1000 }
            };
            
            const reward = rewards[goalType];
            if (!reward) {
                await interaction.reply({ content: 'ì˜ëª»ëœ ëª©í‘œì…ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            // ì´ë¯¸ ìˆ˜ë ¹í–ˆëŠ”ì§€ í™•ì¸
            if (user.fitness.goals.daily[`claimed${goalType}`]) {
                await interaction.reply({ content: 'ì´ë¯¸ ë³´ìƒì„ ìˆ˜ë ¹í–ˆìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            user.gold += reward.gold;
            user.exp += reward.exp;
            user.fitness.goals.daily[`claimed${goalType}`] = true;
            
            // ë ˆë²¨ì—… ì²´í¬
            const { leveledUp, levelsGained, oldLevel } = processLevelUp(user);
            await user.save();
            
            const levelUpMessage = leveledUp ? `\nğŸ‰ **ë ˆë²¨ì—…!** Lv.${oldLevel} â†’ Lv.${user.level}` : '';
            
            await interaction.reply({ 
                content: `âœ… ${goalType}ë¶„ ìš´ë™ ëª©í‘œ ë³´ìƒì„ ìˆ˜ë ¹í–ˆìŠµë‹ˆë‹¤!\nğŸ’° +${reward.gold.toLocaleString()}G | âœ¨ +${reward.exp} EXP${levelUpMessage}`, 
                flags: 64 
            });
        }
        
        else if (interaction.customId === 'info') {
            const maxExp = user.level * 100;
            const embed = new EmbedBuilder()
                .setColor('#9932cc')
                .setTitle('ë‚´ ì •ë³´')
                .setDescription(`**${user.nickname}**ë‹˜ì˜ ê²Œì„ ì •ë³´`)
                .addFields(
                    { name: 'ë ˆë²¨', value: `Lv.${user.level}`, inline: true },
                    { name: 'ê²½í—˜ì¹˜', value: `${user.exp}/${maxExp} EXP`, inline: true },
                    { name: 'ê³¨ë“œ', value: `${user.gold.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true },
                    { name: 'ì¸ê¸°ë„', value: `${user.popularity} ${user.popularity > 0 ? 'â¤ï¸' : user.popularity < 0 ? 'ğŸ’”' : ''}`, inline: true },
                    { name: 'ì¶œì„ì²´í¬', value: user.lastDaily === new Date().toDateString() ? 'ì™„ë£Œ' : 'ë¯¸ì™„ë£Œ', inline: true },
                    { name: 'ìš´ë™ìƒíƒœ', value: user.fitness.currentExercise.type ? 'ìš´ë™ì¤‘' : 'ëŒ€ê¸°ì¤‘', inline: true },
                    { name: 'ì—°ì† ì¶œì„', value: `${user.attendanceStreak || 0}ì¼ ğŸ”¥`, inline: true },
                    { name: 'ì£¼ê°„ ì¶œì„', value: `${user.weeklyAttendance ? user.weeklyAttendance.filter(x => x).length : 0}/7ì¼`, inline: true }
                );

            await interaction.reply({ embeds: [embed], flags: 64 });
        }
        
        else if (interaction.customId === 'stats') {
            const totalStats = user.stats.strength + user.stats.agility + user.stats.intelligence + user.stats.vitality + user.stats.luck;
            
            const statsEmbed = new EmbedBuilder()
                .setColor('#ff6b6b')
                .setTitle('ğŸ’ª ëŠ¥ë ¥ì¹˜')
                .setDescription(`**${user.nickname}**ë‹˜ì˜ ëŠ¥ë ¥ì¹˜ ì •ë³´`)
                .addFields(
                    { name: 'ğŸ’ª í˜', value: `${user.stats.strength}`, inline: true },
                    { name: 'ğŸƒ ë¯¼ì²©', value: `${user.stats.agility}`, inline: true },
                    { name: 'ğŸ§  ì§€ëŠ¥', value: `${user.stats.intelligence}`, inline: true },
                    { name: 'â¤ï¸ ì²´ë ¥', value: `${user.stats.vitality}`, inline: true },
                    { name: 'ğŸ€ í–‰ìš´', value: `${user.stats.luck}`, inline: true },
                    { name: 'ğŸ“Š ì´í•©', value: `${totalStats}`, inline: true },
                    { name: 'â­ ë³´ìœ  ìŠ¤íƒ¯í¬ì¸íŠ¸', value: `${user.statPoints}ì `, inline: false }
                )
                .setFooter({ text: 'ë ˆë²¨ì—… ì‹œ ìŠ¤íƒ¯í¬ì¸íŠ¸ê°€ ì§€ê¸‰ë©ë‹ˆë‹¤!' });

            const statButtons = new ActionRowBuilder();
            
            if (user.statPoints > 0) {
                statButtons.addComponents(
                    new ButtonBuilder()
                        .setCustomId('add_strength')
                        .setLabel('ğŸ’ª í˜ +1')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('add_agility')
                        .setLabel('ğŸƒ ë¯¼ì²© +1')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('add_intelligence')
                        .setLabel('ğŸ§  ì§€ëŠ¥ +1')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('add_vitality')
                        .setLabel('â¤ï¸ ì²´ë ¥ +1')
                        .setStyle(ButtonStyle.Primary)
                );
            } else {
                statButtons.addComponents(
                    new ButtonBuilder()
                        .setCustomId('stats_info')
                        .setLabel('ìŠ¤íƒ¯í¬ì¸íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(true)
                );
            }

            await interaction.reply({ 
                embeds: [statsEmbed], 
                components: user.statPoints > 0 ? [statButtons] : [statButtons],
                flags: 64 
            });
        }
        
        else if (interaction.customId === 'skills') {
            const skillsEmbed = new EmbedBuilder()
                .setColor('#4ecdc4')
                .setTitle('ğŸ”® ìŠ¤í‚¬')
                .setDescription(`**${user.nickname}**ë‹˜ì˜ ìŠ¤í‚¬ ì •ë³´`)
                .addFields(
                    { name: 'ğŸ“š ë³´ìœ  ìŠ¤í‚¬', value: user.skills.length > 0 ? user.skills.map(skill => `**${skill.name}** Lv.${skill.level}`).join('\n') : 'ë³´ìœ í•œ ìŠ¤í‚¬ì´ ì—†ìŠµë‹ˆë‹¤.', inline: false },
                    { name: 'ğŸ’¡ ìŠ¤í‚¬ íšë“', value: 'íŠ¹ì • ì¡°ê±´ì„ ë§Œì¡±í•˜ë©´ ìƒˆë¡œìš´ ìŠ¤í‚¬ì„ ìŠµë“í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!', inline: false }
                )
                .setFooter({ text: 'ìŠ¤í‚¬ì€ ì „íˆ¬ì™€ í™œë™ì—ì„œ ë„ì›€ì„ ì¤ë‹ˆë‹¤!' });

            await interaction.reply({ embeds: [skillsEmbed], flags: 64 });
        }
        
        else if (interaction.customId.startsWith('add_')) {
            const statType = interaction.customId.replace('add_', '');
            
            if (user.statPoints <= 0) {
                await interaction.reply({ content: 'ìŠ¤íƒ¯í¬ì¸íŠ¸ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            user.stats[statType] += 1;
            user.statPoints -= 1;
            await user.save();
            
            const statNames = {
                strength: 'ğŸ’ª í˜',
                agility: 'ğŸƒ ë¯¼ì²©', 
                intelligence: 'ğŸ§  ì§€ëŠ¥',
                vitality: 'â¤ï¸ ì²´ë ¥',
                luck: 'ğŸ€ í–‰ìš´'
            };
            
            await interaction.reply({ 
                content: `${statNames[statType]}ì´ 1 ì¦ê°€í–ˆìŠµë‹ˆë‹¤! (${user.stats[statType]-1} â†’ ${user.stats[statType]})`, 
                flags: 64 
            });
        }
        
        else if (interaction.customId === 'shop') {
            const shopMainAttachment = new AttachmentBuilder(path.join(__dirname, 'resource', 'kim_shop_main.gif'), { name: 'kim_shop_main.gif' });
            
            const shopEmbed = new EmbedBuilder()
                .setColor('#ff6b6b')
                .setTitle('ğŸ›’ ê¹€í—Œí„° ìƒì ')
                .setDescription(`**${user.nickname}** ëª¨í—˜ê°€ë‹˜, ì´ ë³´ìœ ê¸ˆì•¡ì€ **${user.gold.toLocaleString()}<:currency_emoji:1377404064316522778>**ì…ë‹ˆë‹¤.\n\nì›í•˜ëŠ” ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•˜ì—¬ ì•„ì´í…œì„ êµ¬ë§¤í•˜ì„¸ìš”!`)
                .setImage('attachment://kim_shop_main.gif');

            const categorySelect = new ActionRowBuilder()
                .addComponents(
                    new StringSelectMenuBuilder()
                        .setCustomId('shop_category')
                        .setPlaceholder('ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•˜ì„¸ìš”')
                        .addOptions([
                            {
                                label: 'ë¬´ê¸°',
                                description: 'ê²€, ë„ë¼, í™œ, ì§€íŒ¡ì´ ë“±',
                                value: 'weapon',
                                emoji: 'âš”ï¸'
                            },
                            {
                                label: 'í—¬ë©§',
                                description: 'íˆ¬êµ¬, ëª¨ì, ë¨¸ë¦¬ë  ë“±',
                                value: 'helmet',
                                emoji: 'â›‘ï¸'
                            },
                            {
                                label: 'ê°‘ì˜·',
                                description: 'ê°‘ì˜·, ë¡œë¸Œ, ì˜ë³µ ë“±',
                                value: 'armor',
                                emoji: 'ğŸ›¡ï¸'
                            },
                            {
                                label: 'ì¥ê°‘',
                                description: 'ì¥ê°‘, íŒ”ì°Œ, ì†ëª©ë³´í˜¸ëŒ€ ë“±',
                                value: 'gloves',
                                emoji: 'ğŸ§¤'
                            },
                            {
                                label: 'ì‹ ë°œ',
                                description: 'ë¶€ì¸ , ì‹ ë°œ, ë°œëª©ë³´í˜¸ëŒ€ ë“±',
                                value: 'boots',
                                emoji: 'ğŸ‘¢'
                            },
                            {
                                label: 'ì†Œë¹„',
                                description: 'í¬ì…˜, ìŠ¤í¬ë¡¤, ë²„í”„ì•„ì´í…œ ë“±',
                                value: 'consumable',
                                emoji: 'ğŸ’Š'
                            },
                            {
                                label: 'ì£¼ë¬¸ì„œ',
                                description: 'ê°•í™”ì„, ê°•í™” ì¬ë£Œ ë“±',
                                value: 'enhancement',
                                emoji: 'âš’ï¸'
                            },
                            {
                                label: 'ì½”ì¸',
                                description: 'íŠ¹ë³„í•œ ì½”ì¸ê³¼ ì¬í™”',
                                value: 'coin',
                                emoji: 'ğŸª™'
                            }
                        ])
                );

            const backButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('back_to_game_menu')
                        .setLabel('ğŸ® ê²Œì„ ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸°')
                        .setStyle(ButtonStyle.Success)
                );

            await interaction.reply({ 
                embeds: [shopEmbed], 
                components: [categorySelect, backButton], 
                files: [shopMainAttachment],
                flags: [64] // InteractionResponseFlags.Ephemeral
            });
        }
        
        else if (interaction.customId === 'manual_fusion_select') {
            const selectedValue = interaction.values[0];
            const level = parseInt(selectedValue.replace('manual_fusion_', ''));
            
            const user = await getUser(interaction.user.id);
            if (!user) {
                await interaction.update({ content: 'ìœ ì € ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', embeds: [], components: [] });
                return;
            }
            
            const fragments = new Map(user.energyFragments.fragments);
            const fragmentCount = fragments.get(level.toString()) || 0;
            
            if (fragmentCount < 2) {
                await interaction.update({ 
                    content: 'í•´ë‹¹ ì¡°ê°ì´ ë¶€ì¡±í•©ë‹ˆë‹¤! ìµœì†Œ 2ê°œê°€ í•„ìš”í•©ë‹ˆë‹¤.', 
                    embeds: [], 
                    components: [] 
                });
                return;
            }
            
            const cost = calculateFusionCost(level);
            if (user.gold < cost) {
                await interaction.update({ 
                    content: `ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤! í•„ìš”: ${cost.toLocaleString()}G, ë³´ìœ : ${user.gold.toLocaleString()}G`, 
                    embeds: [], 
                    components: [] 
                });
                return;
            }
            
            // ìœµí•© í™•ì¸ ë²„íŠ¼
            const fragmentInfo = getFragmentInfo(level);
            const nextInfo = getFragmentInfo(level + 1);
            
            let successRate = getSuccessRate(level);
            
            // ê°•í™” ë³´ë„ˆìŠ¤ ê³„ì‚°
            let enhanceBonus = 0;
            for (const equipment of Object.values(user.equipment)) {
                if (equipment && equipment.enhanceLevel >= 20) {
                    if (equipment.enhanceLevel >= 30) enhanceBonus = 15;
                    else if (equipment.enhanceLevel >= 25) enhanceBonus = 10;
                    else enhanceBonus = 5;
                    break;
                }
            }
            successRate += enhanceBonus;
            successRate += user.energyFragments.permanentSuccessBonus;
            successRate += user.energyFragments.weeklyRankingBonus;
            
            const guaranteedSuccess = user.energyFragments.failureStack >= ENERGY_FRAGMENT_SYSTEM.FAILURE_STACK_REQUIRED;
            const finalSuccessRate = guaranteedSuccess ? 100 : Math.min(100, successRate);
            
            const confirmEmbed = new EmbedBuilder()
                .setColor('#FFD700')
                .setTitle('ğŸ¯ ìœµí•© í™•ì¸')
                .setDescription(`**${fragmentInfo.name}** ìœµí•©ì„ ì‹œë„í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)
                .addFields(
                    { name: 'ğŸ“Š ìœµí•© ì •ë³´', value: `${fragmentInfo.emoji} Lv.${level} (2ê°œ) â†’ ${nextInfo.emoji} Lv.${level + 1} (1ê°œ)`, inline: false },
                    { name: 'ğŸ’° ë¹„ìš©', value: `${cost.toLocaleString()}G`, inline: true },
                    { name: 'ğŸ¯ ì„±ê³µë¥ ', value: guaranteedSuccess ? '**100% (ìŠ¤íƒ ë³´ì¥)**' : `${finalSuccessRate}%`, inline: true },
                    { name: 'ğŸ’ ë³´ìƒ', value: `${(level + 1) * 500}G`, inline: true }
                );
            
            if (enhanceBonus > 0) {
                confirmEmbed.addFields({ name: 'ğŸ”¨ ì¥ë¹„ ë³´ë„ˆìŠ¤', value: `+${enhanceBonus}%`, inline: true });
            }
            
            const confirmButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId(`confirm_manual_fusion_${level}`)
                        .setLabel('âœ… ìœµí•© ì‹œë„')
                        .setStyle(ButtonStyle.Success),
                    new ButtonBuilder()
                        .setCustomId('cancel_manual_fusion')
                        .setLabel('âŒ ì·¨ì†Œ')
                        .setStyle(ButtonStyle.Danger)
                );
                
            await interaction.update({ embeds: [confirmEmbed], components: [confirmButtons] });
        }
        
        else if (interaction.customId.startsWith('confirm_manual_fusion_')) {
            const level = parseInt(interaction.customId.split('_')[3]);
            
            const user = await getUser(interaction.user.id);
            if (!user) {
                await interaction.update({ content: 'ìœ ì € ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', embeds: [], components: [] });
                return;
            }
            
            const fragments = new Map(user.energyFragments.fragments);
            const fragmentCount = fragments.get(level.toString()) || 0;
            
            if (fragmentCount < 2) {
                await interaction.update({ 
                    content: 'í•´ë‹¹ ì¡°ê°ì´ ë¶€ì¡±í•©ë‹ˆë‹¤! ìµœì†Œ 2ê°œê°€ í•„ìš”í•©ë‹ˆë‹¤.', 
                    embeds: [], 
                    components: [] 
                });
                return;
            }
            
            const cost = calculateFusionCost(level);
            if (user.gold < cost) {
                await interaction.update({ 
                    content: `ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤! í•„ìš”: ${cost.toLocaleString()}G, ë³´ìœ : ${user.gold.toLocaleString()}G`, 
                    embeds: [], 
                    components: [] 
                });
                return;
            }
            
            // ìœµí•© ì‹œë„ ë¡œì§ ì‹¤í–‰
            const fragmentInfo = getFragmentInfo(level);
            const nextInfo = getFragmentInfo(level + 1);
            
            let successRate = getSuccessRate(level);
            
            // ê°•í™” ë³´ë„ˆìŠ¤ ê³„ì‚°
            let enhanceBonus = 0;
            for (const equipment of Object.values(user.equipment)) {
                if (equipment && equipment.enhanceLevel >= 20) {
                    if (equipment.enhanceLevel >= 30) enhanceBonus = 15;
                    else if (equipment.enhanceLevel >= 25) enhanceBonus = 10;
                    else enhanceBonus = 5;
                    break;
                }
            }
            successRate += enhanceBonus;
            successRate += user.energyFragments.permanentSuccessBonus;
            successRate += user.energyFragments.weeklyRankingBonus;
            
            const guaranteedSuccess = user.energyFragments.failureStack >= ENERGY_FRAGMENT_SYSTEM.FAILURE_STACK_REQUIRED;
            const finalSuccessRate = guaranteedSuccess ? 100 : Math.min(100, successRate);
            
            const isSuccess = guaranteedSuccess || Math.random() * 100 < finalSuccessRate;
            
            // ë¹„ìš© ì°¨ê°
            user.gold -= cost;
            
            // ì¡°ê° ì°¨ê°
            fragments.set(level.toString(), fragmentCount - 2);
            
            let resultEmbed;
            
            if (isSuccess) {
                // ì„±ê³µ ì‹œ ìƒìœ„ ì¡°ê° ì¶”ê°€
                const nextFragmentCount = fragments.get((level + 1).toString()) || 0;
                fragments.set((level + 1).toString(), nextFragmentCount + 1);
                
                // ì‹¤íŒ¨ ìŠ¤íƒ ì´ˆê¸°í™”
                user.energyFragments.failureStack = 0;
                
                // ë³´ìƒ ê³¨ë“œ ì¶”ê°€
                const rewardGold = (level + 1) * 500;
                user.gold += rewardGold;
                
                resultEmbed = new EmbedBuilder()
                    .setColor('#00FF00')
                    .setTitle('âœ… ìœµí•© ì„±ê³µ!')
                    .setDescription(`**${fragmentInfo.name}** ìœµí•©ì— ì„±ê³µí–ˆìŠµë‹ˆë‹¤!`)
                    .addFields(
                        { name: 'ğŸ¯ ê²°ê³¼', value: `${fragmentInfo.emoji} Lv.${level} (2ê°œ) â†’ ${nextInfo.emoji} Lv.${level + 1} (1ê°œ)`, inline: false },
                        { name: 'ğŸ‰ ë³´ìƒ', value: `${rewardGold.toLocaleString()}G`, inline: true },
                        { name: 'ğŸ’° í˜„ì¬ ê³¨ë“œ', value: `${user.gold.toLocaleString()}G`, inline: true }
                    );
            } else {
                // ì‹¤íŒ¨ ì‹œ ì‹¤íŒ¨ ìŠ¤íƒ ì¦ê°€
                user.energyFragments.failureStack++;
                
                resultEmbed = new EmbedBuilder()
                    .setColor('#FF0000')
                    .setTitle('âŒ ìœµí•© ì‹¤íŒ¨!')
                    .setDescription(`**${fragmentInfo.name}** ìœµí•©ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤...`)
                    .addFields(
                        { name: 'ğŸ’” ê²°ê³¼', value: `${fragmentInfo.emoji} Lv.${level} (2ê°œ) â†’ ì†Œì‹¤`, inline: false },
                        { name: 'ğŸ“ˆ ì‹¤íŒ¨ ìŠ¤íƒ', value: `${user.energyFragments.failureStack}/${ENERGY_FRAGMENT_SYSTEM.FAILURE_STACK_REQUIRED}`, inline: true },
                        { name: 'ğŸ’° í˜„ì¬ ê³¨ë“œ', value: `${user.gold.toLocaleString()}G`, inline: true }
                    );
                
                if (user.energyFragments.failureStack >= ENERGY_FRAGMENT_SYSTEM.FAILURE_STACK_REQUIRED) {
                    resultEmbed.addFields({ name: 'ğŸ¯ ë‹¤ìŒ ìœµí•©', value: '**100% ì„±ê³µ ë³´ì¥!**', inline: false });
                }
            }
            
            // ì¡°ê° ë°ì´í„° ì—…ë°ì´íŠ¸
            user.energyFragments.fragments = Array.from(fragments.entries());
            
            // ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥
            await user.save();
            
            await interaction.update({ embeds: [resultEmbed], components: [] });
        }
        
        else if (interaction.customId === 'cancel_manual_fusion') {
            await interaction.update({ 
                content: 'ìœµí•©ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.', 
                embeds: [], 
                components: [] 
            });
        }
        
        else if (interaction.customId === 'shop_category') {
            const selectedCategory = interaction.values[0];
            
            // ì „ì—­ ìƒì  ì¹´í…Œê³ ë¦¬ ë°ì´í„° ì‚¬ìš©
            const categoryData = SHOP_CATEGORIES[selectedCategory];
            if (!categoryData) {
                await interaction.update({ content: 'í•´ë‹¹ ì¹´í…Œê³ ë¦¬ëŠ” ì•„ì§ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤!', embeds: [], components: [] });
                return;
            }
            
            // ì¹´í…Œê³ ë¦¬ ì´ë¯¸ì§€ ì²¨ë¶€íŒŒì¼ ìƒì„±
            const categoryAttachment = new AttachmentBuilder(path.join(__dirname, 'resource', categoryData.gif), { name: categoryData.gif });
            
            // ë“±ê¸‰ë³„ ì»¤ìŠ¤í…€ ì´ëª¨ì§€
            const rarityEmojis = {
                'ì¼ë°˜': '<:common_emoji:1381597953072037909>',
                'ê³ ê¸‰': '<:uncomon_emoji:1381598058327838752>',
                'ë ˆì–´': '<:rare_emoji:1381598053974278154>',
                'ì—í”½': '<:epic_emoji:1381598051046658048>',
                'ë ˆì „ë“œë¦¬': '<:legendary_emoji:1381598048446189589>'
            };
            
            // ê³¨ë“œ ì»¤ìŠ¤í…€ ì´ëª¨ì§€
            const goldEmoji = '<:currency_emoji:1377404064316522778>';
            
            // Use the global category data
            const category = categoryData;
            if (!category) {
                await interaction.update({ content: 'í•´ë‹¹ ì¹´í…Œê³ ë¦¬ëŠ” ì•„ì§ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤!', embeds: [], components: [] });
                return;
            }
            
            // í˜ì´ì§€ë³„ ë“±ê¸‰ ì •ì˜
            const pageRarities = {
                0: ['ì¼ë°˜', 'ê³ ê¸‰', 'ë ˆì–´'],        // 1í˜ì´ì§€
                1: ['ì—í”½', 'ë ˆì „ë“œë¦¬']           // 2í˜ì´ì§€
            };
            
            const totalPages = 2; // ê³ ì • 2í˜ì´ì§€
            const currentPage = 0; // ì²« í˜ì´ì§€ë¶€í„° ì‹œì‘

            // í˜„ì¬ í˜ì´ì§€ì— í•´ë‹¹í•˜ëŠ” ë“±ê¸‰ë“¤ì˜ ì•„ì´í…œë§Œ í•„í„°ë§
            const currentPageRarities = pageRarities[currentPage];
            const currentItems = category.items.filter(item => 
                currentPageRarities.includes(item.rarity)
            );

            // ë“±ê¸‰ë³„ë¡œ ì•„ì´í…œ ê·¸ë£¹í™”
            const itemsByRarity = {};
            currentItems.forEach(item => {
                if (!itemsByRarity[item.rarity]) {
                    itemsByRarity[item.rarity] = [];
                }
                itemsByRarity[item.rarity].push(item);
            });

            // ë“±ê¸‰ ìˆœì„œ ì •ì˜
            const rarityOrder = ['ë…¸ë©€', 'ë ˆì–´', 'ì—í”½', 'ë ˆì „ë“œë¦¬', 'ìœ ë‹ˆí¬'];
            
            // í˜„ì¬ í˜ì´ì§€ì˜ ë“±ê¸‰ë“¤ë§Œ í‘œì‹œ
            let itemList = '';
            currentPageRarities.forEach(rarity => {
                if (itemsByRarity[rarity] && itemsByRarity[rarity].length > 0) {
                    itemList += `${rarityEmojis[rarity]} **${rarity}**\n`;
                    itemsByRarity[rarity].forEach(item => {
                        itemList += `\`${item.name}\` - ${item.price.toLocaleString()}${goldEmoji}\n`;
                    });
                    itemList += '\n'; // ë“±ê¸‰ ê°„ êµ¬ë¶„ì„ ìœ„í•œ ë¹ˆ ì¤„
                }
            });
            
            const categoryEmbed = new EmbedBuilder()
                .setColor('#ff6b6b')
                .setTitle(`${category.emoji} ${category.name} ìƒì `)
                .setDescription(`${category.name} ì¹´í…Œê³ ë¦¬ì˜ ì•„ì´í…œë“¤ì…ë‹ˆë‹¤.\n\n${itemList}`)
                .setThumbnail(`attachment://${categoryData.gif}`)
                .setFooter({ text: `í˜ì´ì§€ ${currentPage + 1}/${totalPages} | ì•„ì´í…œì„ í´ë¦­í•˜ì—¬ êµ¬ë§¤í•˜ì„¸ìš”!` });
            
            // ë“±ê¸‰ë³„ ë²„íŠ¼ ìŠ¤íƒ€ì¼ ì„¤ì •
            const getRarityButtonStyle = (rarity) => {
                switch(rarity) {
                    case 'ì¼ë°˜': return ButtonStyle.Secondary; // íšŒìƒ‰
                    case 'ê³ ê¸‰': return ButtonStyle.Primary;   // íŒŒë€ìƒ‰
                    case 'ë ˆì–´': return ButtonStyle.Danger;    // ë¹¨ê°„ìƒ‰
                    case 'ì—í”½': return ButtonStyle.Success; // ì´ˆë¡ìƒ‰
                    case 'ë ˆì „ë“œë¦¬': return ButtonStyle.Danger; // ë¹¨ê°„ìƒ‰
                    default: return ButtonStyle.Secondary;
                }
            };

            // ì•„ì´í…œ êµ¬ë§¤ ë²„íŠ¼ë“¤ (3ê°œì”© 3ì¤„)
            const itemButtons = [];
            for (let i = 0; i < currentItems.length; i += 3) {
                const row = new ActionRowBuilder();
                const rowItems = currentItems.slice(i, i + 3);
                
                rowItems.forEach((item, index) => {
                    // ì „ì²´ ì•„ì´í…œ ë°°ì—´ì—ì„œì˜ ì‹¤ì œ ì¸ë±ìŠ¤ ì°¾ê¸°
                    const actualIndex = category.items.findIndex(categoryItem => 
                        categoryItem.name === item.name && categoryItem.rarity === item.rarity
                    );
                    row.addComponents(
                        new ButtonBuilder()
                            .setCustomId(`buy_${selectedCategory}_${actualIndex}`)
                            .setLabel(`${item.name}`)
                            .setStyle(getRarityButtonStyle(item.rarity))
                            .setDisabled(user.gold < item.price)
                    );
                });
                
                itemButtons.push(row);
            }

            // ë„¤ë¹„ê²Œì´ì…˜ ë²„íŠ¼ (ì‚¬ëƒ¥í„°ì™€ ë™ì¼í•œ ë°©ì‹)
            const navButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId(`shop_${selectedCategory}_prev_page`)
                        .setLabel('â—€ ì´ì „')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(currentPage === 0),
                    new ButtonBuilder()
                        .setCustomId(`shop_${selectedCategory}_page_info`)
                        .setLabel(`${currentPage + 1}/${totalPages}`)
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(true),
                    new ButtonBuilder()
                        .setCustomId(`shop_${selectedCategory}_next_page`)
                        .setLabel('ë‹¤ìŒ â–¶')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(currentPage >= totalPages - 1),
                    new ButtonBuilder()
                        .setCustomId('shop')
                        .setLabel('ğŸ”™ ìƒì  ë©”ì¸')
                        .setStyle(ButtonStyle.Primary)
                );

            // ëª¨ë“  ë²„íŠ¼ í•©ì¹˜ê¸°
            const allComponents = [...itemButtons, navButtons];

            await interaction.update({
                embeds: [categoryEmbed],
                components: allComponents,
                files: [categoryAttachment]
            });
        }
        
        // ìƒì  ì¹´í…Œê³ ë¦¬ ë²„íŠ¼ ì²˜ë¦¬ (shop_weapon, shop_armor ë“±)
        else if (interaction.customId.startsWith('shop_') && !interaction.customId.includes('_page') && interaction.customId !== 'shop_category') {
            const category = interaction.customId.replace('shop_', '');
            
            // ì „ì—­ ìƒì  ì¹´í…Œê³ ë¦¬ ë°ì´í„° ì‚¬ìš©
            const categoryData = SHOP_CATEGORIES[category];
            if (!categoryData) {
                await interaction.reply({ content: 'í•´ë‹¹ ì¹´í…Œê³ ë¦¬ëŠ” ì•„ì§ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            // ì¹´í…Œê³ ë¦¬ ì´ë¯¸ì§€ ì²¨ë¶€íŒŒì¼ ìƒì„±
            const categoryAttachment = new AttachmentBuilder(
                path.join(__dirname, 'resource', categoryData.gif), 
                { name: categoryData.gif }
            );
            
            // ì²« ë²ˆì§¸ í˜ì´ì§€ ë°ì´í„°
            const currentPage = 0;
            const itemsPerPage = 4;
            const startIndex = currentPage * itemsPerPage;
            const endIndex = Math.min(startIndex + itemsPerPage, categoryData.items.length);
            const currentItems = categoryData.items.slice(startIndex, endIndex);
            const totalPages = Math.ceil(categoryData.items.length / itemsPerPage);
            
            // ì¹´í…Œê³ ë¦¬ ì •ë³´ ì„ë² ë“œ
            const description = `**${user.nickname}** ëª¨í—˜ê°€ë‹˜ì˜ í˜„ì¬ ë³´ìœ ê¸ˆì•¡: **${user.gold.toLocaleString()}<:currency_emoji:1377404064316522778>**\n\nêµ¬ë§¤í•˜ê³  ì‹¶ì€ ì•„ì´í…œì„ ì„ íƒí•˜ì„¸ìš”!`;
            
            const categoryEmbed = new EmbedBuilder()
                .setColor('#ff6b6b')
                .setTitle(`ğŸ›’ ${categoryData.name}`)
                .setDescription(description)
                .setImage(`attachment://${categoryData.gif}`)
                .setFooter({ text: `í˜ì´ì§€ ${currentPage + 1}/${totalPages}` });
            
            // ì•„ì´í…œ ë²„íŠ¼ë“¤ ìƒì„± (ìµœëŒ€ 2í–‰)
            const itemButtons = [];
            for (let i = 0; i < currentItems.length; i += 2) {
                const row = new ActionRowBuilder();
                
                // ì²« ë²ˆì§¸ ì•„ì´í…œ
                if (currentItems[i]) {
                    const item = currentItems[i];
                    row.addComponents(
                        new ButtonBuilder()
                            .setCustomId(`buy_${item.id}`)
                            .setLabel(`${item.name} (${item.price.toLocaleString()}G)`)
                            .setStyle(ButtonStyle.Success)
                            .setEmoji(item.emoji || 'ğŸ’')
                    );
                }
                
                // ë‘ ë²ˆì§¸ ì•„ì´í…œ (ìˆëŠ” ê²½ìš°)
                if (currentItems[i + 1]) {
                    const item = currentItems[i + 1];
                    row.addComponents(
                        new ButtonBuilder()
                            .setCustomId(`buy_${item.id}`)
                            .setLabel(`${item.name} (${item.price.toLocaleString()}G)`)
                            .setStyle(ButtonStyle.Success)
                            .setEmoji(item.emoji || 'ğŸ’')
                    );
                }
                
                itemButtons.push(row);
            }
            
            // ë„¤ë¹„ê²Œì´ì…˜ ë²„íŠ¼
            const navButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId(`shop_${category}_prev_page`)
                        .setLabel('â—€ ì´ì „')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(currentPage === 0),
                    new ButtonBuilder()
                        .setCustomId(`shop_${category}_page_info`)
                        .setLabel(`${currentPage + 1}/${totalPages}`)
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(true),
                    new ButtonBuilder()
                        .setCustomId(`shop_${category}_next_page`)
                        .setLabel('ë‹¤ìŒ â–¶')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(currentPage >= totalPages - 1),
                    new ButtonBuilder()
                        .setCustomId('shop')
                        .setLabel('ğŸ”™ ìƒì  ë©”ì¸')
                        .setStyle(ButtonStyle.Primary)
                );
            
            // ëª¨ë“  ë²„íŠ¼ í•©ì¹˜ê¸°
            const allComponents = [...itemButtons, navButtons];
            
            await interaction.reply({
                embeds: [categoryEmbed],
                components: allComponents,
                files: [categoryAttachment]
            });
        }
        
        else if (interaction.customId.includes('_prev_page') || interaction.customId.includes('_next_page')) {
            // ìƒì  í˜ì´ì§€ë„¤ì´ì…˜ ì²˜ë¦¬
            const parts = interaction.customId.split('_');
            const category = parts[1];
            const direction = parts[2]; // 'prev' ë˜ëŠ” 'next'
            
            // í˜„ì¬ í˜ì´ì§€ ì •ë³´ ì¶”ì¶œ (ì„ë² ë“œì˜ footerì—ì„œ)
            const currentEmbed = interaction.message.embeds[0];
            const footerText = currentEmbed.footer?.text || '';
            const pageMatch = footerText.match(/í˜ì´ì§€ (\d+)\/(\d+)/);
            
            if (!pageMatch) {
                await interaction.reply({ content: 'í˜ì´ì§€ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            const currentPage = parseInt(pageMatch[1]) - 1; // 0-based index
            const totalPages = parseInt(pageMatch[2]);
            
            let newPage = currentPage;
            if (direction === 'prev' && currentPage > 0) {
                newPage = currentPage - 1;
            } else if (direction === 'next' && currentPage < totalPages - 1) {
                newPage = currentPage + 1;
            }
            
            // ì „ì—­ ìƒì  ì¹´í…Œê³ ë¦¬ ë°ì´í„° ì‚¬ìš©
            const categoryData = SHOP_CATEGORIES[category];
            if (!categoryData) {
                await interaction.reply({ content: 'ì¹´í…Œê³ ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            // ì¹´í…Œê³ ë¦¬ ì´ë¯¸ì§€ ì²¨ë¶€íŒŒì¼ ìƒì„±
            const categoryAttachment = new AttachmentBuilder(path.join(__dirname, 'resource', categoryData.gif), { name: categoryData.gif });
            
            // í˜ì´ì§€ ì¬êµ¬ì„± - ë“±ê¸‰ë³„ í•„í„°ë§ ì‚¬ìš©
            const rarityEmojis = {
                'ì¼ë°˜': '<:common_emoji:1381597953072037909>',
                'ê³ ê¸‰': '<:uncomon_emoji:1381598058327838752>',
                'ë ˆì–´': '<:rare_emoji:1381598053974278154>',
                'ì—í”½': '<:epic_emoji:1381598051046658048>',
                'ë ˆì „ë“œë¦¬': '<:legendary_emoji:1381598048446189589>'
            };
            
            // ê³¨ë“œ ì»¤ìŠ¤í…€ ì´ëª¨ì§€
            const goldEmoji = '<:currency_emoji:1377404064316522778>';
            
            // í˜ì´ì§€ë³„ ë“±ê¸‰ ì •ì˜ (ì¹´í…Œê³ ë¦¬ í‘œì‹œì™€ ë™ì¼í•œ ë¡œì§)
            const pageRarities = {
                0: ['ì¼ë°˜', 'ê³ ê¸‰', 'ë ˆì–´'],        // 1í˜ì´ì§€
                1: ['ì—í”½', 'ë ˆì „ë“œë¦¬']           // 2í˜ì´ì§€
            };
            
            // í˜„ì¬ í˜ì´ì§€ì— í•´ë‹¹í•˜ëŠ” ë“±ê¸‰ë“¤ì˜ ì•„ì´í…œë§Œ í•„í„°ë§
            const currentPageRarities = pageRarities[newPage];
            const currentItems = categoryData.items.filter(item => 
                currentPageRarities.includes(item.rarity)
            );
            
            // ë“±ê¸‰ë³„ë¡œ ì•„ì´í…œ ê·¸ë£¹í™”
            const itemsByRarity = {};
            currentItems.forEach(item => {
                if (!itemsByRarity[item.rarity]) {
                    itemsByRarity[item.rarity] = [];
                }
                itemsByRarity[item.rarity].push(item);
            });
            
            // í˜„ì¬ í˜ì´ì§€ì˜ ë“±ê¸‰ë“¤ë§Œ í‘œì‹œ
            let itemList = '';
            currentPageRarities.forEach(rarity => {
                if (itemsByRarity[rarity] && itemsByRarity[rarity].length > 0) {
                    itemList += `${rarityEmojis[rarity]} **${rarity}**\n`;
                    itemsByRarity[rarity].forEach(item => {
                        itemList += `\`${item.name}\` - ${item.price.toLocaleString()}${goldEmoji}\n`;
                    });
                    itemList += '\n'; // ë“±ê¸‰ ê°„ êµ¬ë¶„ì„ ìœ„í•œ ë¹ˆ ì¤„
                }
            });
            
            const updatedEmbed = new EmbedBuilder()
                .setColor('#ff6b6b')
                .setTitle(`${categoryData.emoji} ${categoryData.name} ìƒì `)
                .setDescription(`${categoryData.name} ì¹´í…Œê³ ë¦¬ì˜ ì•„ì´í…œë“¤ì…ë‹ˆë‹¤.\n\n${itemList}`)
                .setThumbnail(`attachment://${categoryData.gif}`)
                .setFooter({ text: `í˜ì´ì§€ ${newPage + 1}/${totalPages} | ì•„ì´í…œì„ í´ë¦­í•˜ì—¬ êµ¬ë§¤í•˜ì„¸ìš”!` });
            
            // ë²„íŠ¼ ì¬êµ¬ì„±
            const getRarityButtonStyle = (rarity) => {
                switch(rarity) {
                    case 'ë…¸ë©€': return ButtonStyle.Secondary;
                    case 'ë ˆì–´': return ButtonStyle.Primary;
                    case 'ì—í”½': return ButtonStyle.Danger;
                    case 'ìœ ë‹ˆí¬': return ButtonStyle.Success;
                    case 'ë ˆì „ë“œë¦¬': return ButtonStyle.Danger;
                    default: return ButtonStyle.Secondary;
                }
            };
            
            const itemButtons = [];
            for (let i = 0; i < currentItems.length; i += 3) {
                const row = new ActionRowBuilder();
                const rowItems = currentItems.slice(i, i + 3);
                
                rowItems.forEach((item, index) => {
                    // ì „ì²´ ì•„ì´í…œ ë°°ì—´ì—ì„œì˜ ì‹¤ì œ ì¸ë±ìŠ¤ ì°¾ê¸°
                    const actualIndex = categoryData.items.findIndex(categoryItem => 
                        categoryItem.name === item.name && categoryItem.rarity === item.rarity
                    );
                    row.addComponents(
                        new ButtonBuilder()
                            .setCustomId(`buy_${category}_${actualIndex}`)
                            .setLabel(`${item.name}`)
                            .setStyle(getRarityButtonStyle(item.rarity))
                            .setDisabled(user.gold < item.price)
                    );
                });
                
                itemButtons.push(row);
            }
            
            const navButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId(`shop_${category}_prev_page`)
                        .setLabel('â—€ ì´ì „')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(newPage === 0),
                    new ButtonBuilder()
                        .setCustomId(`shop_${category}_page_info`)
                        .setLabel(`${newPage + 1}/${totalPages}`)
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(true),
                    new ButtonBuilder()
                        .setCustomId(`shop_${category}_next_page`)
                        .setLabel('ë‹¤ìŒ â–¶')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(newPage >= totalPages - 1),
                    new ButtonBuilder()
                        .setCustomId('shop')
                        .setLabel('ğŸ”™ ìƒì  ë©”ì¸')
                        .setStyle(ButtonStyle.Primary)
                );

            const allComponents = [...itemButtons, navButtons];

            await interaction.update({
                embeds: [updatedEmbed],
                components: allComponents,
                files: [categoryAttachment]
            });
        }
        
        else if (interaction.customId.startsWith('buy_')) {
            const parts = interaction.customId.split('_');
            if (parts.length < 3) {
                await interaction.reply({ content: 'ì˜ëª»ëœ ì•„ì´í…œ ì„ íƒì…ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            const category = parts[1];
            const itemIndex = parseInt(parts[2]);
            
            // ì „ì—­ ìƒì  ì¹´í…Œê³ ë¦¬ ë°ì´í„° ì‚¬ìš©
            const categoryData = SHOP_CATEGORIES[category];
            if (!categoryData || !categoryData.items[itemIndex]) {
                await interaction.reply({ content: 'ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì•„ì´í…œì…ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            const item = categoryData.items[itemIndex];
            
            if (user.gold < item.price) {
                await interaction.reply({ content: 'ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            // ëœë¤ ëŠ¥ë ¥ì¹˜ ìƒì„±
            const randomStats = generateRandomStats(item.stats);
            
            // ëŠ¥ë ¥ì¹˜ í€„ë¦¬í‹° ê³„ì‚° (1~100%)
            let totalQuality = 0;
            let statCount = 0;
            
            for (const [statName, value] of Object.entries(randomStats)) {
                const [min, max] = item.stats[statName];
                if (min !== max) {
                    const quality = ((value - min) / (max - min)) * 100;
                    totalQuality += quality;
                    statCount++;
                }
            }
            
            const averageQuality = statCount > 0 ? totalQuality / statCount : 100;
            
            // í€„ë¦¬í‹°ì— ë”°ë¥¸ GIF ë° ë©”ì‹œì§€ ì„ íƒ
            let purchaseGif;
            let qualityMessage;
            let embedColor;
            
            if (averageQuality <= 80) {
                // í•˜ìœ„ 80% - 2 ë²„ì „ GIF
                switch(item.type) {
                    case 'weapon':
                        purchaseGif = 'kim_shop_buy_waepon2.gif';
                        break;
                    case 'armor':
                        purchaseGif = 'kim_shop_buy_robe2.gif';
                        break;
                    case 'helmet':
                        purchaseGif = 'kim_shop_buy_hood2.gif';
                        break;
                    case 'gloves':
                        purchaseGif = 'kim_shop_buy_gloves2.gif';
                        break;
                    case 'boots':
                        purchaseGif = 'kim_shop_buy_boots2.gif';
                        break;
                    default:
                        purchaseGif = null;
                }
                
                if (averageQuality <= 20) {
                    qualityMessage = 'ğŸ˜¢ ìµœí•˜ê¸‰ ì˜µì…˜';
                    embedColor = '#7f8c8d'; // íšŒìƒ‰
                } else if (averageQuality <= 40) {
                    qualityMessage = 'ğŸ˜ í•˜ê¸‰ ì˜µì…˜';
                    embedColor = '#95a5a6'; // ì—°í•œ íšŒìƒ‰
                } else if (averageQuality <= 60) {
                    qualityMessage = 'ğŸ™‚ í‰ê·  ì˜µì…˜';
                    embedColor = '#3498db'; // íŒŒë€ìƒ‰
                } else {
                    qualityMessage = 'ğŸ˜Š ì¤€ìˆ˜í•œ ì˜µì…˜';
                    embedColor = '#2ecc71'; // ì´ˆë¡ìƒ‰
                }
            } else {
                // ìƒìœ„ 20% - ê¸°ë³¸ GIF
                switch(item.type) {
                    case 'weapon':
                        purchaseGif = 'kim_shop_buy_waepon.gif';
                        break;
                    case 'armor':
                        purchaseGif = 'kim_shop_buy_robe.gif';
                        break;
                    case 'helmet':
                        purchaseGif = 'kim_shop_buy_hood.gif';
                        break;
                    case 'gloves':
                        purchaseGif = 'kim_shop_buy_gloves.gif';
                        break;
                    case 'boots':
                        purchaseGif = 'kim_shop_buy_boots.gif';
                        break;
                    default:
                        purchaseGif = null;
                }
                
                if (averageQuality <= 90) {
                    qualityMessage = 'ğŸ˜ ìƒê¸‰ ì˜µì…˜!';
                    embedColor = '#e74c3c'; // ë¹¨ê°„ìƒ‰
                } else if (averageQuality <= 95) {
                    qualityMessage = 'ğŸ¤© ìµœìƒê¸‰ ì˜µì…˜!!';
                    embedColor = '#e67e22'; // ì£¼í™©ìƒ‰
                } else {
                    qualityMessage = 'ğŸ”¥ ì™„ë²½í•œ ì˜µì…˜!!!';
                    embedColor = '#f1c40f'; // í™©ê¸ˆìƒ‰
                }
            }
            
            // GIF ì²¨ë¶€íŒŒì¼ ìƒì„± (íŒŒì¼ì´ ì¡´ì¬í•˜ëŠ” ê²½ìš°ì—ë§Œ)
            let purchaseAttachment = null;
            const gifPath = path.join(__dirname, 'resource', purchaseGif);
            try {
                if (fs.existsSync(gifPath)) {
                    purchaseAttachment = new AttachmentBuilder(gifPath, { name: purchaseGif });
                }
            } catch (error) {
                console.log(`GIF íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${purchaseGif}`);
            }
            
            // ëœë¤ ì¶”ê°€ ì˜µì…˜ ìƒì„±
            const randomOptions = generateRandomOptions(item.rarity);
            
            // ì¸ë²¤í† ë¦¬ ê³µê°„ í™•ì¸
            const uniqueItemId = `${category}_${itemIndex}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            const itemData = {
                id: uniqueItemId,
                name: item.name,
                type: item.type,
                rarity: item.rarity,
                setName: item.setName,
                level: item.level || 1,
                quantity: 1,
                enhanceLevel: 0,
                stats: randomStats,
                price: item.price,
                description: item.description || '',
                randomOptions: randomOptions // ì¶”ê°€ ì˜µì…˜ ì €ì¥
            };
            
            const inventoryResult = addItemToInventory(user, itemData);
            if (!inventoryResult.success) {
                await interaction.editReply({ content: inventoryResult.message });
                return;
            }
            
            // ê³¨ë“œ ì°¨ê°
            user.gold -= item.price;
            
            await user.save();
            
            // ì£¼ì‹ ì‹œì¥ ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±° (ìƒì  êµ¬ë§¤)
            recordPlayerAction('shop_purchase');
            
            // ëŠ¥ë ¥ì¹˜ í‘œì‹œ í…ìŠ¤íŠ¸ ìƒì„±
            let statsText = '';
            for (const [statName, value] of Object.entries(randomStats)) {
                if (value !== 0) {
                    const statDisplay = statName === 'attack' ? 'ê³µê²©ë ¥' : 
                                      statName === 'defense' ? 'ë°©ì–´ë ¥' : 
                                      statName === 'dodge' ? 'íšŒí”¼ë ¥' : 
                                      statName === 'luck' ? 'í–‰ìš´' : statName;
                    
                    // ìµœëŒ€ê°’ì¸ ê²½ìš° ê°•ì¡°
                    const [min, max] = item.stats[statName];
                    const isMax = value === max;
                    statsText += `${statDisplay}: ${value > 0 ? '+' : ''}${value}${isMax ? ' ğŸ“ˆ' : ''}\n`;
                }
            }
            
            // ê°€ì±  ì—°ì¶œìš© R ë²„ì „ GIF ì„ íƒ
            let gachaGif;
            switch(item.type) {
                case 'weapon':
                    gachaGif = 'kim_shop_buy_waeponR.gif';
                    break;
                case 'armor':
                case 'helmet':
                    gachaGif = 'kim_shop_buy_robeR.gif';
                    break;
                case 'gloves':
                    gachaGif = 'kim_shop_buy_glovesR.gif';
                    break;
                case 'boots':
                    gachaGif = 'kim_shop_buy_bootsR.gif';
                    break;
                default:
                    gachaGif = null;
            }
            
            // ê°€ì±  ì—°ì¶œìš© ì²¨ë¶€íŒŒì¼ ìƒì„±
            let gachaAttachment = null;
            if (gachaGif) {
                const gachaPath = path.join(__dirname, 'resource', gachaGif);
                try {
                    if (fs.existsSync(gachaPath)) {
                        gachaAttachment = new AttachmentBuilder(gachaPath, { name: gachaGif });
                    }
                } catch (error) {
                    console.log(`ê°€ì±  GIF íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${gachaGif}`);
                }
            }
            
            // ë¨¼ì € ê°€ì±  ì—°ì¶œ GIF í‘œì‹œ
            const gachaEmbed = new EmbedBuilder()
                .setColor('#ffffff')
                .setTitle('ğŸ² ì•„ì´í…œ íšë“ ì¤‘...')
                .setDescription('ì–´ë–¤ ì˜µì…˜ì´ ë‚˜ì˜¬ê¹Œìš”?');
            
            if (gachaAttachment) {
                gachaEmbed.setImage(`attachment://${gachaGif}`);
            }
            
            const gachaOptions = { 
                embeds: [gachaEmbed], 
                components: [],
                flags: 64 
            };
            
            if (gachaAttachment) {
                gachaOptions.files = [gachaAttachment];
            }
            
            await interaction.reply(gachaOptions);
            
            // 0.5ì´ˆ í›„ ì‹¤ì œ êµ¬ë§¤ ì •ë³´ë¡œ ì—…ë°ì´íŠ¸
            setTimeout(async () => {
                // ì¶”ê°€ ì˜µì…˜ í…ìŠ¤íŠ¸ ìƒì„±
                let optionsText = '';
                if (randomOptions.length > 0) {
                    randomOptions.forEach(option => {
                        optionsText += `${option.name}: ${option.displayValue}\n`;
                    });
                }
                
                const purchaseEmbed = new EmbedBuilder()
                    .setColor(embedColor)
                    .setTitle('ğŸ›ï¸ êµ¬ë§¤ ì„±ê³µ!')
                    .setDescription(`**${item.name}**ì„(ë¥¼) ì„±ê³µì ìœ¼ë¡œ êµ¬ë§¤í–ˆìŠµë‹ˆë‹¤!`)
                    .addFields(
                        { name: 'ğŸ’ ì•„ì´í…œ ì •ë³´', value: `${item.setName}\n${item.rarity} ë“±ê¸‰`, inline: true },
                        { name: 'ğŸ“Š ì˜µì…˜ í‰ê°€', value: `${qualityMessage}\n(ìƒìœ„ ${Math.round(100 - averageQuality)}%)`, inline: true },
                        { name: 'ğŸ“ˆ ëœë¤ ëŠ¥ë ¥ì¹˜', value: statsText.trim() || 'ì—†ìŒ', inline: false }
                    );
                
                // ì¶”ê°€ ì˜µì…˜ì´ ìˆëŠ” ê²½ìš°ì—ë§Œ í•„ë“œ ì¶”ê°€
                if (optionsText) {
                    purchaseEmbed.addFields(
                        { name: 'âœ¨ ì¶”ê°€ ì˜µì…˜', value: optionsText.trim(), inline: false }
                    );
                }
                
                purchaseEmbed.addFields(
                    { name: 'ğŸ’° ê²°ì œ ì •ë³´', value: `êµ¬ë§¤ê°€: ${item.price.toLocaleString()}<:currency_emoji:1377404064316522778>\nì”ì•¡: ${user.gold.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true }
                )
                .setFooter({ text: 'ì¸ë²¤í† ë¦¬ì—ì„œ ì¥ì°©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!' });

                if (purchaseAttachment) {
                    purchaseEmbed.setImage(`attachment://${purchaseGif}`);
                }
                
                // ì¬êµ¬ë§¤ ë° ìƒì ë©”ì¸ ë²„íŠ¼ ì¶”ê°€
                const actionButtons = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId(`buy_${category}_${itemIndex}`)
                            .setLabel('ğŸ”„ ì¬êµ¬ë§¤')
                            .setStyle(ButtonStyle.Secondary)
                            .setDisabled(user.gold < item.price),
                        new ButtonBuilder()
                            .setCustomId('shop')
                            .setLabel('ğŸ›’ ìƒì  ë©”ì¸')
                            .setStyle(ButtonStyle.Primary)
                    );
                
                const updateOptions = { 
                    embeds: [purchaseEmbed], 
                    components: [actionButtons],
                    files: purchaseAttachment ? [purchaseAttachment] : []
                };

                await interaction.editReply(updateOptions);
            }, 500);
        }
        
        else if (interaction.customId === 'inventory') {
            if (user.inventory.length === 0) {
                const emptyInventoryEmbed = new EmbedBuilder()
                    .setColor('#e74c3c')
                    .setTitle('ğŸ’ ì¸ë²¤í† ë¦¬')
                    .setDescription('ì¸ë²¤í† ë¦¬ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤!')
                    .addFields(
                        { name: 'ğŸ’¡ íŒ', value: 'ìƒì ì—ì„œ ì•„ì´í…œì„ êµ¬ë§¤í•˜ê±°ë‚˜ ì‚¬ëƒ¥ì„ í†µí•´ ì•„ì´í…œì„ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤!', inline: false }
                    );
                
                await interaction.reply({ embeds: [emptyInventoryEmbed], flags: 64 });
                return;
            }
            
            // ì¸ë²¤í† ë¦¬ ë©”ì¸ í™”ë©´ (ì¹´í…Œê³ ë¦¬ ì„ íƒ)
            const inventoryEmbed = new EmbedBuilder()
                .setColor('#3498db')
                .setTitle('ğŸ’ ì¸ë²¤í† ë¦¬')
                .setDescription(`**${getUserTitle(user)} ${user.nickname}**ë‹˜ì˜ ë³´ìœ  ì•„ì´í…œ\n\nì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•˜ì—¬ ì•„ì´í…œì„ í™•ì¸í•˜ì„¸ìš”!`)
                .addFields(
                    { name: 'ğŸ“Š ì•„ì´í…œ ê°œìˆ˜', value: `ì´ ${user.inventory.length}ê°œ`, inline: true },
                    { name: 'âš”ï¸ ì¥ë¹„ ì•„ì´í…œ', value: `${user.inventory.filter(item => ['weapon', 'armor', 'helmet', 'gloves', 'boots', 'accessory'].includes(item.type)).length}ê°œ`, inline: true },
                    { name: 'ğŸ“œ ê¸°íƒ€ ì•„ì´í…œ', value: `${user.inventory.filter(item => !['weapon', 'armor', 'helmet', 'gloves', 'boots', 'accessory'].includes(item.type)).length}ê°œ`, inline: true }
                );

            // ì¹´í…Œê³ ë¦¬ ë²„íŠ¼ë“¤ (3ê°œì”© 2ì¤„)
            const categoryButtons1 = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('inv_category_weapons')
                        .setLabel('âš”ï¸ ë¬´ê¸°')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('inv_category_armor')
                        .setLabel('ğŸ›¡ï¸ ê°‘ì˜·')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('inv_category_helmet_gloves')
                        .setLabel('â›‘ï¸ í—¬ë©§/ì¥ê°‘')
                        .setStyle(ButtonStyle.Primary)
                );

            const categoryButtons2 = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('inv_category_boots')
                        .setLabel('ğŸ‘¢ ë¶€ì¸ ')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('inv_category_accessory')
                        .setLabel('ğŸ’ ì•¡ì„¸ì„œë¦¬')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('inv_category_scrolls')
                        .setLabel('ğŸ“œ ì£¼ë¬¸ì„œ')
                        .setStyle(ButtonStyle.Secondary)
                );

            const categoryButtons3 = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('inv_category_consumables')
                        .setLabel('ğŸ§ª ì†Œë¹„')
                        .setStyle(ButtonStyle.Secondary),
                    new ButtonBuilder()
                        .setCustomId('inv_category_coins')
                        .setLabel('ğŸª™ ì½”ì¸')
                        .setStyle(ButtonStyle.Secondary)
                );

            await interaction.reply({ 
                embeds: [inventoryEmbed], 
                components: [categoryButtons1, categoryButtons2, categoryButtons3],
                flags: 64 
            });
        }
        
        // ì¸ë²¤í† ë¦¬ ì¹´í…Œê³ ë¦¬ë³„ í•„í„°ë§
        else if (interaction.customId.startsWith('inv_category_')) {
            const category = interaction.customId.replace('inv_category_', '');
            
            let categoryItems = [];
            let categoryName = '';
            let categoryEmoji = '';
            let categoryGif = null;
            
            switch(category) {
                case 'weapons':
                    categoryItems = user.inventory.filter(item => item.type === 'weapon');
                    categoryName = 'ë¬´ê¸°';
                    categoryEmoji = 'âš”ï¸';
                    categoryGif = 'kim_equipment_waepon.gif';
                    break;
                case 'armor':
                    categoryItems = user.inventory.filter(item => item.type === 'armor');
                    categoryName = 'ê°‘ì˜·';
                    categoryEmoji = 'ğŸ›¡ï¸';
                    categoryGif = 'kim_equipment_robe.gif';
                    break;
                case 'helmet_gloves':
                    categoryItems = user.inventory.filter(item => item.type === 'helmet' || item.type === 'gloves');
                    categoryName = 'í—¬ë©§/ì¥ê°‘';
                    categoryEmoji = 'â›‘ï¸';
                    categoryGif = 'kim_equipment_hood.gif';
                    break;
                case 'boots':
                    categoryItems = user.inventory.filter(item => item.type === 'boots');
                    categoryName = 'ë¶€ì¸ ';
                    categoryEmoji = 'ğŸ‘¢';
                    categoryGif = 'kim_equipment_boots.gif';
                    break;
                case 'accessory':
                    categoryItems = user.inventory.filter(item => item.type === 'accessory');
                    categoryName = 'ì•¡ì„¸ì„œë¦¬';
                    categoryEmoji = 'ğŸ’';
                    categoryGif = 'kim_equipment_acce.gif';
                    break;
                case 'scrolls':
                    categoryItems = user.inventory.filter(item => item.type === 'scroll' || item.type === 'enhancement');
                    categoryName = 'ì£¼ë¬¸ì„œ';
                    categoryEmoji = 'ğŸ“œ';
                    categoryGif = 'kim_equipment_con.gif';
                    break;
                case 'consumables':
                    categoryItems = user.inventory.filter(item => item.type === 'consumable' || item.type === 'potion');
                    categoryName = 'ì†Œë¹„';
                    categoryEmoji = 'ğŸ§ª';
                    categoryGif = 'kim_equipment_examples.gif';
                    break;
                case 'coins':
                    categoryItems = user.inventory.filter(item => item.type === 'currency' || item.type === 'coin');
                    categoryName = 'ì½”ì¸';
                    categoryEmoji = 'ğŸª™';
                    categoryGif = 'kim_equipment_coin.gif';
                    break;
            }
            
            if (categoryItems.length === 0) {
                await interaction.reply({ 
                    content: `${categoryName} ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤!`, 
                    flags: 64 
                });
                return;
            }

            // í˜ì´ì§€ë„¤ì´ì…˜ ì„¤ì •
            const itemsPerPage = 3;
            const currentPage = 0;
            const totalPages = Math.ceil(categoryItems.length / itemsPerPage);
            const startIndex = currentPage * itemsPerPage;
            const currentItems = categoryItems.slice(startIndex, startIndex + itemsPerPage);

            // GIF ì²¨ë¶€ íŒŒì¼ ì¤€ë¹„
            let categoryAttachment = null;
            if (categoryGif) {
                const gifPath = path.join(__dirname, 'resource', categoryGif);
                try {
                    if (fs.existsSync(gifPath)) {
                        categoryAttachment = new AttachmentBuilder(gifPath, { name: categoryGif });
                    }
                } catch (error) {
                    console.log(`GIF íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${categoryGif}`);
                }
            }

            // ì¹´í…Œê³ ë¦¬ ì„ë² ë“œ ìƒì„±
            const categoryEmbed = new EmbedBuilder()
                .setColor('#3498db')
                .setTitle(`${categoryEmoji} ${categoryName} ì¸ë²¤í† ë¦¬`)
                .setDescription(`**${getUserTitle(user)} ${user.nickname}**ë‹˜ì˜ ${categoryName} ëª©ë¡`)
                .setFooter({ text: `í˜ì´ì§€ ${currentPage + 1}/${totalPages} | ì•„ì´í…œì„ ì„ íƒí•˜ì—¬ ì‚¬ìš©í•˜ê±°ë‚˜ ì¥ì°©í•˜ì„¸ìš”!` });
            
            if (categoryAttachment) {
                categoryEmbed.setImage(`attachment://${categoryGif}`);
            }

            // ì•„ì´í…œ ëª©ë¡ í…ìŠ¤íŠ¸ ìƒì„±
            let itemList = '';
            currentItems.forEach((item, index) => {
                const globalIndex = startIndex + index;
                
                // ë” ì•ˆì „í•œ ì¥ì°© ìƒíƒœ í™•ì¸
                let isEquipped = false;
                if (user.equipment && user.equipment[item.type]) {
                    const equippedItem = user.equipment[item.type];
                    if (typeof equippedItem === 'object' && equippedItem.id) {
                        isEquipped = (equippedItem.id === item.id);
                    }
                }
                
                const enhanceText = item.enhanceLevel > 0 ? ` (+${item.enhanceLevel}ê°•)` : '';
                
                itemList += `**${globalIndex + 1}. ${item.name}**${enhanceText} ${isEquipped ? ' -ì°©ìš©ì¤‘' : ''}\n`;
                itemList += `ë“±ê¸‰: ${item.rarity} | ìˆ˜ëŸ‰: x${item.quantity}\n`;
                
                // ì¥ë¹„ ì•„ì´í…œì¸ ê²½ìš° ìŠ¤íƒ¯ í‘œì‹œ
                if (['weapon', 'armor', 'helmet', 'gloves', 'boots', 'accessory'].includes(item.type)) {
                    let statsText = '';
                    for (const [statName, value] of Object.entries(item.stats)) {
                        if (value !== 0) {
                            const statDisplay = statName === 'attack' ? 'ê³µê²©ë ¥' : 
                                              statName === 'defense' ? 'ë°©ì–´ë ¥' : 
                                              statName === 'dodge' ? 'íšŒí”¼ë ¥' : 
                                              statName === 'luck' ? 'í–‰ìš´' : statName;
                            statsText += `${statDisplay}: ${value > 0 ? '+' : ''}${value} `;
                        }
                    }
                    itemList += `${statsText}\n`;
                }
                
                itemList += `ğŸ’° íŒë§¤ê°€: ${Math.floor(item.price * 0.7).toLocaleString()}<:currency_emoji:1377404064316522778>\n\n`;
            });

            categoryEmbed.addFields({ name: 'ë³´ìœ  ì•„ì´í…œ', value: itemList, inline: false });

            // ì•„ì´í…œ ì‚¬ìš©/ì¥ì°© ë²„íŠ¼ë“¤ (3ê°œì”©)
            const itemButtons = new ActionRowBuilder();
            currentItems.forEach((item, index) => {
                const globalIndex = startIndex + index;
                
                console.log(`ì•„ì´í…œ ${item.name} (${item.id}) - type: ${item.type}`);
                console.log(`í˜„ì¬ ì¥ì°©ëœ ${item.type}:`, user.equipment[item.type]);
                
                // ë” ì•ˆì „í•œ ì¥ì°© ìƒíƒœ í™•ì¸
                let isEquipped = false;
                if (user.equipment && user.equipment[item.type]) {
                    const equippedItem = user.equipment[item.type];
                    if (typeof equippedItem === 'object' && equippedItem.id) {
                        isEquipped = (equippedItem.id === item.id);
                    }
                }
                
                const isEquipment = ['weapon', 'armor', 'helmet', 'gloves', 'boots', 'accessory'].includes(item.type);
                
                console.log(`${item.name} - isEquipped: ${isEquipped}, equippedId: ${user.equipment[item.type]?.id || 'none'}`);
                
                itemButtons.addComponents(
                    new ButtonBuilder()
                        .setCustomId(`inv_use_${item.id}_${category}_${currentPage}`)
                        .setLabel(`${globalIndex + 1}. ${isEquipment ? 'ì¥ì°©' : 'ì‚¬ìš©'}`)
                        .setStyle(isEquipped ? ButtonStyle.Success : ButtonStyle.Primary)
                        .setDisabled(isEquipped)
                );
            });

            // í˜ì´ì§€ë„¤ì´ì…˜ ë²„íŠ¼
            const navButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId(`inv_${category}_prev_${currentPage}`)
                        .setLabel('â—€ ì´ì „')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(currentPage === 0),
                    new ButtonBuilder()
                        .setCustomId(`inv_${category}_page_${currentPage}`)
                        .setLabel(`${currentPage + 1}/${totalPages}`)
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(true),
                    new ButtonBuilder()
                        .setCustomId(`inv_${category}_next_${currentPage}`)
                        .setLabel('ë‹¤ìŒ â–¶')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(currentPage >= totalPages - 1),
                    new ButtonBuilder()
                        .setCustomId('inventory')
                        .setLabel('ğŸ”™ ì¸ë²¤í† ë¦¬ ë©”ì¸')
                        .setStyle(ButtonStyle.Primary)
                );

            const components = [itemButtons];
            if (totalPages > 1) {
                components.push(navButtons);
            } else {
                components.push(new ActionRowBuilder().addComponents(
                    new ButtonBuilder()
                        .setCustomId('inventory')
                        .setLabel('ğŸ”™ ì¸ë²¤í† ë¦¬ ë©”ì¸')
                        .setStyle(ButtonStyle.Primary)
                ));
            }

            const replyOptions = {
                embeds: [categoryEmbed],
                components: components,
                flags: 64
            };
            
            if (categoryAttachment) {
                replyOptions.files = [categoryAttachment];
            }
            
            await interaction.reply(replyOptions);
        }
        
        // ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ì‚¬ìš©/ì¥ì°© ì²˜ë¦¬
        else if (interaction.customId.startsWith('inv_use_')) {
            await interaction.deferReply({ flags: 64 });
            
            // customId íŒŒì‹±: inv_use_{itemId}_{category}_{currentPage}
            // itemIdì— _ê°€ í¬í•¨ë˜ì–´ ìˆìœ¼ë¯€ë¡œ ë§ˆì§€ë§‰ ë‘ ë¶€ë¶„ì„ ì œê±°í•˜ì—¬ itemId ì¶”ì¶œ
            const customId = interaction.customId;
            const parts = customId.split('_');
            const currentPage = parseInt(parts[parts.length - 1]); // ë§ˆì§€ë§‰ ë¶€ë¶„
            const category = parts[parts.length - 2]; // ë§ˆì§€ë§‰ì—ì„œ ë‘ ë²ˆì§¸ ë¶€ë¶„
            const itemId = parts.slice(2, parts.length - 2).join('_'); // ë‚˜ë¨¸ì§€ ë¶€ë¶„ë“¤ì„ í•©ì³ì„œ itemId
            
            // ì¸ë²¤í† ë¦¬ ë°ì´í„° ë¬´ê²°ì„± ê²€ì‚¬
            const needsFix = validateAndFixInventory(user);
            if (needsFix) {
                await user.save();
                console.log(`[ì¸ë²¤í† ë¦¬ ë³µêµ¬] ${user.nickname}ì˜ ì¸ë²¤í† ë¦¬ ë°ì´í„° ë³µêµ¬ ì™„ë£Œ`);
            }
            
            const inventoryItem = user.inventory.find(inv => inv.id === itemId);
            
            if (!inventoryItem) {
                await interaction.editReply({ content: `í•´ë‹¹ ì•„ì´í…œì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤! (ID: ${itemId})` });
                return;
            }
            
            // inventorySlotì´ ì—†ëŠ” ê²½ìš° ìë™ í• ë‹¹
            if (inventoryItem.inventorySlot === undefined || inventoryItem.inventorySlot === null) {
                const availableSlot = getAvailableInventorySlot(user);
                if (availableSlot !== -1) {
                    inventoryItem.inventorySlot = availableSlot;
                    console.log(`[ì¸ë²¤í† ë¦¬] ${inventoryItem.name}ì— ìŠ¬ë¡¯ ${availableSlot} ìë™ í• ë‹¹`);
                } else {
                    await interaction.editReply({ content: 'ì¸ë²¤í† ë¦¬ê°€ ê°€ë“ ì°¼ìŠµë‹ˆë‹¤!' });
                    return;
                }
            }
            
            // ì¥ë¹„ ì•„ì´í…œì¸ ê²½ìš° ì¥ì°© ì²˜ë¦¬
            if (['weapon', 'armor', 'helmet', 'gloves', 'boots', 'accessory'].includes(inventoryItem.type)) {
                // ì´ë¯¸ ì°©ìš© ì¤‘ì¸ì§€ í™•ì¸
                if (inventoryItem.equipped) {
                    // ì¥ì°© í•´ì œ
                    const result = unequipItem(user, inventoryItem.type);
                    await user.save();
                    
                    await interaction.editReply({ 
                        content: `ğŸš« **${inventoryItem.name}**ì„(ë¥¼) í•´ì œí–ˆìŠµë‹ˆë‹¤!` 
                    });
                    
                    // ì¸ë²¤í† ë¦¬ í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨ì„ ìœ„í•´ inventory ë²„íŠ¼ í´ë¦­ ì‹œë®¬ë ˆì´ì…˜
                    setTimeout(async () => {
                        await interaction.followUp({ 
                            content: 'ğŸ”„ ì¸ë²¤í† ë¦¬ë¥¼ ìƒˆë¡œê³ ì¹¨í•˜ë ¤ë©´ ë‹¤ì‹œ ì¸ë²¤í† ë¦¬ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.', 
                            flags: 64 
                        });
                    }, 500);
                    return;
                }

                // ì¥ì°© ì²˜ë¦¬
                const result = equipItem(user, inventoryItem.inventorySlot, inventoryItem.type);
                
                if (!result.success) {
                    await interaction.editReply({ content: `âŒ ${result.message}` });
                    return;
                }

                // ì¥ì°© ì „ ì „íˆ¬ë ¥ ê³„ì‚°
                const prevCombatPower = calculateCombatPower(user);
                await user.save();
                
                // ì¥ì°© í›„ ì „íˆ¬ë ¥ ê³„ì‚°
                const newCombatPower = calculateCombatPower(user);
                const powerChange = newCombatPower - prevCombatPower;
                const changeText = powerChange > 0 ? `(+${powerChange})` : powerChange < 0 ? `(${powerChange})` : '(ë³€í™” ì—†ìŒ)';

                const equipEmbed = new EmbedBuilder()
                    .setColor('#00ff00')
                    .setTitle('âš”ï¸ ì¥ë¹„ ì°©ìš© ì™„ë£Œ!')
                    .setDescription(`**${inventoryItem.name}**ì„(ë¥¼) ì„±ê³µì ìœ¼ë¡œ ì°©ìš©í–ˆìŠµë‹ˆë‹¤!`)
                    .addFields(
                        { name: 'ì°©ìš©í•œ ì•„ì´í…œ', value: `${inventoryItem.name}${inventoryItem.enhanceLevel > 0 ? ` (+${inventoryItem.enhanceLevel}ê°•)` : ''}`, inline: true },
                        { name: 'ì•„ì´í…œ ë“±ê¸‰', value: inventoryItem.rarity, inline: true },
                        { name: 'ë³€í™”ëœ ì „íˆ¬ë ¥', value: `${prevCombatPower.toLocaleString()} â†’ ${newCombatPower.toLocaleString()} ${changeText}`, inline: true }
                    );

                // ëŒì•„ê°€ê¸° ë²„íŠ¼ë“¤
                // categoryë¥¼ ì˜¬ë°”ë¥¸ í˜•íƒœë¡œ ë³€í™˜ (weapons â†’ weapon)
                const categoryMap = {
                    'weapons': 'weapon',
                    'armor': 'armor', 
                    'helmets': 'helmet',
                    'gloves': 'gloves',
                    'boots': 'boots',
                    'accessories': 'accessory'
                };
                const equipCategory = categoryMap[category] || inventoryItem.type;
                
                const backButtons = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId(`equip_category_${equipCategory}`)
                            .setLabel('ğŸ”™ í•´ë‹¹ ì¹´í…Œê³ ë¦¬ë¡œ ëŒì•„ê°€ê¸°')
                            .setStyle(ButtonStyle.Secondary),
                        new ButtonBuilder()
                            .setCustomId('inventory')
                            .setLabel('ğŸ  ì¸ë²¤í† ë¦¬ ë©”ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°')
                            .setStyle(ButtonStyle.Primary)
                    );

                await interaction.update({
                    embeds: [equipEmbed],
                    components: [backButtons]
                });
            } else {
                // ì†Œë¹„ ì•„ì´í…œ ì‚¬ìš©
                inventoryItem.quantity -= 1;
                if (inventoryItem.quantity <= 0) {
                    user.inventory = user.inventory.filter(inv => inv.id !== itemId);
                }
                
                await user.save();
                await interaction.reply({ 
                    content: `**${inventoryItem.name}**ì„(ë¥¼) ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤!`, 
                    flags: 64 
                });
            }
        }
        
        // ëª¨ë“  ì¥ë¹„ í•´ì œ ì²˜ë¦¬
        else if (interaction.customId === 'unequip_all') {
            await interaction.deferReply({ flags: 64 });
            
            const user = await getUser(interaction.user.id);
            if (!user) {
                return await interaction.editReply({ content: 'ìœ ì € ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!' });
            }
            
            // í˜„ì¬ ì¥ì°©ëœ ì¥ë¹„ í™•ì¸
            let unequippedCount = 0;
            const slots = ['weapon', 'armor', 'helmet', 'gloves', 'boots', 'accessory'];
            
            for (const slot of slots) {
                if (user.equipment[slot] !== -1) {
                    // ì¥ì°©ëœ ì•„ì´í…œì˜ equipped ìƒíƒœ í•´ì œ
                    const equippedItem = user.inventory.find(item => item.inventorySlot === user.equipment[slot]);
                    if (equippedItem) {
                        equippedItem.equipped = false;
                    }
                    user.equipment[slot] = -1;
                    unequippedCount++;
                }
            }
            
            if (unequippedCount === 0) {
                return await interaction.editReply({ content: 'âŒ ì¥ì°©ëœ ì¥ë¹„ê°€ ì—†ìŠµë‹ˆë‹¤!' });
            }
            
            await user.save();
            
            const unequipAllEmbed = new EmbedBuilder()
                .setColor('#ff6b6b')
                .setTitle('ğŸ”“ ëª¨ë“  ì¥ë¹„ í•´ì œ ì™„ë£Œ!')
                .setDescription(`ì´ ${unequippedCount}ê°œì˜ ì¥ë¹„ë¥¼ í•´ì œí–ˆìŠµë‹ˆë‹¤.`);
            
            return await interaction.editReply({ embeds: [unequipAllEmbed] });
        }
        
        // ì¥ë¹„ í•´ì œ ì²˜ë¦¬
        else if (interaction.customId.startsWith('unequip_')) {
            const equipSlot = interaction.customId.replace('unequip_', '');
            
            const slotIndex = user.equipment[equipSlot];
            if (slotIndex === -1 || slotIndex === null || slotIndex === undefined || typeof slotIndex === 'object') {
                await interaction.update({ content: 'í•´ì œí•  ì¥ë¹„ê°€ ì—†ìŠµë‹ˆë‹¤!', embeds: [], components: [] });
                return;
            }
            
            // í•´ì œ ì „ ì „íˆ¬ë ¥ ê³„ì‚°
            const prevCombatPower = calculateCombatPower(user);
            
            // ì¥ì°©ëœ ì•„ì´í…œì˜ equipped ìƒíƒœ í•´ì œ
            const unequippedItem = user.inventory.find(item => item.inventorySlot === slotIndex);
            if (unequippedItem) {
                unequippedItem.equipped = false;
            }
            
            // ì¥ë¹„ ìŠ¬ë¡¯ ë¹„ìš°ê¸°
            user.equipment[equipSlot] = -1;
            await user.save();
            
            // í•´ì œ í›„ ì „íˆ¬ë ¥ ê³„ì‚°
            const newCombatPower = calculateCombatPower(user);
            const powerChange = newCombatPower - prevCombatPower;
            const changeText = powerChange > 0 ? `(+${powerChange})` : powerChange < 0 ? `(${powerChange})` : '(ë³€í™” ì—†ìŒ)';
            
            const unequipEmbed = new EmbedBuilder()
                .setColor('#ff6b6b')
                .setTitle('ğŸ”“ ì¥ë¹„ í•´ì œ ì™„ë£Œ!')
                .setDescription(`**${unequippedItem.name}**ì„(ë¥¼) í•´ì œí–ˆìŠµë‹ˆë‹¤!`)
                .addFields(
                    { name: 'í•´ì œí•œ ì•„ì´í…œ', value: `${unequippedItem.name}${unequippedItem.enhanceLevel > 0 ? ` (+${unequippedItem.enhanceLevel}ê°•)` : ''}`, inline: true },
                    { name: 'ì•„ì´í…œ ë“±ê¸‰', value: unequippedItem.rarity, inline: true },
                    { name: 'ë³€í™”ëœ ì „íˆ¬ë ¥', value: `${prevCombatPower.toLocaleString()} â†’ ${newCombatPower.toLocaleString()} ${changeText}`, inline: true }
                );

            // ëŒì•„ê°€ê¸° ë²„íŠ¼ë“¤ (ì¥ë¹„ í•´ì œëŠ” ì¥ë¹„ ë©”ë‰´ì—ì„œ ì§„í–‰ë˜ë¯€ë¡œ)
            const backButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('equipment')
                        .setLabel('ğŸ”™ ì¥ë¹„ ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸°')
                        .setStyle(ButtonStyle.Secondary),
                    new ButtonBuilder()
                        .setCustomId('game_page_1')
                        .setLabel('ğŸ  ê²Œì„ ë©”ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°')
                        .setStyle(ButtonStyle.Primary)
                );

            await interaction.update({
                embeds: [unequipEmbed],
                components: [backButtons]
            });
        }
        
        // ì¸ë²¤í† ë¦¬ ì¹´í…Œê³ ë¦¬ í˜ì´ì§€ë„¤ì´ì…˜ ì²˜ë¦¬
        else if (interaction.customId.includes('inv_') && (interaction.customId.includes('_prev_') || interaction.customId.includes('_next_'))) {
            const parts = interaction.customId.split('_');
            
            if (parts[0] === 'inv' && (parts[2] === 'prev' || parts[2] === 'next')) {
                const category = parts[1];
                const direction = parts[2];
                const currentPage = parseInt(parts[3]);
                
                let newPage = currentPage;
                if (direction === 'prev' && currentPage > 0) {
                    newPage = currentPage - 1;
                } else if (direction === 'next') {
                    newPage = currentPage + 1;
                }

                // ì¹´í…Œê³ ë¦¬ë³„ ì•„ì´í…œ í•„í„°ë§
                let categoryItems = [];
                let categoryName = '';
                let categoryEmoji = '';
                
                switch(category) {
                    case 'weapons':
                        categoryItems = user.inventory.filter(item => item.type === 'weapon');
                        categoryName = 'ë¬´ê¸°';
                        categoryEmoji = 'âš”ï¸';
                        break;
                    case 'armor':
                        categoryItems = user.inventory.filter(item => item.type === 'armor');
                        categoryName = 'ê°‘ì˜·';
                        categoryEmoji = 'ğŸ›¡ï¸';
                        break;
                    case 'helmet_gloves':
                        categoryItems = user.inventory.filter(item => item.type === 'helmet' || item.type === 'gloves');
                        categoryName = 'í—¬ë©§/ì¥ê°‘';
                        categoryEmoji = 'â›‘ï¸';
                        break;
                    case 'boots':
                        categoryItems = user.inventory.filter(item => item.type === 'boots');
                        categoryName = 'ë¶€ì¸ ';
                        categoryEmoji = 'ğŸ‘¢';
                        break;
                    case 'accessory':
                        categoryItems = user.inventory.filter(item => item.type === 'accessory');
                        categoryName = 'ì•¡ì„¸ì„œë¦¬';
                        categoryEmoji = 'ğŸ’';
                        break;
                    case 'consumables':
                        categoryItems = user.inventory.filter(item => !['weapon', 'armor', 'helmet', 'gloves', 'boots', 'accessory'].includes(item.type));
                        categoryName = 'ì£¼ë¬¸ì„œ/ì†Œë¹„/ì½”ì¸';
                        categoryEmoji = 'ğŸ“œ';
                        break;
                }

                const itemsPerPage = 3;
                const totalPages = Math.ceil(categoryItems.length / itemsPerPage);
                
                if (newPage >= totalPages || newPage < 0) {
                    await interaction.reply({ content: 'ì˜ëª»ëœ í˜ì´ì§€ì…ë‹ˆë‹¤!', flags: 64 });
                    return;
                }

                const startIndex = newPage * itemsPerPage;
                const currentItems = categoryItems.slice(startIndex, startIndex + itemsPerPage);

                // ì¹´í…Œê³ ë¦¬ ì„ë² ë“œ ì—…ë°ì´íŠ¸
                const categoryEmbed = new EmbedBuilder()
                    .setColor('#3498db')
                    .setTitle(`${categoryEmoji} ${categoryName} ì¸ë²¤í† ë¦¬`)
                    .setDescription(`**${getUserTitle(user)} ${user.nickname}**ë‹˜ì˜ ${categoryName} ëª©ë¡`)
                    .setFooter({ text: `í˜ì´ì§€ ${newPage + 1}/${totalPages} | ì•„ì´í…œì„ ì„ íƒí•˜ì—¬ ì‚¬ìš©í•˜ê±°ë‚˜ ì¥ì°©í•˜ì„¸ìš”!` });

                // ì•„ì´í…œ ëª©ë¡ í…ìŠ¤íŠ¸ ìƒì„±
                let itemList = '';
                currentItems.forEach((item, index) => {
                    const globalIndex = startIndex + index;
                    const isEquipped = user.equipment[item.type] === item.inventorySlot;
                    const enhanceText = item.enhanceLevel > 0 ? ` (+${item.enhanceLevel}ê°•)` : '';
                    
                    itemList += `**${globalIndex + 1}. ${item.name}**${enhanceText} ${isEquipped ? ' -ì°©ìš©ì¤‘' : ''}\n`;
                    itemList += `ë“±ê¸‰: ${item.rarity} | ìˆ˜ëŸ‰: x${item.quantity}\n`;
                    
                    // ì¥ë¹„ ì•„ì´í…œì¸ ê²½ìš° ìŠ¤íƒ¯ í‘œì‹œ
                    if (['weapon', 'armor', 'helmet', 'gloves', 'boots', 'accessory'].includes(item.type)) {
                        let statsText = '';
                        for (const [statName, value] of Object.entries(item.stats)) {
                            if (value !== 0) {
                                const statDisplay = statName === 'attack' ? 'ê³µê²©ë ¥' : 
                                                  statName === 'defense' ? 'ë°©ì–´ë ¥' : 
                                                  statName === 'dodge' ? 'íšŒí”¼ë ¥' : 
                                                  statName === 'luck' ? 'í–‰ìš´' : statName;
                                statsText += `${statDisplay}: ${value > 0 ? '+' : ''}${value} `;
                            }
                        }
                        itemList += `${statsText}\n`;
                    }
                    
                    itemList += `ğŸ’° íŒë§¤ê°€: ${Math.floor(item.price * 0.7).toLocaleString()}<:currency_emoji:1377404064316522778>\n\n`;
                });

                categoryEmbed.addFields({ name: 'ë³´ìœ  ì•„ì´í…œ', value: itemList, inline: false });

                // ì•„ì´í…œ ì‚¬ìš©/ì¥ì°© ë²„íŠ¼ë“¤ ì—…ë°ì´íŠ¸
                const itemButtons = new ActionRowBuilder();
                currentItems.forEach((item, index) => {
                    const globalIndex = startIndex + index;
                    const isEquipped = user.equipment[item.type] === item.inventorySlot;
                    const isEquipment = ['weapon', 'armor', 'helmet', 'gloves', 'boots', 'accessory'].includes(item.type);
                    
                    itemButtons.addComponents(
                        new ButtonBuilder()
                            .setCustomId(`inv_use_${item.id}_${category}_${newPage}`)
                            .setLabel(`${globalIndex + 1}. ${isEquipment ? 'ì¥ì°©' : 'ì‚¬ìš©'}`)
                            .setStyle(isEquipped ? ButtonStyle.Success : ButtonStyle.Primary)
                            .setDisabled(isEquipped)
                    );
                });

                // í˜ì´ì§€ë„¤ì´ì…˜ ë²„íŠ¼ ì—…ë°ì´íŠ¸
                const navButtons = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId(`inv_${category}_prev_${newPage}`)
                            .setLabel('â—€ ì´ì „')
                            .setStyle(ButtonStyle.Secondary)
                            .setDisabled(newPage === 0),
                        new ButtonBuilder()
                            .setCustomId(`inv_${category}_page_${newPage}`)
                            .setLabel(`${newPage + 1}/${totalPages}`)
                            .setStyle(ButtonStyle.Secondary)
                            .setDisabled(true),
                        new ButtonBuilder()
                            .setCustomId(`inv_${category}_next_${newPage}`)
                            .setLabel('ë‹¤ìŒ â–¶')
                            .setStyle(ButtonStyle.Secondary)
                            .setDisabled(newPage >= totalPages - 1),
                        new ButtonBuilder()
                            .setCustomId('inventory')
                            .setLabel('ğŸ”™ ì¸ë²¤í† ë¦¬ ë©”ì¸')
                            .setStyle(ButtonStyle.Primary)
                    );

                const components = [itemButtons];
                if (totalPages > 1) {
                    components.push(navButtons);
                } else {
                    components.push(new ActionRowBuilder().addComponents(
                        new ButtonBuilder()
                            .setCustomId('inventory')
                            .setLabel('ğŸ”™ ì¸ë²¤í† ë¦¬ ë©”ì¸')
                            .setStyle(ButtonStyle.Primary)
                    ));
                }

                await interaction.update({
                    embeds: [categoryEmbed],
                    components: components
                });
            }
        }
        
        else if (interaction.customId.startsWith('use_')) {
            const itemId = interaction.customId.replace('use_', '');
            const inventoryItem = user.inventory.find(inv => inv.id === itemId);
            
            if (!inventoryItem) {
                await interaction.reply({ content: 'í•´ë‹¹ ì•„ì´í…œì„ ë³´ìœ í•˜ê³  ìˆì§€ ì•ŠìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            if (inventoryItem.type === 'consumable') {
                // ì†Œë¹„ ì•„ì´í…œ ì‚¬ìš©
                inventoryItem.quantity -= 1;
                if (inventoryItem.quantity <= 0) {
                    user.inventory = user.inventory.filter(inv => inv.id !== itemId);
                }
                
                await user.save();
                await interaction.reply({ 
                    content: `**${inventoryItem.name}**ì„(ë¥¼) ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤!`, 
                    flags: 64 
                });
            } else {
                // ì¥ë¹„ ì•„ì´í…œ ì¥ì°©
                await interaction.reply({ 
                    content: `ì¥ë¹„ ì‹œìŠ¤í…œì€ 5í˜ì´ì§€ì—ì„œ ì´ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!`, 
                    flags: 64 
                });
            }
        }
        
        else if (interaction.customId === 'equipment') {
            // Defer update to prevent timeout
            await interaction.deferUpdate();
            
            // ì¥ë¹„ ë©”ì¸ ì´ë¯¸ì§€ ì²¨ë¶€íŒŒì¼ ìƒì„±
            const equipmentAttachment = new AttachmentBuilder(path.join(__dirname, 'resource', 'kim_equipment.gif'), { name: 'kim_equipment.gif' });
            
            // ì „íˆ¬ë ¥ ê³„ì‚°
            const combatPower = calculateCombatPower(user);
            
            const equipmentEmbed = new EmbedBuilder()
                .setColor('#f39c12')
                .setTitle('âš”ï¸ ì¥ë¹„ ê´€ë¦¬')
                .setDescription(`**${getUserTitle(user)} ${user.nickname}**ë‹˜ì˜ í˜„ì¬ ì¥ë¹„ ìƒíƒœ\n\nğŸ”¥ **ì´ ì „íˆ¬ë ¥**: ${combatPower.toLocaleString()}`)
                .setImage('attachment://kim_equipment.gif')
                .addFields(
                    { name: 'âš”ï¸ ë¬´ê¸°', value: getEquippedItem(user, 'weapon') ? (() => {
                        const weapon = getEquippedItem(user, 'weapon');
                        const enhanceLevel = weapon.enhanceLevel || 0;
                        const baseAttack = weapon.stats?.attack || [0, 0];
                        const minAttack = Array.isArray(baseAttack) ? baseAttack[0] : baseAttack;
                        const maxAttack = Array.isArray(baseAttack) ? baseAttack[1] : baseAttack;
                        const enhanceBonus = enhanceLevel * 2; // ê°•í™”ë‹¹ +2 ê³µê²©ë ¥
                        return `${weapon.name}${enhanceLevel > 0 ? ` (+${enhanceLevel}ê°•)` : ''}\nê³µê²©ë ¥: ${minAttack + enhanceBonus}-${maxAttack + enhanceBonus}`;
                    })() : 'ë¯¸ì°©ìš©', inline: true },
                    { name: 'ğŸ›¡ï¸ ê°‘ì˜·', value: getEquippedItem(user, 'armor') ? (() => {
                        const armor = getEquippedItem(user, 'armor');
                        const enhanceLevel = armor.enhanceLevel || 0;
                        const baseDefense = armor.stats?.defense || [0, 0];
                        const minDefense = Array.isArray(baseDefense) ? baseDefense[0] : baseDefense;
                        const maxDefense = Array.isArray(baseDefense) ? baseDefense[1] : baseDefense;
                        const enhanceBonus = enhanceLevel * 2; // ê°•í™”ë‹¹ +2 ë°©ì–´ë ¥
                        return `${armor.name}${enhanceLevel > 0 ? ` (+${enhanceLevel}ê°•)` : ''}\në°©ì–´ë ¥: ${minDefense + enhanceBonus}-${maxDefense + enhanceBonus}`;
                    })() : 'ë¯¸ì°©ìš©', inline: true },
                    { name: 'â›‘ï¸ í—¬ë©§', value: getEquippedItem(user, 'helmet') ? `${getEquippedItem(user, 'helmet').name}${(getEquippedItem(user, 'helmet').enhanceLevel || 0) > 0 ? ` (+${getEquippedItem(user, 'helmet').enhanceLevel}ê°•)` : ''}` : 'ë¯¸ì°©ìš©', inline: true },
                    { name: 'ğŸ§¤ ì¥ê°‘', value: getEquippedItem(user, 'gloves') ? `${getEquippedItem(user, 'gloves').name}${(getEquippedItem(user, 'gloves').enhanceLevel || 0) > 0 ? ` (+${getEquippedItem(user, 'gloves').enhanceLevel}ê°•)` : ''}` : 'ë¯¸ì°©ìš©', inline: true },
                    { name: 'ğŸ‘¢ ë¶€ì¸ ', value: getEquippedItem(user, 'boots') ? `${getEquippedItem(user, 'boots').name}${(getEquippedItem(user, 'boots').enhanceLevel || 0) > 0 ? ` (+${getEquippedItem(user, 'boots').enhanceLevel}ê°•)` : ''}` : 'ë¯¸ì°©ìš©', inline: true },
                    { name: 'ğŸ’ ì•¡ì„¸ì„œë¦¬', value: getEquippedItem(user, 'accessory') ? `${getEquippedItem(user, 'accessory').name}${(getEquippedItem(user, 'accessory').enhanceLevel || 0) > 0 ? ` (+${getEquippedItem(user, 'accessory').enhanceLevel}ê°•)` : ''}` : 'ë¯¸ì°©ìš©', inline: true }
                );

            // ì¹´í…Œê³ ë¦¬ë³„ ì¥ë¹„ êµì²´ ë²„íŠ¼
            const categoryButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('equip_category_weapon')
                        .setLabel('âš”ï¸ ë¬´ê¸°')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('equip_category_armor')
                        .setLabel('ğŸ›¡ï¸ ê°‘ì˜·')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('equip_category_helmet')
                        .setLabel('â›‘ï¸ í—¬ë©§')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('equip_category_gloves')
                        .setLabel('ğŸ§¤ ì¥ê°‘')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('equip_category_boots')
                        .setLabel('ğŸ‘¢ ë¶€ì¸ ')
                        .setStyle(ButtonStyle.Primary)
                );

            const categoryButtons2 = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('equip_category_accessory')
                        .setLabel('ğŸ’ ì•¡ì„¸ì„œë¦¬')
                        .setStyle(ButtonStyle.Primary)
                );

            // ì¥ì°©ëœ ì•„ì´í…œ í•´ì œ ë²„íŠ¼ë“¤
            const unequipButtons = new ActionRowBuilder();
            const equipmentSlots = ['weapon', 'armor', 'helmet', 'gloves', 'boots', 'accessory'];
            const buttonLabels = ['âš”ï¸', 'ğŸ›¡ï¸', 'â›‘ï¸', 'ğŸ§¤', 'ğŸ‘¢', 'ğŸ’'];
            
            equipmentSlots.forEach((slot, index) => {
                const slotValue = user.equipment[slot];
                if (slotValue !== -1 && slotValue !== null && slotValue !== undefined && typeof slotValue === 'number') {
                    unequipButtons.addComponents(
                        new ButtonBuilder()
                            .setCustomId(`unequip_${slot}`)
                            .setLabel(`${buttonLabels[index]} í•´ì œ`)
                            .setStyle(ButtonStyle.Danger)
                    );
                }
            });

            const components = [categoryButtons, categoryButtons2];
            if (unequipButtons.components.length > 0) {
                components.push(unequipButtons);
            }

            await interaction.editReply({ 
                embeds: [equipmentEmbed], 
                components: components,
                files: [equipmentAttachment]
            });
        }
        
        // ì¥ë¹„ ì¹´í…Œê³ ë¦¬ë³„ í•„í„°ë§
        else if (interaction.customId.startsWith('equip_category_')) {
            const category = interaction.customId.replace('equip_category_', '');
            
            // í•´ë‹¹ ì¹´í…Œê³ ë¦¬ì˜ ì•„ì´í…œë§Œ í•„í„°ë§
            const categoryItems = user.inventory.filter(item => item.type === category);
            
            if (categoryItems.length === 0) {
                await interaction.reply({ 
                    content: `ì¸ë²¤í† ë¦¬ì— ${getCategoryName(category)} ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤!`, 
                    flags: 64 
                });
                return;
            }

            // í˜ì´ì§€ë„¤ì´ì…˜ ì„¤ì •
            const itemsPerPage = 3;
            const currentPage = 0;
            const totalPages = Math.ceil(categoryItems.length / itemsPerPage);
            const startIndex = currentPage * itemsPerPage;
            const currentItems = categoryItems.slice(startIndex, startIndex + itemsPerPage);

            console.log(`${category} ì¹´í…Œê³ ë¦¬ ì•„ì´í…œ í‘œì‹œ - ì´ ${categoryItems.length}ê°œ, í˜„ì¬ í˜ì´ì§€: ${currentPage + 1}`);
            console.log('í˜„ì¬ í˜ì´ì§€ ì•„ì´í…œë“¤:', currentItems.map((item, idx) => `${idx}: ${item.name} (ID: ${item.id || 'NO_ID'})`));

            // ì¹´í…Œê³ ë¦¬ ì„ë² ë“œ ìƒì„±
            const categoryEmbed = new EmbedBuilder()
                .setColor('#3498db')
                .setTitle(`${getCategoryEmoji(category)} ${getCategoryName(category)} êµì²´`)
                .setDescription(`**${getUserTitle(user)} ${user.nickname}**ë‹˜ì˜ ${getCategoryName(category)} ëª©ë¡`)
                .setFooter({ text: `í˜ì´ì§€ ${currentPage + 1}/${totalPages} | ì›í•˜ëŠ” ì•„ì´í…œì„ ì„ íƒí•˜ì—¬ ì¥ì°©í•˜ì„¸ìš”!` });

            // ì•„ì´í…œ ëª©ë¡ í…ìŠ¤íŠ¸ ìƒì„±
            let itemList = '';
            currentItems.forEach((item, index) => {
                const globalIndex = startIndex + index;
                const isEquipped = user.equipment[category] === item.inventorySlot;
                const enhanceText = item.enhanceLevel > 0 ? ` (+${item.enhanceLevel}ê°•)` : '';
                
                itemList += `**${globalIndex + 1}. ${item.name}**${enhanceText} ${isEquipped ? ' -ì°©ìš©ì¤‘' : ''}\n`;
                itemList += `ë“±ê¸‰: ${item.rarity} | ë ˆë²¨: ${item.level}\n`;
                
                // ìŠ¤íƒ¯ í‘œì‹œ
                let statsText = '';
                for (const [statName, value] of Object.entries(item.stats)) {
                    if (value !== 0) {
                        const statDisplay = statName === 'attack' ? 'ê³µê²©ë ¥' : 
                                          statName === 'defense' ? 'ë°©ì–´ë ¥' : 
                                          statName === 'dodge' ? 'íšŒí”¼ë ¥' : 
                                          statName === 'luck' ? 'í–‰ìš´' : statName;
                        statsText += `${statDisplay}: ${value > 0 ? '+' : ''}${value} `;
                    }
                }
                itemList += `${statsText}\n\n`;
            });

            categoryEmbed.addFields({ name: 'ë³´ìœ  ì•„ì´í…œ', value: itemList, inline: false });

            // ì•„ì´í…œ ì„ íƒ ë²„íŠ¼ë“¤ (3ê°œì”©)
            const itemButtons = new ActionRowBuilder();
            currentItems.forEach((item, index) => {
                const globalIndex = startIndex + index;
                const currentEquipped = user.equipment[category];
                
                // ì¥ì°© ìƒíƒœ í™•ì¸ (í˜¸í™˜ì„± ê³ ë ¤)
                let isEquipped = false;
                if (currentEquipped) {
                    if (typeof currentEquipped === 'object' && currentEquipped.id === item.id) {
                        isEquipped = true;
                    } else if (typeof currentEquipped === 'number') {
                        const itemIndex = user.inventory.findIndex(inv => inv.id === item.id);
                        isEquipped = (currentEquipped === itemIndex);
                    }
                }
                
                // ì•„ì´í…œ IDê°€ ì—†ìœ¼ë©´ ì¸ë±ìŠ¤ ì‚¬ìš©
                const itemIdentifier = item.id || (startIndex + index);
                
                console.log(`ë²„íŠ¼ ìƒì„± - ${item.name}: itemIdentifier=${itemIdentifier}, customId=equip_item_${itemIdentifier}_${category}_${currentPage}`);
                
                itemButtons.addComponents(
                    new ButtonBuilder()
                        .setCustomId(`equip_item_${itemIdentifier}_${category}_${currentPage}`)
                        .setLabel(`${globalIndex + 1}. ${item.name} ì¥ì°©`)
                        .setStyle(isEquipped ? ButtonStyle.Success : ButtonStyle.Primary)
                        .setDisabled(isEquipped)
                );
            });

            // í˜ì´ì§€ë„¤ì´ì…˜ ë²„íŠ¼
            const navButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId(`equip_${category}_prev_${currentPage}`)
                        .setLabel('â—€ ì´ì „')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(currentPage === 0),
                    new ButtonBuilder()
                        .setCustomId(`equip_${category}_page_${currentPage}`)
                        .setLabel(`${currentPage + 1}/${totalPages}`)
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(true),
                    new ButtonBuilder()
                        .setCustomId(`equip_${category}_next_${currentPage}`)
                        .setLabel('ë‹¤ìŒ â–¶')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(currentPage >= totalPages - 1),
                    new ButtonBuilder()
                        .setCustomId('equipment')
                        .setLabel('ğŸ”™ ì¥ë¹„ ë©”ì¸')
                        .setStyle(ButtonStyle.Primary)
                );

            const components = [itemButtons];
            if (totalPages > 1) {
                components.push(navButtons);
            } else {
                components.push(new ActionRowBuilder().addComponents(
                    new ButtonBuilder()
                        .setCustomId('equipment')
                        .setLabel('ğŸ”™ ì¥ë¹„ ë©”ì¸')
                        .setStyle(ButtonStyle.Primary)
                ));
            }

            await interaction.reply({
                embeds: [categoryEmbed],
                components: components,
                flags: 64
            });
        }
        
        // ì¥ë¹„ ì•„ì´í…œ ì°©ìš© ì²˜ë¦¬
        else if (interaction.customId.startsWith('equip_item_')) {
            console.log('=== ì¥ì°© í•¸ë“¤ëŸ¬ ì§„ì… ===');
            
            // ObjectId ë°ì´í„° ë¬¸ì œ í•´ê²°ì„ ìœ„í•´ user ê°ì²´ ìƒˆë¡œ ë¡œë“œ
            const freshUser = await User.findOne({ discordId: interaction.user.id });
            if (!freshUser) {
                await interaction.update({ content: 'ìœ ì € ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', embeds: [], components: [] });
                return;
            }
            
            // customId íŒŒì‹±: equip_item_{itemId}_{category}_{currentPage}
            // itemIdì— _ê°€ í¬í•¨ë˜ì–´ ìˆìœ¼ë¯€ë¡œ ë§ˆì§€ë§‰ ë‘ ë¶€ë¶„ì„ ì œê±°í•˜ì—¬ itemId ì¶”ì¶œ
            const customId = interaction.customId;
            const parts = customId.split('_');
            const currentPage = parseInt(parts[parts.length - 1]); // ë§ˆì§€ë§‰ ë¶€ë¶„
            const category = parts[parts.length - 2]; // ë§ˆì§€ë§‰ì—ì„œ ë‘ ë²ˆì§¸ ë¶€ë¶„
            const itemId = parts.slice(2, parts.length - 2).join('_'); // ë‚˜ë¨¸ì§€ ë¶€ë¶„ë“¤ì„ í•©ì³ì„œ itemId
            
            console.log(`ì¥ì°© ì‹œë„ - itemId: ${itemId}, category: ${category}`);
            console.log(`ì‚¬ìš©ì ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ìˆ˜: ${freshUser.inventory.length}`);
            
            // ì•„ì´í…œ ê²€ìƒ‰
            const inventoryItem = freshUser.inventory.find(inv => inv.id === itemId);
            
            if (!inventoryItem) {
                console.log(`ì•„ì´í…œì„ ì°¾ì„ ìˆ˜ ì—†ìŒ - ìš”ì²­ëœ ID: ${itemId}`);
                await interaction.update({ content: `í•´ë‹¹ ì•„ì´í…œì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!`, embeds: [], components: [] });
                return;
            }
            
            // inventorySlotì´ ì—†ëŠ” ê²½ìš° ìë™ í• ë‹¹
            if (inventoryItem.inventorySlot === undefined || inventoryItem.inventorySlot === null) {
                console.log(`âš ï¸ inventorySlotì´ ì—†ëŠ” ì•„ì´í…œ ë°œê²¬! ìë™ í• ë‹¹ ì¤‘...`);
                const availableSlot = getAvailableInventorySlot(freshUser);
                if (availableSlot !== -1) {
                    inventoryItem.inventorySlot = availableSlot;
                    console.log(`âœ… inventorySlot ${availableSlot}ìœ¼ë¡œ í• ë‹¹ ì™„ë£Œ`);
                } else {
                    console.log(`âŒ ì‚¬ìš© ê°€ëŠ¥í•œ ìŠ¬ë¡¯ì´ ì—†ìŒ`);
                    await interaction.update({ content: 'ì¸ë²¤í† ë¦¬ê°€ ê°€ë“ ì°¼ìŠµë‹ˆë‹¤!', embeds: [], components: [] });
                    return;
                }
            }
            
            console.log(`ğŸ“¦ ì•„ì´í…œ ì •ë³´: ${inventoryItem.name}, inventorySlot: ${inventoryItem.inventorySlot}`);
            console.log(`ğŸ“Š ì•„ì´í…œ ìŠ¤íƒ¯:`, JSON.stringify(inventoryItem.stats));
            console.log(`ğŸ”¢ ì•„ì´í…œ íƒ€ì…: ${inventoryItem.type}`);
            
            // ì´ë¯¸ ì°©ìš© ì¤‘ì¸ì§€ í™•ì¸
            if (freshUser.equipment[inventoryItem.type] === inventoryItem.inventorySlot) {
                await interaction.update({ content: 'ì´ë¯¸ ì°©ìš© ì¤‘ì¸ ì•„ì´í…œì…ë‹ˆë‹¤!', embeds: [], components: [] });
                return;
            }

            // ë ˆë²¨ í™•ì¸
            if (freshUser.level < inventoryItem.level) {
                await interaction.update({ 
                    content: `ë ˆë²¨ì´ ë¶€ì¡±í•©ë‹ˆë‹¤! (í•„ìš”: Lv.${inventoryItem.level}, í˜„ì¬: Lv.${freshUser.level})`, 
                    embeds: [], 
                    components: [] 
                });
                return;
            }

            // ì¥ì°© ê°€ëŠ¥í•œ íƒ€ì…ì¸ì§€ í™•ì¸
            if (!['weapon', 'armor', 'helmet', 'gloves', 'boots', 'accessory'].includes(inventoryItem.type)) {
                await interaction.update({ content: 'ì¥ì°©í•  ìˆ˜ ì—†ëŠ” ì•„ì´í…œì…ë‹ˆë‹¤!', embeds: [], components: [] });
                return;
            }

            // ì¥ì°© ì „ ì „íˆ¬ë ¥ ê³„ì‚°
            console.log(`ğŸ“ ì¥ì°© ì „ weapon ìŠ¬ë¡¯: ${freshUser.equipment.weapon}`);
            const prevCombatPower = calculateCombatPower(freshUser);
            console.log(`ğŸ“ ì¥ì°© ì „ ì „íˆ¬ë ¥: ${prevCombatPower}`);
            
            // ì´ì „ì— ì¥ì°©ëœ ì•„ì´í…œì´ ìˆë‹¤ë©´ í•´ì œ
            const prevSlotIndex = freshUser.equipment[inventoryItem.type];
            
            // ObjectIdì¸ ê²½ìš° ê°•ì œë¡œ -1ë¡œ ì„¤ì • (êµ¬ì‹ ë°ì´í„° ì²˜ë¦¬)
            if (prevSlotIndex && typeof prevSlotIndex === 'object') {
                console.log(`âš ï¸ êµ¬ì‹ ObjectId ë°ì´í„° ê°ì§€: ${prevSlotIndex} â†’ -1ë¡œ ë³€ê²½`);
                freshUser.equipment[inventoryItem.type] = -1;
            } else if (typeof prevSlotIndex === 'number' && prevSlotIndex !== -1) {
                // ì´ì „ ì¥ì°© ì•„ì´í…œì˜ equipped ìƒíƒœ í•´ì œ
                const prevItem = freshUser.inventory.find(item => item.inventorySlot === prevSlotIndex);
                if (prevItem) {
                    prevItem.equipped = false;
                }
            }
            
            // ì¥ì°© ì²˜ë¦¬ - ì‹ ì‹ ì‹œìŠ¤í…œ (ìŠ¬ë¡¯ ë²ˆí˜¸ ì°¸ì¡°)
            freshUser.equipment[inventoryItem.type] = inventoryItem.inventorySlot;
            
            // freshUser.inventoryì—ì„œ ë™ì¼í•œ ì•„ì´í…œì„ ì°¾ì•„ equipped ìƒíƒœ ì—…ë°ì´íŠ¸
            const freshInventoryItem = freshUser.inventory.find(item => 
                item.id === inventoryItem.id || item.inventorySlot === inventoryItem.inventorySlot
            );
            if (freshInventoryItem) {
                freshInventoryItem.equipped = true;
            }
            
            console.log(`ğŸ’¾ ì €ì¥ ì „ freshUser.equipment.weapon: ${freshUser.equipment.weapon}`);
            console.log(`ğŸ’¾ ì €ì¥ ì „ inventoryItem.inventorySlot: ${inventoryItem.inventorySlot}`);
            
            // ê°•ì œë¡œ markModified í˜¸ì¶œí•˜ì—¬ MongoDBê°€ ë³€ê²½ì‚¬í•­ì„ ì¸ì‹í•˜ë„ë¡ í•¨
            freshUser.markModified('equipment');
            freshUser.markModified('inventory');
            
            try {
                await freshUser.save();
                console.log(`ğŸ’¾ ì €ì¥ ì™„ë£Œ`);
                
                // ì €ì¥ í›„ ë‹¤ì‹œ í•œë²ˆ í™•ì¸
                const verifyUser = await User.findOne({ discordId: interaction.user.id });
                console.log(`âœ… ì €ì¥ í™•ì¸ - weapon ìŠ¬ë¡¯: ${verifyUser.equipment.weapon}`);
                console.log(`âœ… ì €ì¥ í™•ì¸ - ì¥ì°©ëœ ì•„ì´í…œ:`, verifyUser.inventory.find(item => item.inventorySlot === verifyUser.equipment[inventoryItem.type]));
            } catch (saveError) {
                console.error('âŒ ì €ì¥ ì˜¤ë¥˜:', saveError);
                await interaction.update({ content: 'ì¥ë¹„ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.', embeds: [], components: [] });
                return;
            }
            
            // ì¥ì°© í›„ ì „íˆ¬ë ¥ ê³„ì‚° (ìƒˆë¡œ ì €ì¥ëœ ë°ì´í„° ì‚¬ìš©)
            const updatedUser = await User.findOne({ discordId: interaction.user.id });
            console.log(`ğŸ“ ì¥ì°© í›„ weapon ìŠ¬ë¡¯ í™•ì¸: ${updatedUser.equipment.weapon}`);
            console.log(`ğŸ” ì¥ì°©ëœ ì•„ì´í…œ ì¬í™•ì¸:`, updatedUser.inventory.find(item => item.inventorySlot === updatedUser.equipment.weapon));
            const newCombatPower = calculateCombatPower(updatedUser);
            const powerChange = newCombatPower - prevCombatPower;
            const changeText = powerChange > 0 ? `(+${powerChange})` : powerChange < 0 ? `(${powerChange})` : '(ë³€í™” ì—†ìŒ)';

            const equipEmbed = new EmbedBuilder()
                .setColor('#00ff00')
                .setTitle('âš”ï¸ ì¥ë¹„ ì°©ìš© ì™„ë£Œ!')
                .setDescription(`**${inventoryItem.name}**ì„(ë¥¼) ì„±ê³µì ìœ¼ë¡œ ì°©ìš©í–ˆìŠµë‹ˆë‹¤!`)
                .addFields(
                    { name: 'ì°©ìš©í•œ ì•„ì´í…œ', value: `${inventoryItem.name}${inventoryItem.enhanceLevel > 0 ? ` (+${inventoryItem.enhanceLevel}ê°•)` : ''}`, inline: true },
                    { name: 'ì•„ì´í…œ ë“±ê¸‰', value: inventoryItem.rarity, inline: true },
                    { name: 'ë³€í™”ëœ ì „íˆ¬ë ¥', value: `${prevCombatPower.toLocaleString()} â†’ ${newCombatPower.toLocaleString()} ${changeText}`, inline: true }
                );

            // ëŒì•„ê°€ê¸° ë²„íŠ¼ë“¤
            // categoryë¥¼ ì˜¬ë°”ë¥¸ í˜•íƒœë¡œ ë³€í™˜ (weapons â†’ weapon)
            const categoryMap = {
                'weapons': 'weapon',
                'armor': 'armor', 
                'helmets': 'helmet',
                'gloves': 'gloves',
                'boots': 'boots',
                'accessories': 'accessory'
            };
            const equipCategory = categoryMap[category] || inventoryItem.type;
            
            const backButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId(`equip_category_${equipCategory}`)
                        .setLabel('ğŸ”™ í•´ë‹¹ ì¹´í…Œê³ ë¦¬ë¡œ ëŒì•„ê°€ê¸°')
                        .setStyle(ButtonStyle.Secondary),
                    new ButtonBuilder()
                        .setCustomId('equipment')
                        .setLabel('âš”ï¸ ì¥ë¹„ ê´€ë¦¬ë¡œ ëŒì•„ê°€ê¸°')
                        .setStyle(ButtonStyle.Primary)
                );

            await interaction.update({
                embeds: [equipEmbed],
                components: [backButtons]
            });
        }
        
        // ì¥ë¹„ ì¹´í…Œê³ ë¦¬ í˜ì´ì§€ë„¤ì´ì…˜ ì²˜ë¦¬
        else if (interaction.customId.includes('_prev_') || interaction.customId.includes('_next_')) {
            const parts = interaction.customId.split('_');
            
            if (parts[0] === 'equip' && (parts[2] === 'prev' || parts[2] === 'next')) {
                const category = parts[1];
                const direction = parts[2];
                const currentPage = parseInt(parts[3]);
                
                let newPage = currentPage;
                if (direction === 'prev' && currentPage > 0) {
                    newPage = currentPage - 1;
                } else if (direction === 'next') {
                    newPage = currentPage + 1;
                }

                // í•´ë‹¹ ì¹´í…Œê³ ë¦¬ì˜ ì•„ì´í…œë§Œ í•„í„°ë§
                const categoryItems = user.inventory.filter(item => item.type === category);
                const itemsPerPage = 3;
                const totalPages = Math.ceil(categoryItems.length / itemsPerPage);
                
                if (newPage >= totalPages || newPage < 0) {
                    await interaction.reply({ content: 'ì˜ëª»ëœ í˜ì´ì§€ì…ë‹ˆë‹¤!', flags: 64 });
                    return;
                }

                const startIndex = newPage * itemsPerPage;
                const currentItems = categoryItems.slice(startIndex, startIndex + itemsPerPage);

                // ì¹´í…Œê³ ë¦¬ ì„ë² ë“œ ì—…ë°ì´íŠ¸
                const categoryEmbed = new EmbedBuilder()
                    .setColor('#3498db')
                    .setTitle(`${getCategoryEmoji(category)} ${getCategoryName(category)} êµì²´`)
                    .setDescription(`**${getUserTitle(user)} ${user.nickname}**ë‹˜ì˜ ${getCategoryName(category)} ëª©ë¡`)
                    .setFooter({ text: `í˜ì´ì§€ ${newPage + 1}/${totalPages} | ì›í•˜ëŠ” ì•„ì´í…œì„ ì„ íƒí•˜ì—¬ ì¥ì°©í•˜ì„¸ìš”!` });

                // ì•„ì´í…œ ëª©ë¡ í…ìŠ¤íŠ¸ ìƒì„±
                let itemList = '';
                currentItems.forEach((item, index) => {
                    const globalIndex = startIndex + index;
                    const isEquipped = user.equipment[category] === item.inventorySlot;
                    const enhanceText = item.enhanceLevel > 0 ? ` (+${item.enhanceLevel}ê°•)` : '';
                    
                    itemList += `**${globalIndex + 1}. ${item.name}**${enhanceText} ${isEquipped ? ' -ì°©ìš©ì¤‘' : ''}\n`;
                    itemList += `ë“±ê¸‰: ${item.rarity} | ë ˆë²¨: ${item.level}\n`;
                    
                    // ìŠ¤íƒ¯ í‘œì‹œ
                    let statsText = '';
                    for (const [statName, value] of Object.entries(item.stats)) {
                        if (value !== 0) {
                            const statDisplay = statName === 'attack' ? 'ê³µê²©ë ¥' : 
                                              statName === 'defense' ? 'ë°©ì–´ë ¥' : 
                                              statName === 'dodge' ? 'íšŒí”¼ë ¥' : 
                                              statName === 'luck' ? 'í–‰ìš´' : statName;
                            statsText += `${statDisplay}: ${value > 0 ? '+' : ''}${value} `;
                        }
                    }
                    itemList += `${statsText}\n\n`;
                });

                categoryEmbed.addFields({ name: 'ë³´ìœ  ì•„ì´í…œ', value: itemList, inline: false });

                // ì•„ì´í…œ ì„ íƒ ë²„íŠ¼ë“¤ ì—…ë°ì´íŠ¸
                const itemButtons = new ActionRowBuilder();
                currentItems.forEach((item, index) => {
                    const globalIndex = startIndex + index;
                    const isEquipped = user.equipment[category] === item.inventorySlot;
                    
                    itemButtons.addComponents(
                        new ButtonBuilder()
                            .setCustomId(`equip_item_${item.id}_${category}_${newPage}`)
                            .setLabel(`${globalIndex + 1}. ${item.name} ì¥ì°©`)
                            .setStyle(isEquipped ? ButtonStyle.Success : ButtonStyle.Primary)
                            .setDisabled(isEquipped)
                    );
                });

                // í˜ì´ì§€ë„¤ì´ì…˜ ë²„íŠ¼ ì—…ë°ì´íŠ¸
                const navButtons = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId(`equip_${category}_prev_${newPage}`)
                            .setLabel('â—€ ì´ì „')
                            .setStyle(ButtonStyle.Secondary)
                            .setDisabled(newPage === 0),
                        new ButtonBuilder()
                            .setCustomId(`equip_${category}_page_${newPage}`)
                            .setLabel(`${newPage + 1}/${totalPages}`)
                            .setStyle(ButtonStyle.Secondary)
                            .setDisabled(true),
                        new ButtonBuilder()
                            .setCustomId(`equip_${category}_next_${newPage}`)
                            .setLabel('ë‹¤ìŒ â–¶')
                            .setStyle(ButtonStyle.Secondary)
                            .setDisabled(newPage >= totalPages - 1),
                        new ButtonBuilder()
                            .setCustomId('equipment')
                            .setLabel('ğŸ”™ ì¥ë¹„ ë©”ì¸')
                            .setStyle(ButtonStyle.Primary)
                    );

                const components = [itemButtons];
                if (totalPages > 1) {
                    components.push(navButtons);
                } else {
                    components.push(new ActionRowBuilder().addComponents(
                        new ButtonBuilder()
                            .setCustomId('equipment')
                            .setLabel('ğŸ”™ ì¥ë¹„ ë©”ì¸')
                            .setStyle(ButtonStyle.Primary)
                    ));
                }

                await interaction.update({
                    embeds: [categoryEmbed],
                    components: components
                });
            }
        }
        
        else if (interaction.customId === 'enhancement') {
            // Defer update to prevent timeout
            await interaction.deferUpdate();
            
            // ê°•í™” ë©”ë‰´ ì²˜ë¦¬
            if (user.level < 10) {
                await interaction.editReply({ content: 'ê°•í™”ëŠ” ë ˆë²¨ 10ë¶€í„° ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!', embeds: [], components: [] });
                return;
            }
            
            // ê°•í™” ê°€ëŠ¥í•œ ì¥ë¹„ í™•ì¸
            const equippedItems = [];
            const equipmentSlots = ['weapon', 'armor', 'helmet', 'gloves', 'boots', 'accessory'];
            
            equipmentSlots.forEach(slot => {
                const equippedItem = getEquippedItem(user, slot);
                if (equippedItem) {
                    equippedItems.push({
                        slot: slot,
                        item: equippedItem,
                        displayName: getSlotDisplayName(slot)
                    });
                }
            });
            
            if (equippedItems.length === 0) {
                await interaction.editReply({ 
                    content: 'ê°•í™”í•  ì¥ë¹„ê°€ ì—†ìŠµë‹ˆë‹¤! ë¨¼ì € ì¥ë¹„ë¥¼ ì°©ìš©í•´ì£¼ì„¸ìš”.', 
                    embeds: [], 
                    components: [] 
                });
                return;
            }
            
            // ê°•í™” ë©”ë‰´ ì„ë² ë“œ
            const enhanceEmbed = new EmbedBuilder()
                .setColor('#9b59b6')
                .setTitle('âš¡ ì¥ë¹„ ê°•í™”')
                .setDescription(`**${user.nickname}**ë‹˜ì˜ ê°•í™” ë©”ë‰´\n\nê°•í™”í•  ì¥ë¹„ë¥¼ ì„ íƒí•˜ì„¸ìš”!`)
                .setFooter({ text: 'ê°•í™”ëŠ” ì¥ë¹„ì˜ ì„±ëŠ¥ì„ í–¥ìƒì‹œí‚¤ì§€ë§Œ, ì‹¤íŒ¨í•  ìœ„í—˜ì´ ìˆìŠµë‹ˆë‹¤!' });
            
            // ì¥ì°©ëœ ì¥ë¹„ë“¤ í‘œì‹œ
            let equipmentList = '';
            equippedItems.forEach((equipped, index) => {
                const item = equipped.item;
                const enhanceLevel = item.enhanceLevel || 0;
                const enhanceText = enhanceLevel > 0 ? ` (+${enhanceLevel}ê°•)` : '';
                
                // ìŠ¤íƒ¯ ì •ë³´ ì¶”ê°€
                const stats = item.stats || {};
                let statsText = '';
                if (stats.attack && stats.attack[0] > 0) statsText += ` | ê³µê²©: ${stats.attack[0]}-${stats.attack[1]}`;
                if (stats.defense && stats.defense[0] > 0) statsText += ` | ë°©ì–´: ${stats.defense[0]}-${stats.defense[1]}`;
                if (stats.dodge && stats.dodge[0] > 0) statsText += ` | íšŒí”¼: ${stats.dodge[0]}-${stats.dodge[1]}`;
                if (stats.luck && stats.luck[0] > 0) statsText += ` | í–‰ìš´: ${stats.luck[0]}-${stats.luck[1]}`;
                
                equipmentList += `**${index + 1}. ${equipped.displayName}**: ${item.name}${enhanceText}${statsText}\n`;
            });
            
            enhanceEmbed.addFields({ name: 'ğŸ’ ì¥ì°©ëœ ì¥ë¹„', value: equipmentList, inline: false });
            
            // ê°•í™” ë²„íŠ¼ë“¤ (ì¥ë¹„ë³„ë¡œ)
            const enhanceButtons = new ActionRowBuilder();
            equippedItems.slice(0, 5).forEach((equipped, index) => {
                const item = equipped.item;
                const enhanceLevel = item.enhanceLevel || 0;
                const isMaxLevel = enhanceLevel >= 30;
                
                enhanceButtons.addComponents(
                    new ButtonBuilder()
                        .setCustomId(`enhance_${equipped.slot}`)
                        .setLabel(`${equipped.displayName} (+${enhanceLevel})`)
                        .setStyle(isMaxLevel ? ButtonStyle.Secondary : ButtonStyle.Primary)
                        .setDisabled(isMaxLevel)
                );
            });
            
            // ë’¤ë¡œê°€ê¸° ë²„íŠ¼
            const backButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('back_to_game_menu')
                        .setLabel('ğŸ® ê²Œì„ ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸°')
                        .setStyle(ButtonStyle.Success)
                );
            
            const components = [enhanceButtons, backButton];
            
            await interaction.editReply({ 
                embeds: [enhanceEmbed], 
                components: components
            });
        }
        
        else if (interaction.customId.startsWith('enhance_')) {
            // Defer update to prevent timeout
            await interaction.deferUpdate();
            
            // íŠ¹ì • ì¥ë¹„ ê°•í™” ì²˜ë¦¬
            const slotName = interaction.customId.replace('enhance_', '');
            const equipment = getEquippedItem(user, slotName);
            
            if (!equipment) {
                await interaction.editReply({ content: 'í•´ë‹¹ ìŠ¬ë¡¯ì— ì¥ì°©ëœ ì¥ë¹„ê°€ ì—†ìŠµë‹ˆë‹¤!', embeds: [], components: [] });
                return;
            }
            
            if (equipment.enhanceLevel >= 30) {
                await interaction.editReply({ content: 'ì´ë¯¸ ìµœëŒ€ ê°•í™” ë‹¨ê³„(30ê°•)ì…ë‹ˆë‹¤!', embeds: [], components: [] });
                return;
            }
            
            // ì•„ì´í…œ ë ˆë²¨ ë° ê°•í™” ë¹„ìš© ê³„ì‚°
            const itemLevel = ITEM_LEVELS[equipment.setName] || ITEM_LEVELS[equipment.name] || 1;
            const currentStar = equipment.enhanceLevel || 0;
            const cost = calculateEnhanceCost(itemLevel, currentStar);
            
            if (user.gold < cost) {
                await interaction.editReply({ 
                    content: `ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤! í•„ìš”: ${cost.toLocaleString()}<:currency_emoji:1377404064316522778>, ë³´ìœ : ${user.gold.toLocaleString()}<:currency_emoji:1377404064316522778>`,
                    embeds: [],
                    components: []
                });
                return;
            }
            
            // ê°•í™” í™•ë¥  ë° ì •ë³´ í‘œì‹œ
            const rates = ENHANCEMENT_RATES[currentStar];
            const successRate = rates.success;
            const failRate = rates.fail;
            const destroyRate = rates.destroy;
            
            const confirmEmbed = new EmbedBuilder()
                .setColor('#e74c3c')
                .setTitle('âš¡ ê°•í™” í™•ì¸')
                .setDescription(`**${equipment.name}** (+${currentStar}ê°• â†’ +${currentStar + 1}ê°•)\n\nì •ë§ ê°•í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)
                .addFields(
                    { name: 'ğŸ’° ê°•í™” ë¹„ìš©', value: `${cost.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true },
                    { name: 'âœ… ì„±ê³µ í™•ë¥ ', value: `${successRate}%`, inline: true },
                    { name: 'âŒ ì‹¤íŒ¨ í™•ë¥ ', value: `${failRate}%`, inline: true },
                    { name: 'ğŸ’€ íŒŒê´´ í™•ë¥ ', value: `${destroyRate}%`, inline: true },
                    { name: 'ğŸ’ í˜„ì¬ ë³´ìœ  ê³¨ë“œ', value: `${user.gold.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true }
                )
                .setFooter({ text: 'ê°•í™” í›„ì—ëŠ” ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!' });
            
            // ê°•í™” ì‹¤í–‰ ë²„íŠ¼
            const confirmButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId(`confirm_enhance_${slotName}`)
                        .setLabel('âš¡ ê°•í™” ì‹¤í–‰!')
                        .setStyle(ButtonStyle.Danger),
                    new ButtonBuilder()
                        .setCustomId('enhancement')
                        .setLabel('ğŸ”™ ëŒì•„ê°€ê¸°')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            await interaction.editReply({
                embeds: [confirmEmbed],
                components: [confirmButtons]
            });
        }
        
        else if (interaction.customId.startsWith('confirm_enhance_')) {
            // ì¦‰ì‹œ ì‘ë‹µí•˜ì—¬ ì‹œê°„ ì´ˆê³¼ ë°©ì§€
            await interaction.deferReply({ flags: 64 });
            
            // ê°•í™” ì‹¤í–‰
            const slotName = interaction.customId.replace('confirm_enhance_', '');
            const equipment = getEquippedItem(user, slotName);
            
            if (!equipment) {
                await interaction.editReply({ content: 'í•´ë‹¹ ìŠ¬ë¡¯ì— ì¥ì°©ëœ ì¥ë¹„ê°€ ì—†ìŠµë‹ˆë‹¤!', embeds: [], components: [] });
                return;
            }
            
            if (equipment.enhanceLevel >= 30) {
                await interaction.editReply({ content: 'ì´ë¯¸ ìµœëŒ€ ê°•í™” ë‹¨ê³„(30ê°•)ì…ë‹ˆë‹¤!', embeds: [], components: [] });
                return;
            }
            
            // ì•„ì´í…œ ë ˆë²¨ ë° ê°•í™” ë¹„ìš© ê³„ì‚°
            const itemLevel = ITEM_LEVELS[equipment.setName] || ITEM_LEVELS[equipment.name] || 1;
            const currentStar = equipment.enhanceLevel || 0;
            const cost = calculateEnhanceCost(itemLevel, currentStar);
            
            if (user.gold < cost) {
                await interaction.editReply({ 
                    content: `ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤! í•„ìš”: ${cost.toLocaleString()}<:currency_emoji:1377404064316522778>, ë³´ìœ : ${user.gold.toLocaleString()}<:currency_emoji:1377404064316522778>`, 
                    embeds: [], 
                    components: [] 
                });
                return;
            }
            
            // ê°•í™” ì‹œë„
            const rates = ENHANCEMENT_RATES[currentStar];
            const result = attemptEnhanceWithProtection(rates, false, false, currentStar, false);
            user.gold -= cost;
            
            // ê°•í™” í†µê³„ ì—…ë°ì´íŠ¸
            if (!user.enhanceStats) {
                user.enhanceStats = {
                    totalAttempts: 0,
                    successCount: 0,
                    destroyCount: 0,
                    totalCost: 0,
                    maxEnhanceLevel: 0
                };
            }
            
            user.enhanceStats.totalAttempts += 1;
            user.enhanceStats.totalCost += cost;
            
            // í€˜ìŠ¤íŠ¸ ì§„í–‰ë„ ì—…ë°ì´íŠ¸ (ê°•í™” ì‹œë„)
            checkQuestProgress(user, 'daily', 'enhance_attempt');
            
            let resultEmbed;
            
            if (result === 'success') {
                equipment.enhanceLevel += 1;
                user.enhanceStats.successCount += 1;
                user.enhanceStats.maxEnhanceLevel = Math.max(user.enhanceStats.maxEnhanceLevel, equipment.enhanceLevel);
                
                // í€˜ìŠ¤íŠ¸ ì§„í–‰ë„ ì—…ë°ì´íŠ¸ (ê°•í™” ì„±ê³µ)
                checkQuestProgress(user, 'weekly', 'enhance_success');
                checkQuestProgress(user, 'achievement', 'enhance_level', equipment.enhanceLevel);
                
                // ì‹ ì‹ ì‹œìŠ¤í…œ: getEquippedItemì´ ì´ë¯¸ ì¸ë²¤í† ë¦¬ì˜ ì‹¤ì œ ì•„ì´í…œì„ ì°¸ì¡°í•˜ë¯€ë¡œ ë³„ë„ ì—…ë°ì´íŠ¸ ë¶ˆí•„ìš”
                
                resultEmbed = new EmbedBuilder()
                    .setColor('#00ff00')
                    .setTitle('âœ… ê°•í™” ì„±ê³µ!')
                    .setDescription(`**${equipment.name}**ì´(ê°€) ì„±ê³µì ìœ¼ë¡œ ê°•í™”ë˜ì—ˆìŠµë‹ˆë‹¤!`)
                    .addFields(
                        { name: 'ê°•í™” ê²°ê³¼', value: `+${currentStar} â†’ **+${equipment.enhanceLevel}**ê°•`, inline: true },
                        { name: 'ì‚¬ìš©ëœ ê³¨ë“œ', value: `${cost.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true },
                        { name: 'ë‚¨ì€ ê³¨ë“œ', value: `${user.gold.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true }
                    );
                    
                if (equipment.enhanceLevel >= 10) {
                    resultEmbed.setFooter({ text: 'ë†’ì€ ê°•í™” ë‹¨ê³„ì— ë„ë‹¬í–ˆìŠµë‹ˆë‹¤! ì¶•í•˜í•©ë‹ˆë‹¤!' });
                }
                
                triggerEnhancementEvent(equipment.enhanceLevel, true);
                
            } else if (result === 'fail') {
                resultEmbed = new EmbedBuilder()
                    .setColor('#ffaa00')
                    .setTitle('âŒ ê°•í™” ì‹¤íŒ¨')
                    .setDescription(`**${equipment.name}** ê°•í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.`)
                    .addFields(
                        { name: 'ê°•í™” ê²°ê³¼', value: `+${currentStar} (ë³€í™” ì—†ìŒ)`, inline: true },
                        { name: 'ì‚¬ìš©ëœ ê³¨ë“œ', value: `${cost.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true },
                        { name: 'ë‚¨ì€ ê³¨ë“œ', value: `${user.gold.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true }
                    );
                    
                triggerEnhancementEvent(equipment.enhanceLevel, false);
                
            } else if (result === 'destroy') {
                const oldLevel = equipment.enhanceLevel;
                equipment.enhanceLevel = Math.max(0, equipment.enhanceLevel - 1);
                user.enhanceStats.destroyCount += 1;
                
                // ì‹ ì‹ ì‹œìŠ¤í…œ: getEquippedItemì´ ì´ë¯¸ ì¸ë²¤í† ë¦¬ì˜ ì‹¤ì œ ì•„ì´í…œì„ ì°¸ì¡°í•˜ë¯€ë¡œ ë³„ë„ ì—…ë°ì´íŠ¸ ë¶ˆí•„ìš”
                
                resultEmbed = new EmbedBuilder()
                    .setColor('#ff0000')
                    .setTitle('ğŸ’€ ê°•í™” íŒŒê´´!')
                    .setDescription(`**${equipment.name}**ì´(ê°€) íŒŒê´´ë˜ì–´ ê°•í™” ë‹¨ê³„ê°€ í•˜ë½í–ˆìŠµë‹ˆë‹¤!`)
                    .addFields(
                        { name: 'ê°•í™” ê²°ê³¼', value: `+${oldLevel} â†’ **+${equipment.enhanceLevel}**ğŸ’€`, inline: true },
                        { name: 'ì‚¬ìš©ëœ ê³¨ë“œ', value: `${cost.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true },
                        { name: 'ë‚¨ì€ ê³¨ë“œ', value: `${user.gold.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true }
                    )
                    .setFooter({ text: 'íŒŒê´´ëŠ” ê³ ìœ„ ê°•í™”ì—ì„œë§Œ ë°œìƒí•©ë‹ˆë‹¤. ë‹¤ìŒì—ëŠ” ë” ì‹ ì¤‘í•˜ê²Œ!' });
                    
                triggerEnhancementEvent(equipment.enhanceLevel, false);
            }
            
            // ê°•ì œë¡œ markModified í˜¸ì¶œí•˜ì—¬ MongoDBê°€ ë³€ê²½ì‚¬í•­ì„ ì¸ì‹í•˜ë„ë¡ í•¨
            user.markModified('inventory');
            user.markModified('equipment');
            user.markModified('enhanceStats');
            
            await user.save();
            
            // ê²°ê³¼ í‘œì‹œ í›„ ë‹¤ì‹œ ê°•í™”í•˜ê¸° ë²„íŠ¼ ì¶”ê°€
            const afterButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId(`enhance_${slotName}`)
                        .setLabel('ğŸ”„ ë‹¤ì‹œ ê°•í™”í•˜ê¸°')
                        .setStyle(ButtonStyle.Primary)
                        .setDisabled(equipment.enhanceLevel >= 30),
                    new ButtonBuilder()
                        .setCustomId('enhancement')
                        .setLabel('âš¡ ê°•í™” ë©”ë‰´')
                        .setStyle(ButtonStyle.Secondary),
                    new ButtonBuilder()
                        .setCustomId('back_to_game_menu')
                        .setLabel('ğŸ® ê²Œì„ ë©”ë‰´')
                        .setStyle(ButtonStyle.Success)
                );
            
            await interaction.editReply({
                embeds: [resultEmbed],
                components: [afterButtons]
            });
        }
        
        else if (interaction.customId === 'claim_quest_rewards') {
            // Defer update to prevent timeout
            await interaction.deferUpdate();
            
            // í€˜ìŠ¤íŠ¸ ë³´ìƒ ë°›ê¸°
            let totalGold = 0;
            let totalExp = 0;
            const claimedQuests = [];
            
            // ì¼ì¼ í€˜ìŠ¤íŠ¸ ë³´ìƒ
            Object.entries(user.quests.daily).forEach(([questId, progress]) => {
                if (progress.completed && !progress.claimedReward) {
                    const quest = QUEST_SYSTEM.dailyQuests[questId];
                    if (quest) {
                        totalGold += quest.rewards.gold;
                        totalExp += quest.rewards.exp;
                        progress.claimedReward = true;
                        claimedQuests.push(quest.name);
                        
                        // ì•„ì´í…œ ë³´ìƒ
                        if (quest.rewards.items && quest.rewards.items.length > 0) {
                            quest.rewards.items.forEach(item => {
                                const existingItem = user.inventory.find(i => i.name === item.name);
                                if (existingItem) {
                                    existingItem.quantity += item.quantity;
                                } else {
                                    user.inventory.push({
                                        name: item.name,
                                        quantity: item.quantity,
                                        type: 'consumable'
                                    });
                                }
                            });
                        }
                    }
                }
            });
            
            // ì£¼ê°„ í€˜ìŠ¤íŠ¸ ë³´ìƒ
            Object.entries(user.quests.weekly).forEach(([questId, progress]) => {
                if (progress.completed && !progress.claimedReward) {
                    const quest = QUEST_SYSTEM.weeklyQuests[questId];
                    if (quest) {
                        totalGold += quest.rewards.gold;
                        totalExp += quest.rewards.exp;
                        progress.claimedReward = true;
                        claimedQuests.push(quest.name);
                        
                        // ì•„ì´í…œ ë³´ìƒ
                        if (quest.rewards.items && quest.rewards.items.length > 0) {
                            quest.rewards.items.forEach(item => {
                                const existingItem = user.inventory.find(i => i.name === item.name);
                                if (existingItem) {
                                    existingItem.quantity += item.quantity;
                                } else {
                                    user.inventory.push({
                                        name: item.name,
                                        quantity: item.quantity,
                                        type: 'consumable'
                                    });
                                }
                            });
                        }
                    }
                }
            });
            
            if (claimedQuests.length === 0) {
                await interaction.editReply({ 
                    content: 'ë°›ì„ ìˆ˜ ìˆëŠ” ë³´ìƒì´ ì—†ìŠµë‹ˆë‹¤!', 
                    embeds: [], 
                    components: [] 
                });
                return;
            }
            
            // ë³´ìƒ ì§€ê¸‰
            user.gold += totalGold;
            user.exp += totalExp;
            
            // ë ˆë²¨ì—… ì²´í¬
            while (user.exp >= user.level * 100) {
                user.exp -= user.level * 100;
                user.level += 1;
                user.statPoints += 5;
                
                // ë ˆë²¨ì—… í€˜ìŠ¤íŠ¸ ì²´í¬
                checkQuestProgress(user, 'achievement', 'level_up', user.level);
            }
            
            await user.save();
            
            const rewardEmbed = new EmbedBuilder()
                .setColor('#00ff00')
                .setTitle('ğŸ í€˜ìŠ¤íŠ¸ ë³´ìƒ íšë“!')
                .setDescription(`ë‹¤ìŒ í€˜ìŠ¤íŠ¸ì˜ ë³´ìƒì„ ë°›ì•˜ìŠµë‹ˆë‹¤:\n\n${claimedQuests.map(q => `âœ… ${q}`).join('\n')}`)
                .addFields(
                    { name: 'ğŸ’° ê³¨ë“œ', value: `+${totalGold.toLocaleString()}G`, inline: true },
                    { name: 'â­ ê²½í—˜ì¹˜', value: `+${totalExp}EXP`, inline: true }
                );
            
            const backButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('quest')
                        .setLabel('ğŸ“œ í€˜ìŠ¤íŠ¸ ëª©ë¡')
                        .setStyle(ButtonStyle.Primary)
                );
            
            await interaction.editReply({
                embeds: [rewardEmbed],
                components: [backButton]
            });
        }
        
        else if (interaction.customId === 'view_achievements') {
            // Defer update to prevent timeout
            await interaction.deferUpdate();
            
            // ì—…ì  ë³´ê¸°
            const achievementEmbed = new EmbedBuilder()
                .setColor('#ffd700')
                .setTitle('ğŸ† ì—…ì ')
                .setDescription('ë‹¬ì„±í•œ ì—…ì ê³¼ ì§„í–‰ì¤‘ì¸ ì—…ì ì„ í™•ì¸í•˜ì„¸ìš”!');
            
            let achievementText = '';
            Object.values(QUEST_SYSTEM.achievements).forEach(achievement => {
                const progress = user.quests.achievements[achievement.id] || { progress: 0, completed: false, claimedReward: false };
                const icon = progress.completed ? 'ğŸ†' : 'â¬œ';
                const targetProgress = achievement.requirements.level || achievement.requirements.amount || 1;
                achievementText += `${icon} **${achievement.name}**\n${achievement.description}\n`;
                
                if (!progress.completed) {
                    achievementText += `ì§„í–‰ë„: ${progress.progress}/${targetProgress}\n`;
                }
                
                achievementText += `ë³´ìƒ: ${achievement.rewards.gold.toLocaleString()}G`;
                if (achievement.rewards.title) {
                    achievementText += `, ì¹­í˜¸: "${achievement.rewards.title}"`;
                }
                achievementText += '\n\n';
            });
            
            achievementEmbed.addFields({ name: 'ğŸ“‹ ì—…ì  ëª©ë¡', value: achievementText || 'ì—†ìŒ', inline: false });
            
            const backButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('quest')
                        .setLabel('ğŸ“œ í€˜ìŠ¤íŠ¸ ëª©ë¡')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            await interaction.editReply({
                embeds: [achievementEmbed],
                components: [backButton]
            });
        }
        
        else if (interaction.customId === 'quest_old_system_disabled') {
            // Defer update to prevent timeout
            await interaction.deferUpdate();
            
            // í€˜ìŠ¤íŠ¸ ëª©ë¡ìœ¼ë¡œ ëŒì•„ê°€ê¸°
            if (!user.quests) {
                user.quests = {
                    daily: {},
                    weekly: {},
                    achievements: {},
                    lastDailyReset: new Date().toDateString(),
                    lastWeeklyReset: new Date()
                };
            }
            
            const questEmbed = new EmbedBuilder()
                .setColor('#ff00ff')
                .setTitle('ğŸ“œ ì˜ë¢° ì‹œìŠ¤í…œ')
                .setDescription('ë‹¤ì–‘í•œ í€˜ìŠ¤íŠ¸ë¥¼ ì™„ë£Œí•˜ê³  ë³´ìƒì„ ë°›ìœ¼ì„¸ìš”!');
            
            // ì¼ì¼ í€˜ìŠ¤íŠ¸ í‘œì‹œ
            let dailyQuestText = '';
            Object.values(QUEST_SYSTEM.dailyQuests).forEach(quest => {
                const progress = user.quests.daily[quest.id] || { progress: 0, completed: false, claimedReward: false };
                const targetProgress = quest.requirements.count || quest.requirements.minutes || 1;
                const icon = progress.completed ? (progress.claimedReward ? 'âœ…' : 'ğŸŸ¡') : 'â¬œ';
                dailyQuestText += `${icon} **${quest.name}**\n${quest.description}\nì§„í–‰ë„: ${progress.progress}/${targetProgress}\në³´ìƒ: ${quest.rewards.gold.toLocaleString()}G, ${quest.rewards.exp}EXP\n\n`;
            });
            
            // ì£¼ê°„ í€˜ìŠ¤íŠ¸ í‘œì‹œ
            let weeklyQuestText = '';
            Object.values(QUEST_SYSTEM.weeklyQuests).forEach(quest => {
                const progress = user.quests.weekly[quest.id] || { progress: 0, completed: false, claimedReward: false };
                const targetProgress = quest.requirements.count || 1;
                const icon = progress.completed ? (progress.claimedReward ? 'âœ…' : 'ğŸŸ¡') : 'â¬œ';
                weeklyQuestText += `${icon} **${quest.name}**\n${quest.description}\nì§„í–‰ë„: ${progress.progress}/${targetProgress}\në³´ìƒ: ${quest.rewards.gold.toLocaleString()}G\n\n`;
            });
            
            questEmbed.addFields(
                { name: 'ğŸ“… ì¼ì¼ í€˜ìŠ¤íŠ¸', value: dailyQuestText || 'ì—†ìŒ', inline: false },
                { name: 'ğŸ“† ì£¼ê°„ í€˜ìŠ¤íŠ¸', value: weeklyQuestText || 'ì—†ìŒ', inline: false }
            );
            
            const questButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('claim_quest_rewards')
                        .setLabel('ğŸ ë³´ìƒ ë°›ê¸°')
                        .setStyle(ButtonStyle.Success)
                        .setDisabled(!Object.values(user.quests.daily).some(q => q.completed && !q.claimedReward) &&
                                   !Object.values(user.quests.weekly).some(q => q.completed && !q.claimedReward)),
                    new ButtonBuilder()
                        .setCustomId('view_achievements')
                        .setLabel('ğŸ† ì—…ì  ë³´ê¸°')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            await user.save();
            await interaction.editReply({ embeds: [questEmbed], components: [questButtons] });
        }
        
        else if (interaction.customId === 'prev_page' || interaction.customId === 'next_page') {
            // ê²Œì„ ë©”ë‰´ í˜ì´ì§€ë„¤ì´ì…˜ ì²˜ë¦¬
            const currentEmbed = interaction.message.embeds[0];
            const footerText = currentEmbed.footer?.text || '';
            const pageMatch = footerText.match(/(\d+)\/(\d+)\s*í˜ì´ì§€/);
            
            let newPage;
            
            // ì´ˆê¸° ê²Œì„ ë©”ë‰´ì—ì„œ í˜ì´ì§€ë„¤ì´ì…˜ ì‹œì‘í•˜ëŠ” ê²½ìš° ì²˜ë¦¬
            if (!pageMatch && footerText.includes('ê²Œì„ ë©”ë‰´ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤')) {
                // ì²« í˜ì´ì§€ë¡œ ê°„ì£¼
                if (interaction.customId === 'prev_page') {
                    await interaction.reply({ content: 'ì´ë¯¸ ì²« í˜ì´ì§€ì…ë‹ˆë‹¤!', flags: 64 });
                    return;
                } else if (interaction.customId === 'next_page') {
                    newPage = 2; // ë‹¤ìŒ í˜ì´ì§€ëŠ” 2í˜ì´ì§€
                }
            } else if (pageMatch) {
                // ê¸°ì¡´ í˜ì´ì§€ë„¤ì´ì…˜ ë¡œì§
                const currentPage = parseInt(pageMatch[1]);
                const totalPages = parseInt(pageMatch[2]);
                
                newPage = currentPage;
                if (interaction.customId === 'prev_page' && currentPage > 1) {
                    newPage = currentPage - 1;
                } else if (interaction.customId === 'next_page' && currentPage < totalPages) {
                    newPage = currentPage + 1;
                }
                
                if (newPage === currentPage) {
                    await interaction.reply({ content: 'ë” ì´ìƒ ì´ë™í•  í˜ì´ì§€ê°€ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
                    return;
                }
            } else {
                await interaction.reply({ content: 'í˜ì´ì§€ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            // ê¸°ì¡´ í˜ì´ì§€ êµ¬ì¡°ì™€ ë™ì¼í•˜ê²Œ ìƒì„±
            const pages = [
                {
                    buttons: [
                        new ButtonBuilder()
                            .setCustomId('daily')
                            .setLabel('ğŸ ì¶œì„ì²´í¬')
                            .setStyle(ButtonStyle.Success),
                        new ButtonBuilder()
                            .setCustomId('work')
                            .setLabel('âš’ï¸ ì¼í•˜ê¸°')
                            .setStyle(ButtonStyle.Primary),
                        new ButtonBuilder()
                            .setCustomId('quest')
                            .setLabel('ğŸ“œ ì˜ë¢°')
                            .setStyle(ButtonStyle.Primary)
                    ]
                },
                {
                    buttons: [
                        new ButtonBuilder()
                            .setCustomId('hunting')
                            .setLabel('âš”ï¸ ì‚¬ëƒ¥í•˜ê¸°')
                            .setStyle(ButtonStyle.Danger),
                        new ButtonBuilder()
                            .setCustomId('racing')
                            .setLabel('ğŸ ë ˆì´ì‹±')
                            .setStyle(ButtonStyle.Danger),
                        new ButtonBuilder()
                            .setCustomId('pvp_menu')
                            .setLabel('âš”ï¸ PvP')
                            .setStyle(ButtonStyle.Danger)
                    ]
                },
                {
                    buttons: [
                        new ButtonBuilder()
                            .setCustomId('stats')
                            .setLabel('ğŸ’ª ëŠ¥ë ¥ì¹˜')
                            .setStyle(ButtonStyle.Primary),
                        new ButtonBuilder()
                            .setCustomId('skills')
                            .setLabel('ğŸ”® ìŠ¤í‚¬')
                            .setStyle(ButtonStyle.Primary)
                    ]
                },
                {
                    buttons: [
                        new ButtonBuilder()
                            .setCustomId('shop')
                            .setLabel('ğŸ›’ ìƒì ')
                            .setStyle(ButtonStyle.Secondary),
                        new ButtonBuilder()
                            .setCustomId('inventory')
                            .setLabel('ğŸ’ ì¸ë²¤í† ë¦¬')
                            .setStyle(ButtonStyle.Secondary)
                    ]
                },
                {
                    buttons: [
                        new ButtonBuilder()
                            .setCustomId('equipment')
                            .setLabel('âš”ï¸ ì¥ë¹„')
                            .setStyle(ButtonStyle.Primary),
                        new ButtonBuilder()
                            .setCustomId('enhancement')
                            .setLabel('âš¡ ê°•í™”')
                            .setStyle(ButtonStyle.Primary)
                            .setDisabled(user.level < 10),
                        new ButtonBuilder()
                            .setCustomId('ranking')
                            .setLabel('ğŸ† ë­í‚¹')
                            .setStyle(ButtonStyle.Secondary),
                        new ButtonBuilder()
                            .setCustomId('info')
                            .setLabel('ğŸ‘¤ ë‚´ì •ë³´')
                            .setStyle(ButtonStyle.Secondary)
                    ]
                }
            ];
            
            // ì‹œê°„ëŒ€ë³„ ì´ë¯¸ì§€ ë° ìƒ‰ìƒ (ì›ë³¸ê³¼ ë™ì¼)
            const currentTime = new Date();
            const hour = currentTime.getHours();
            
            let timeImage = '';
            let timeColor = '';
            
            if (hour >= 6 && hour < 12) {
                timeImage = 'kim_main_morning.png';
                timeColor = '#ffeb3b';
            } else if (hour >= 12 && hour < 18) {
                timeImage = 'kim_main_lunch.png';
                timeColor = '#ff9800';
            } else {
                timeImage = 'kim_main_night.png';
                timeColor = '#3f51b5';
            }
            
            const greetings = [
                'ì˜¤ëŠ˜ë„ í˜ì°¨ê²Œ ëª¨í—˜ì„ ë– ë‚˜ë³¼ê¹Œìš”?',
                'ìƒˆë¡œìš´ í•˜ë£¨ê°€ ì‹œì‘ë˜ì—ˆë„¤ìš”!',
                'ëª¨í—˜ê°€ë‹˜, ì¤€ë¹„ëŠ” ë˜ì…¨ë‚˜ìš”?',
                'ì˜¤ëŠ˜ì€ ì–´ë–¤ ì¬ë¯¸ìˆëŠ” ì¼ì´ ìˆì„ê¹Œìš”?',
                'ê°•í™”ì™•ì˜ ì„¸ê³„ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!',
                'ë ˆë²¨ì—…ì„ í–¥í•´ ë‹¬ë ¤ê°€ë³¼ê¹Œìš”?',
                'ì˜¤ëŠ˜ë„ ì¢‹ì€ í•˜ë£¨ ë˜ì„¸ìš”!',
                'ëª¨í—˜ì´ ì—¬ëŸ¬ë¶„ì„ ê¸°ë‹¤ë¦¬ê³  ìˆì–´ìš”!',
                'í–‰ìš´ì´ í•¨ê»˜í•˜ê¸¸ ë°”ëë‹ˆë‹¤!',
                'ìƒˆë¡œìš´ ë„ì „ì´ ì‹œì‘ë©ë‹ˆë‹¤!'
            ];
            
            const randomGreeting = greetings[Math.floor(Math.random() * greetings.length)];
            const maxExp = user.level * 100;
            const today = new Date().toDateString();
            const attendanceStatus = user.lastDaily === today ? 'ì¶œì„' : 'ê²°ì„';
            
            // í˜„ì¬ í˜ì´ì§€ì— í•´ë‹¹í•˜ëŠ” ë²„íŠ¼ë“¤ ê°€ì ¸ì˜¤ê¸°
            const currentPageIndex = newPage - 1; // 0-based index
            const currentPageButtons = pages[currentPageIndex];
            
            if (!currentPageButtons) {
                await interaction.reply({ content: 'ì¡´ì¬í•˜ì§€ ì•ŠëŠ” í˜ì´ì§€ì…ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            // ì„ë² ë“œ ìƒì„± (ì›ë³¸ê³¼ ë™ì¼í•œ ìŠ¤íƒ€ì¼)
            const statusEmbed = new EmbedBuilder()
                .setColor(timeColor)
                .setTitle(`${getUserTitle(user)} ${user.nickname}ë‹˜, ${randomGreeting}`)
                .addFields(
                    { name: 'â­ ë ˆë²¨', value: `\`\`\`Lv.${user.level}\`\`\``, inline: true },
                    { name: 'âœ¨ ê²½í—˜ì¹˜', value: `\`\`\`${user.exp}/${maxExp}\`\`\``, inline: true },
                    { name: '<:currency_emoji:1377404064316522778> ê³¨ë“œ', value: `\`\`\`${user.gold.toLocaleString()}\`\`\``, inline: true },
                    { name: 'ğŸ“… ì¶œì„í˜„í™©', value: `\`\`\`${attendanceStatus}\`\`\``, inline: true },
                    { name: 'ğŸ† ì¢…í•©ìˆœìœ„', value: `\`\`\`ì¤€ë¹„ì¤‘\`\`\``, inline: true },
                    { name: 'ğŸ’– ì¸ê¸°ë„', value: `\`\`\`${user.popularity}\`\`\``, inline: true }
                )
                .setImage(`attachment://${timeImage}`)
                .setFooter({ text: `${newPage}/5 í˜ì´ì§€` });
                
            // ë„¤ë¹„ê²Œì´ì…˜ ë²„íŠ¼
            const navigationRow = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('prev_page')
                        .setLabel('â—€')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(newPage === 1),
                    new ButtonBuilder()
                        .setCustomId('page_info')
                        .setLabel(`${newPage}/5`)
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(true),
                    new ButtonBuilder()
                        .setCustomId('next_page')
                        .setLabel('â–¶')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(newPage === 5)
                );
                
            // ì½˜í…ì¸  ë²„íŠ¼ (í˜„ì¬ í˜ì´ì§€ì˜ ë²„íŠ¼ë“¤)
            const contentRow = new ActionRowBuilder()
                .addComponents(currentPageButtons.buttons);
            
            // ì´ë¯¸ì§€ íŒŒì¼ ì²¨ë¶€
            const imageAttachment = new AttachmentBuilder(path.join(__dirname, 'resource', timeImage), { name: timeImage });
                
            await interaction.update({ 
                embeds: [statusEmbed], 
                components: [contentRow, navigationRow],
                files: [imageAttachment]
            });
        }
        
        else if (interaction.customId.startsWith('accept_quest_')) {
            await interaction.deferUpdate();
            
            const user = await getUser(interaction.user.id);
            if (!user) {
                await interaction.editReply({ content: 'ìœ ì € ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', embeds: [], components: [] });
                return;
            }
            
            const questId = parseInt(interaction.customId.split('_')[2]);
            
            // ì˜ë¢° ì°¾ê¸°
            const allClients = [
                ...QUEST_CLIENTS.villagers,
                ...QUEST_CLIENTS.merchants,
                ...QUEST_CLIENTS.scammers,
                ...QUEST_CLIENTS.travelers
            ];
            const quest = allClients.find(q => q.id === questId);
            
            if (!quest) {
                await interaction.update({ content: 'ì˜ë¢°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', embeds: [], components: [] });
                return;
            }

            // ì¿¨íƒ€ì„ ì¶”ê°€
            addQuestCooldown(interaction.user.id);
            
            let resultEmbed;
            let embedColor;
            let resultTitle;
            let resultDescription;
            
            if (quest.type === 'scam') {
                // ì‚¬ê¸° ì˜ë¢° - ê³¨ë“œ ì°¨ê°
                if (user.gold < quest.scamAmount) {
                    resultEmbed = new EmbedBuilder()
                        .setColor('#95a5a6')
                        .setTitle('ğŸ’¸ ê³¨ë“œ ë¶€ì¡±')
                        .setDescription(`**${quest.name}**\n\n"ì•„... ê³¨ë“œê°€ ë¶€ì¡±í•˜ì‹œêµ°ìš”. ê·¸ëŸ¼ ë‹¤ìŒì— ë‹¤ì‹œ ì˜¤ì„¸ìš”!"`)
                        .addFields(
                            { name: 'ğŸ’° í˜„ì¬ ê³¨ë“œ', value: `${user.gold.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true },
                            { name: 'ğŸ’¸ í•„ìš” ê³¨ë“œ', value: `${quest.scamAmount.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true }
                        )
                        .setFooter({ text: 'ë‹¤í–‰íˆ ì‚¬ê¸°ë¥¼ ë‹¹í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤!' });
                } else {
                    user.gold -= quest.scamAmount;
                    await user.save();
                    
                    resultEmbed = new EmbedBuilder()
                        .setColor('#e74c3c')
                        .setTitle('ğŸ’¸ ì‚¬ê¸°ë‹¹í–ˆìŠµë‹ˆë‹¤!')
                        .setDescription(`**${quest.name}**\n\n"í•˜í•˜í•˜! ê³ ë§ˆì›Œìš”! ê·¸ëŸ¼ ì „ ì´ë§Œ..." *ë‹¬ì•„ë‚œë‹¤*`)
                        .addFields(
                            { name: 'ğŸ’¸ ìƒì€ ê³¨ë“œ', value: `${quest.scamAmount.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true },
                            { name: 'ğŸ’° ë‚¨ì€ ê³¨ë“œ', value: `${user.gold.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true }
                        )
                        .setFooter({ text: 'ë‹¤ìŒì—” ì¡°ì‹¬í•˜ì„¸ìš”...' });
                }
            } else {
                // ì •ìƒ ì˜ë¢° - ë³´ìƒ ì§€ê¸‰
                const reward = calculateQuestReward(user.level, quest.type);
                
                user.gold += reward.gold;
                user.exp += reward.exp;
                
                // ë ˆë²¨ì—… ì²´í¬
                let levelUpMessage = '';
                const maxExp = user.level * 100;
                if (user.exp >= maxExp) {
                    const levelsGained = Math.floor(user.exp / maxExp);
                    user.level += levelsGained;
                    user.exp = user.exp % maxExp;
                    levelUpMessage = `\nğŸ‰ **ë ˆë²¨ì—…!** Lv.${user.level - levelsGained} â†’ Lv.${user.level}`;
                }
                
                await user.save();
                
                resultEmbed = new EmbedBuilder()
                    .setColor('#2ecc71')
                    .setTitle('âœ… ì˜ë¢° ì™„ë£Œ!')
                    .setDescription(`**${quest.name}**\n\n"ì •ë§ ê³ ë§ˆì›Œìš”! ì•½ì†í•œ ë³´ìƒì„ ë“œë¦´ê²Œìš”!"${levelUpMessage}`)
                    .addFields(
                        { name: 'ğŸ’° íšë“ ê³¨ë“œ', value: `+${reward.gold.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true },
                        { name: 'âœ¨ íšë“ ê²½í—˜ì¹˜', value: `+${reward.exp} EXP`, inline: true },
                        { name: 'ğŸ’ í˜„ì¬ ê³¨ë“œ', value: `${user.gold.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true }
                    )
                    .setFooter({ text: 'ì˜ë¢° ì™„ë£Œ! 30ë¶„ í›„ì— ë‹¤ì‹œ ì´ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.' });
            }
            
            const newQuestButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('quest')
                        .setLabel('ğŸ“œ ìƒˆ ì˜ë¢° ì°¾ê¸°')
                        .setStyle(ButtonStyle.Primary)
                        .setDisabled(true) // ì¿¨íƒ€ì„ ë•Œë¬¸ì— ë¹„í™œì„±í™”
                );

            await interaction.editReply({ 
                embeds: [resultEmbed], 
                components: [newQuestButton]
            });
        }
        
        else if (interaction.customId === 'decline_quest') {
            const declineEmbed = new EmbedBuilder()
                .setColor('#95a5a6')
                .setTitle('âŒ ì˜ë¢° ê±°ì ˆ')
                .setDescription('ì˜ë¢°ë¥¼ ê±°ì ˆí–ˆìŠµë‹ˆë‹¤. ì–¸ì œë“ ì§€ ë‹¤ì‹œ ì˜ë¢°ë¥¼ ë°›ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.')
                .setFooter({ text: 'ë‹¤ë¥¸ ì˜ë¢°ë¥¼ ì°¾ì•„ë³´ì„¸ìš”!' });

            const newQuestButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('quest')
                        .setLabel('ğŸ“œ ìƒˆ ì˜ë¢° ì°¾ê¸°')
                        .setStyle(ButtonStyle.Primary)
                );

            await interaction.update({ 
                embeds: [declineEmbed], 
                components: [newQuestButton]
            });
        }
        
        else if (interaction.customId === 'game_menu_page2') {
            await interaction.deferReply({ flags: 64 });
            
            const user = await getUser(interaction.user.id);
            if (!user || !user.registered) {
                await interaction.editReply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!' });
                return;
            }
            
            const page2Embed = new EmbedBuilder()
                .setColor('#ff6b6b')
                .setTitle('ğŸ® ì¶”ê°€ ê²Œì„ ì½˜í…ì¸ ')
                .setDescription('ë” ë§ì€ ê²Œì„ì„ ì¦ê²¨ë³´ì„¸ìš”!')
                .setFooter({ text: 'ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ê²Œì„ì„ ì‹œì‘í•˜ì„¸ìš”!' });
            
            const gameRow1 = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('energy_mine')
                        .setLabel('âš¡ ì—ë„ˆì§€ ì±„êµ´')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('fusion_menu')
                        .setLabel('ğŸ”® ì¡°ê° ìœµí•©')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('oddeven_play')
                        .setLabel('ğŸ² í™€ì§ ê²Œì„')
                        .setStyle(ButtonStyle.Success)
                );
            
            const gameRow2 = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('mushroom_solo')
                        .setLabel('ğŸ„ ë…ë²„ì„¯ ê²Œì„')
                        .setStyle(ButtonStyle.Danger),
                    new ButtonBuilder()
                        .setCustomId('pvp_matchmaking')
                        .setLabel('âš”ï¸ PVP ëŒ€ì „')
                        .setStyle(ButtonStyle.Danger),
                    new ButtonBuilder()
                        .setCustomId('racing_join')
                        .setLabel('ğŸ ë ˆì´ì‹±')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            const backButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('back_to_main_from_page2')
                        .setLabel('ğŸ”™ ë©”ì¸ ë©”ë‰´ë¡œ')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            await interaction.editReply({
                embeds: [page2Embed],
                components: [gameRow1, gameRow2, backButton]
            });
        }
        
        else if (interaction.customId === 'back_to_main_from_page2') {
            await interaction.deferUpdate();
            
            // ë©”ì¸ ë©”ë‰´ ì¬ìƒì„±
            const user = await getUser(interaction.user.id);
            if (!user) {
                await interaction.editReply({ content: 'ìœ ì € ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!' });
                return;
            }
            
            const now = new Date();
            const hour = now.getHours();
            
            let timeImage = '';
            let timeColor = '';
            
            if (hour >= 6 && hour < 12) {
                timeImage = 'kim_main_morning.png';
                timeColor = '#ffeb3b';
            } else if (hour >= 12 && hour < 18) {
                timeImage = 'kim_main_lunch.png';
                timeColor = '#ff9800';
            } else {
                timeImage = 'kim_main_night.png';
                timeColor = '#3f51b5';
            }
            
            const greetings = [
                'ì˜¤ëŠ˜ë„ í˜ì°¨ê²Œ ëª¨í—˜ì„ ë– ë‚˜ë³¼ê¹Œìš”?',
                'ìƒˆë¡œìš´ í•˜ë£¨ê°€ ì‹œì‘ë˜ì—ˆë„¤ìš”!',
                'ëª¨í—˜ê°€ë‹˜, ì¤€ë¹„ëŠ” ë˜ì…¨ë‚˜ìš”?'
            ];
            
            const randomGreeting = greetings[Math.floor(Math.random() * greetings.length)];
            const maxExp = user.level * 100;
            const today = new Date().toDateString();
            const attendanceStatus = user.lastDaily === today ? 'ì¶œì„' : 'ê²°ì„';
            
            const statusEmbed = new EmbedBuilder()
                .setColor(timeColor)
                .setTitle(`${getUserTitle(user)} ${user.nickname}ë‹˜, ${randomGreeting}`)
                .addFields(
                    { name: 'â­ ë ˆë²¨', value: `\`\`\`Lv.${user.level}\`\`\``, inline: true },
                    { name: 'âœ¨ ê²½í—˜ì¹˜', value: `\`\`\`${user.exp}/${maxExp}\`\`\``, inline: true },
                    { name: '<:currency_emoji:1377404064316522778> ê³¨ë“œ', value: `\`\`\`${user.gold.toLocaleString()}\`\`\``, inline: true },
                    { name: 'ğŸ“… ì¶œì„í˜„í™©', value: `\`\`\`${attendanceStatus}\`\`\``, inline: true },
                    { name: 'ğŸ† ì¢…í•©ìˆœìœ„', value: `\`\`\`ì¤€ë¹„ì¤‘\`\`\``, inline: true },
                    { name: 'ğŸ’– ì¸ê¸°ë„', value: `\`\`\`${user.popularity}\`\`\``, inline: true }
                )
                .setImage(`attachment://${timeImage}`)
                .setFooter({ text: 'ê²Œì„ ë©”ë‰´ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!' });
            
            const mainMenu = await createCustomizedMenu(interaction.user.id);
            const menuRow = new ActionRowBuilder().addComponents(mainMenu);
            
            const gameButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('game_menu_page2')
                        .setLabel('ğŸ® ë” ë§ì€ ê²Œì„')
                        .setStyle(ButtonStyle.Primary)
                        .setEmoji('â¡ï¸')
                );
            
            const timeAttachment = new AttachmentBuilder(path.join(__dirname, 'resource', timeImage), { name: timeImage });
            
            await interaction.editReply({ 
                embeds: [statusEmbed], 
                components: [menuRow, gameButtons], 
                files: [timeAttachment]
            });
        }
        
        else if (interaction.customId === 'quest') {
            // ì¿¨íƒ€ì„ ì²´í¬
            const cooldownMinutes = checkQuestCooldown(interaction.user.id);
            if (cooldownMinutes) {
                await interaction.reply({ 
                    content: `â° ì˜ë¢° ì¿¨íƒ€ì„ì´ **${cooldownMinutes}ë¶„** ë‚¨ì•˜ìŠµë‹ˆë‹¤!`, 
                    flags: 64 
                });
                return;
            }

            // ëœë¤ ì˜ë¢° ì„ íƒ
            const quest = getRandomQuest();
            
            const questEmbed = new EmbedBuilder()
                .setColor('#f39c12')
                .setTitle(`${quest.emoji} ${quest.title}`)
                .setDescription(`**${quest.name}**\n\n"${quest.description}"`)
                .setFooter({ text: 'ì˜ë¢°ë¥¼ ìˆ˜ë½í•˜ì‹œê² ìŠµë‹ˆê¹Œ?' });

            if (quest.type === 'scam') {
                questEmbed.setColor('#e74c3c');
            }

            const questButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId(`accept_quest_${quest.id}`)
                        .setLabel('âœ… ìˆ˜ë½')
                        .setStyle(ButtonStyle.Success),
                    new ButtonBuilder()
                        .setCustomId('decline_quest')
                        .setLabel('âŒ ê±°ì ˆ')
                        .setStyle(ButtonStyle.Danger)
                );

            if (interaction.replied || interaction.deferred) {
                await interaction.editReply({ 
                    embeds: [questEmbed], 
                    components: [questButtons]
                });
            } else {
                await interaction.reply({ 
                    embeds: [questEmbed], 
                    components: [questButtons], 
                    flags: 64 
                });
            }
        }
        
        // ìˆ™ì œ(ë¯¸ì…˜) ë²„íŠ¼ í•¸ë“¤ëŸ¬
        else if (interaction.customId === 'missions') {
            await interaction.deferUpdate();
            
            const user = await getUser(interaction.user.id);
            if (!user) {
                await interaction.editReply({ content: 'ìœ ì € ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', embeds: [], components: [] });
                return;
            }
            
            // ê°„ë‹¨í•œ ì¼ì¼ ë¯¸ì…˜ ì‹œìŠ¤í…œ
            const dailyMissions = [
                { name: 'ğŸ¯ ì‚¬ëƒ¥ 10íšŒ', description: 'ëª¬ìŠ¤í„°ë¥¼ 10ë§ˆë¦¬ ì²˜ì¹˜í•˜ì„¸ìš”', reward: { gold: 5000, exp: 1000 } },
                { name: 'ğŸ’ª ìš´ë™ 30ë¶„', description: '30ë¶„ ì´ìƒ ìš´ë™í•˜ì„¸ìš”', reward: { gold: 3000, exp: 800 } },
                { name: 'ğŸ° í™€ì§ 5íšŒ', description: 'í™€ì§ ê²Œì„ì„ 5íšŒ í”Œë ˆì´í•˜ì„¸ìš”', reward: { gold: 2000, exp: 500 } },
                { name: 'âš”ï¸ ê°•í™” 3íšŒ', description: 'ì¥ë¹„ ê°•í™”ë¥¼ 3íšŒ ì‹œë„í•˜ì„¸ìš”', reward: { gold: 4000, exp: 700 } }
            ];
            
            const missionEmbed = new EmbedBuilder()
                .setColor('#4ecdc4')
                .setTitle('ğŸ“ ì¼ì¼ ìˆ™ì œ')
                .setDescription('ë§¤ì¼ ì˜¤ì „ 6ì‹œì— ì´ˆê¸°í™”ë©ë‹ˆë‹¤.')
                .setTimestamp();
            
            // ë¯¸ì…˜ ëª©ë¡ í‘œì‹œ
            dailyMissions.forEach((mission, index) => {
                missionEmbed.addFields({
                    name: mission.name,
                    value: `${mission.description}\në³´ìƒ: ${mission.reward.gold.toLocaleString()}G, ${mission.reward.exp} EXP`,
                    inline: false
                });
            });
            
            // ì£¼ê°„ ì¶œì„ ì²´í¬ í‘œì‹œ
            const weeklyAttendance = user.weeklyAttendance || [];
            const attendanceDays = ['ì¼', 'ì›”', 'í™”', 'ìˆ˜', 'ëª©', 'ê¸ˆ', 'í† '];
            let attendanceText = '';
            
            attendanceDays.forEach((day, index) => {
                attendanceText += weeklyAttendance[index] ? 'âœ… ' : 'âŒ ';
                attendanceText += `${day} `;
            });
            
            missionEmbed.addFields({
                name: 'ğŸ“… ì£¼ê°„ ì¶œì„ ì²´í¬',
                value: `${attendanceText}\nì™„ë£Œ: ${weeklyAttendance.filter(x => x).length}/7ì¼`,
                inline: false
            });
            
            if (weeklyAttendance.filter(x => x).length === 7) {
                missionEmbed.addFields({
                    name: 'ğŸ† ì£¼ê°„ ë¯¸ì…˜ ì™„ë£Œ!',
                    value: '7ì¼ ì—°ì† ì¶œì„ ë³´ìƒ: 5000G',
                    inline: false
                });
            }
            
            const backButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('back_to_game_menu')
                        .setLabel('ğŸ”™ ê²Œì„ ë©”ë‰´ë¡œ')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            await interaction.editReply({ 
                embeds: [missionEmbed], 
                components: [backButton] 
            });
        }
        
        // ì£¼ì‹ ì‹œì¥ ë²„íŠ¼ í•¸ë“¤ëŸ¬ë“¤
        else if (interaction.customId === 'stock_regions') {
            const regionSelect = new ActionRowBuilder()
                .addComponents(
                    new StringSelectMenuBuilder()
                        .setCustomId('select_region')
                        .setPlaceholder('ì§€ì—­ì„ ì„ íƒí•˜ì„¸ìš”')
                        .addOptions(
                            Object.entries(STOCK_MARKET.regions).map(([key, region]) => ({
                                label: region.name,
                                description: `${region.companies.length}ê°œ ê¸°ì—…`,
                                value: key
                            }))
                        )
                );

            const regionEmbed = new EmbedBuilder()
                .setColor('#3498db')
                .setTitle('ğŸŒ ì§€ì—­ë³„ ê¸°ì—… í˜„í™©')
                .setDescription('íˆ¬ìí•˜ê³  ì‹¶ì€ ì§€ì—­ì„ ì„ íƒí•˜ì„¸ìš”!\n\nê° ì§€ì—­ë§ˆë‹¤ ê³ ìœ í•œ íŠ¹ì„±ê³¼ ì‚°ì—…ì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤.')
                .setFooter({ text: 'ì§€ì—­ì„ ì„ íƒí•˜ë©´ í•´ë‹¹ ì§€ì—­ì˜ ê¸°ì—…ë“¤ì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.' });

            await interaction.update({
                embeds: [regionEmbed],
                components: [regionSelect]
            });
        }
        
        else if (interaction.customId === 'stock_chains') {
            const chainCompanies = STOCK_MARKET.chains;
            
            let chainText = '';
            chainCompanies.forEach((company, index) => {
                const changeIcon = company.change > 0 ? 'ğŸ“ˆ' : company.change < 0 ? 'ğŸ“‰' : 'â¡ï¸';
                const changeColor = company.change > 0 ? '+' : '';
                chainText += `${index + 1}. **${company.name}**\n`;
                chainText += `   ${company.price.toLocaleString()}<:currency_emoji:1377404064316522778> ${changeIcon} ${changeColor}${company.change.toFixed(1)}%\n`;
                chainText += `   ê±°ë˜ëŸ‰: ${company.volume.toLocaleString()}\n\n`;
            });

            const chainEmbed = new EmbedBuilder()
                .setColor('#e67e22')
                .setTitle('ğŸ¢ ì²´ì¸ ê¸°ì—… í˜„í™©')
                .setDescription('ì „ ì§€ì—­ì—ì„œ ì„œë¹„ìŠ¤í•˜ëŠ” ëŒ€í˜• ì²´ì¸ ê¸°ì—…ë“¤ì…ë‹ˆë‹¤.\n\n' + chainText)
                .setFooter({ text: 'ì²´ì¸ ê¸°ì—…ì„ í´ë¦­í•˜ì—¬ ë§¤ìˆ˜/ë§¤ë„í•˜ì„¸ìš”!' });

            // ì²´ì¸ ê¸°ì—… ë§¤ìˆ˜/ë§¤ë„ ë²„íŠ¼ë“¤
            const chainButtons = new ActionRowBuilder();
            chainCompanies.slice(0, 5).forEach(company => {
                chainButtons.addComponents(
                    new ButtonBuilder()
                        .setCustomId(`trade_${company.id}`)
                        .setLabel(company.name)
                        .setStyle(ButtonStyle.Secondary)
                );
            });

            await interaction.update({
                embeds: [chainEmbed],
                components: [chainButtons]
            });
        }
        
        // PVP ë§¤ì¹˜ë©”ì´í‚¹ ë²„íŠ¼ ì²˜ë¦¬
        else if (interaction.customId === 'pvp_matchmaking') {
            await interaction.deferReply();
            
            const user = await getUser(interaction.user.id);
            if (!user) {
                await interaction.editReply({ content: 'ìœ ì € ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!' });
                return;
            }
            
            // ë§¤ì¹˜ë©”ì´í‚¹ í ì°¸ê°€
            const result = await pvpSystem.joinQueue(interaction.user.id, user, interaction.channel);
            
            if (result.success) {
                const queueEmbed = new EmbedBuilder()
                    .setColor('#00ff00')
                    .setTitle('ğŸ¯ ë§¤ì¹˜ë©”ì´í‚¹ ì‹œì‘!')
                    .setDescription(result.message)
                    .addFields(
                        { name: 'ğŸ« ë‚¨ì€ ê²°íˆ¬ê¶Œ', value: `${result.tickets}ê°œ`, inline: true },
                        { name: 'â±ï¸ ë§¤ì¹­ ì‹œì‘', value: 'ì´ˆê¸° ë²”ìœ„: Â±200ì ', inline: true }
                    )
                    .setFooter({ text: '60ì´ˆ í›„ ë„ ë§¤ì¹­ì´ ì•ˆë˜ë©´ ë´‡ê³¼ ëŒ€ì „í•©ë‹ˆë‹¤!' });
                
                const cancelButton = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('cancel_pvp_queue')
                            .setLabel('âŒ ë§¤ì¹­ ì·¨ì†Œ')
                            .setStyle(ButtonStyle.Danger)
                    );
                
                await interaction.editReply({ embeds: [queueEmbed], components: [cancelButton] });
            } else {
                await interaction.editReply({ content: `âŒ ${result.message}` });
            }
        }
        
        // PVP ë§¤ì¹­ ì·¨ì†Œ
        else if (interaction.customId === 'cancel_pvp_queue') {
            const result = pvpSystem.leaveQueue(interaction.user.id);
            
            if (result.success) {
                const cancelEmbed = new EmbedBuilder()
                    .setColor('#ff0000')
                    .setTitle('âŒ ë§¤ì¹­ ì·¨ì†Œ')
                    .setDescription(result.message);
                    
                await interaction.update({ embeds: [cancelEmbed], components: [] });
            } else {
                await interaction.reply({ content: result.message, flags: 64 });
            }
        }
        
        // PVP ë­í‚¹
        else if (interaction.customId === 'pvp_ranking') {
            await interaction.deferReply();
            
            try {
                const topUsers = await User.find({ 'pvp.totalDuels': { $gt: 0 } })
                    .sort({ 'pvp.rating': -1 })
                    .limit(10);
                
                if (topUsers.length === 0) {
                    await interaction.editReply({ content: 'ğŸ† ì•„ì§ PVP ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤!' });
                    return;
                }
                
                let rankingText = '';
                topUsers.forEach((user, index) => {
                    const medal = index === 0 ? 'ğŸ¥‡' : index === 1 ? 'ğŸ¥ˆ' : index === 2 ? 'ğŸ¥‰' : `${index + 1}ìœ„`;
                    const tierEmoji = pvpSystem.getTierEmoji ? pvpSystem.getTierEmoji(user.pvp.tier) : '';
                    rankingText += `${medal} **${user.nickname}** ${tierEmoji}\n`;
                    rankingText += `   ë ˆì´íŒ…: ${user.pvp.rating} | ìŠ¹ë¥ : ${((user.pvp.wins / user.pvp.totalDuels) * 100).toFixed(1)}%\n\n`;
                });
                
                const rankingEmbed = new EmbedBuilder()
                    .setColor('#FFD700')
                    .setTitle('ğŸ† PVP ë­í‚¹ TOP 10')
                    .setDescription(rankingText)
                    .setFooter({ text: 'ë§¤ì‹œê°„ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤!' });
                
                await interaction.editReply({ embeds: [rankingEmbed] });
            } catch (error) {
                console.error('PVP ë­í‚¹ ì¡°íšŒ ì˜¤ë¥˜:', error);
                await interaction.editReply({ content: 'âŒ ë­í‚¹ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤!' });
            }
        }
        
        // PVP íœë“¤ëŸ¼ ë°°í‹€ ë²„íŠ¼ ì²˜ë¦¬
        else if (interaction.customId.startsWith('pvp_pendulum_')) {
            const parts = interaction.customId.split('_');
            const matchId = parts[2];
            const position = parts[3]; // high, middle, low
            
            await pvpSystem.handlePendulumChoice(interaction, matchId, position);
        }
        
        // PVP ì •ë³´
        else if (interaction.customId === 'pvp_info') {
            const user = await getUser(interaction.user.id);
            if (!user) {
                await interaction.reply({ content: 'ìœ ì € ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            const pvpInfo = await pvpSystem.getPVPInfo(user);
            
            const infoEmbed = new EmbedBuilder()
                .setColor('#3498db')
                .setTitle('ğŸ® ë‚´ PVP ì •ë³´')
                .setDescription(`**${user.nickname}**ë‹˜ì˜ PVP í†µê³„`)
                .addFields(
                    { name: 'ğŸ–ï¸ í‹°ì–´', value: `${pvpInfo.tierEmoji} ${pvpInfo.tier}`, inline: true },
                    { name: 'ğŸ“ˆ ë ˆì´íŒ…', value: `${pvpInfo.rating}ì `, inline: true },
                    { name: 'ğŸ« ê²°íˆ¬ê¶Œ', value: `${pvpInfo.duelTickets}ê°œ`, inline: true },
                    { name: 'âš”ï¸ ì´ ì „íˆ¬', value: `${pvpInfo.totalDuels}íšŒ`, inline: true },
                    { name: 'ğŸ† ì „ì ', value: `${pvpInfo.wins}ìŠ¹ ${pvpInfo.losses}íŒ¨`, inline: true },
                    { name: 'ğŸ“ˆ ìŠ¹ë¥ ', value: `${pvpInfo.winRate}%`, inline: true },
                    { name: 'ğŸ”¥ ì—°ìŠ¹', value: `${pvpInfo.winStreak}íšŒ`, inline: true },
                    { name: 'ğŸŒŸ ìµœê³  ì—°ìŠ¹', value: `${pvpInfo.maxWinStreak}íšŒ`, inline: true },
                    { name: 'ğŸ‘‘ ìµœê³  ë ˆì´íŒ…', value: `${pvpInfo.highestRating}ì `, inline: true }
                );
            
            // ìµœê·¼ ë§¤ì¹˜ ê¸°ë¡
            if (pvpInfo.matchHistory.length > 0) {
                let historyText = '';
                pvpInfo.matchHistory.slice(0, 5).forEach(match => {
                    const resultEmoji = match.result === 'win' ? 'ğŸŸ¢' : 'ğŸ”´';
                    const ratingChangeText = match.ratingChange > 0 ? `+${match.ratingChange}` : `${match.ratingChange}`;
                    historyText += `${resultEmoji} vs **${match.opponent}** (${ratingChangeText})\n`;
                });
                infoEmbed.addFields({ name: 'ğŸ“Š ìµœê·¼ 5ê²½ê¸°', value: historyText, inline: false });
            }
            
            await interaction.reply({ embeds: [infoEmbed], flags: 64 });
        }
        
        // PVP ê³µê²© ê°•í™”
        else if (interaction.customId === 'pvp_enhance') {
            const user = await getUser(interaction.user.id);
            if (!user) {
                await interaction.reply({ content: 'ìœ ì € ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            const enhanceLevels = user.pvp?.attackEnhancement || { high: 0, middle: 0, low: 0 };
            
            // ê°•í™” ë¹„ìš© ê³„ì‚° (ë ˆë²¨ì´ ë†’ì•„ì§ˆìˆ˜ë¡ ë¹„ìš© ì¦ê°€)
            const getEnhanceCost = (level) => {
                if (level < 10) return 1000 * (level + 1);
                else if (level < 20) return 5000 * (level - 9) + 10000;
                else return 10000 * (level - 19) + 60000;
            };
            
            // ê°•í™” í™•ë¥  ê³„ì‚° (ì¥ë¹„ ê°•í™”ì™€ ë™ì¼)
            const getSuccessRate = (level) => {
                if (level < 10) return 90 - level * 5;
                else if (level < 15) return 50 - (level - 10) * 5;
                else if (level < 20) return 30 - (level - 15) * 2;
                else if (level < 25) return 20 - (level - 20);
                else return 15 - (level - 25);
            };
            
            const enhanceEmbed = new EmbedBuilder()
                .setColor('#ff69b4')
                .setTitle('ğŸ’ PVP ê³µê²© ê°•í™”')
                .setDescription('ê³µê²© ìŠ¤í‚¬ì„ ê°•í™”í•˜ì—¬ ë” ê°•ë ¥í•œ ë°ë¯¸ì§€ë¥¼ ì…íˆì„¸ìš”!\nê°•í™” ì‹œ **ë°ë¯¸ì§€ +1**ì”© ì¦ê°€í•©ë‹ˆë‹¤.')
                .addFields(
                    { 
                        name: 'ğŸŒŸ ë³„ë˜¥ë² ê¸° (ìƒë‹¨)', 
                        value: `ë ˆë²¨: **+${enhanceLevels.high}**\nì„±ê³µë¥ : ${getSuccessRate(enhanceLevels.high)}%\në¹„ìš©: ${getEnhanceCost(enhanceLevels.high).toLocaleString()}G`, 
                        inline: true 
                    },
                    { 
                        name: 'ğŸ¬ ìŠˆê°€ìŠ¤íŒ… (ì¤‘ë‹¨)', 
                        value: `ë ˆë²¨: **+${enhanceLevels.middle}**\nì„±ê³µë¥ : ${getSuccessRate(enhanceLevels.middle)}%\në¹„ìš©: ${getEnhanceCost(enhanceLevels.middle).toLocaleString()}G`, 
                        inline: true 
                    },
                    { 
                        name: 'ğŸ„ ë²„ì„¯íŒ¡ (í•˜ë‹¨)', 
                        value: `ë ˆë²¨: **+${enhanceLevels.low}**\nì„±ê³µë¥ : ${getSuccessRate(enhanceLevels.low)}%\në¹„ìš©: ${getEnhanceCost(enhanceLevels.low).toLocaleString()}G`, 
                        inline: true 
                    },
                    { name: 'ğŸ’° ë³´ìœ  ê³¨ë“œ', value: `${user.gold.toLocaleString()}G`, inline: true },
                    { name: 'ğŸ“Š ê°•í™” í†µê³„', value: `ì‹œë„: ${user.pvp?.pvpEnhanceHistory?.totalAttempts || 0}íšŒ\níŒŒê´´: ${user.pvp?.pvpEnhanceHistory?.destroyCount || 0}íšŒ`, inline: true }
                )
                .setFooter({ text: 'âš ï¸ ì‹¤íŒ¨ ì‹œ ê°•í™” ë ˆë²¨ì´ í•˜ë½í•˜ê±°ë‚˜ 0ìœ¼ë¡œ ì´ˆê¸°í™”ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤!' });
            
            const enhanceButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('pvp_enhance_high')
                        .setLabel('ğŸŒŸ ë³„ë˜¥ë² ê¸° ê°•í™”')
                        .setStyle(ButtonStyle.Primary)
                        .setDisabled(user.gold < getEnhanceCost(enhanceLevels.high)),
                    new ButtonBuilder()
                        .setCustomId('pvp_enhance_middle')
                        .setLabel('ğŸ¬ ìŠˆê°€ìŠ¤íŒ… ê°•í™”')
                        .setStyle(ButtonStyle.Primary)
                        .setDisabled(user.gold < getEnhanceCost(enhanceLevels.middle)),
                    new ButtonBuilder()
                        .setCustomId('pvp_enhance_low')
                        .setLabel('ğŸ„ ë²„ì„¯íŒ¡ ê°•í™”')
                        .setStyle(ButtonStyle.Primary)
                        .setDisabled(user.gold < getEnhanceCost(enhanceLevels.low))
                );
            
            const backButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('back_to_pvp')
                        .setLabel('ğŸ”™ PVP ë©”ë‰´')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            await interaction.reply({ 
                embeds: [enhanceEmbed], 
                components: [enhanceButtons, backButton],
                flags: 64 
            });
        }
        
        // PVP ê³µê²© ê°•í™” ì‹¤í–‰
        else if (interaction.customId.startsWith('pvp_enhance_')) {
            const user = await getUser(interaction.user.id);
            if (!user) {
                await interaction.reply({ content: 'ìœ ì € ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            const position = interaction.customId.replace('pvp_enhance_', '');
            const currentLevel = user.pvp?.attackEnhancement?.[position] || 0;
            
            if (currentLevel >= 30) {
                await interaction.reply({ content: 'ì´ë¯¸ ìµœëŒ€ ê°•í™” ë ˆë²¨(30ê°•)ì…ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            // ê°•í™” ë¹„ìš© ê³„ì‚°
            const getEnhanceCost = (level) => {
                if (level < 10) return 1000 * (level + 1);
                else if (level < 20) return 5000 * (level - 9) + 10000;
                else return 10000 * (level - 19) + 60000;
            };
            
            const cost = getEnhanceCost(currentLevel);
            
            if (user.gold < cost) {
                await interaction.reply({ content: 'ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            // ê°•í™” í™•ë¥  ê³„ì‚°
            const getSuccessRate = (level) => {
                if (level < 10) return 90 - level * 5;
                else if (level < 15) return 50 - (level - 10) * 5;
                else if (level < 20) return 30 - (level - 15) * 2;
                else if (level < 25) return 20 - (level - 20);
                else return 15 - (level - 25);
            };
            
            const successRate = getSuccessRate(currentLevel);
            const isSuccess = Math.random() * 100 < successRate;
            
            // ê³¨ë“œ ì°¨ê°
            user.gold -= cost;
            
            // pvp ê°ì²´ ì´ˆê¸°í™”
            if (!user.pvp) user.pvp = {};
            if (!user.pvp.attackEnhancement) user.pvp.attackEnhancement = { high: 0, middle: 0, low: 0 };
            if (!user.pvp.pvpEnhanceHistory) user.pvp.pvpEnhanceHistory = { totalAttempts: 0, totalGoldUsed: 0, destroyCount: 0, maxLevel: 0 };
            
            // í†µê³„ ì—…ë°ì´íŠ¸
            user.pvp.pvpEnhanceHistory.totalAttempts++;
            user.pvp.pvpEnhanceHistory.totalGoldUsed += cost;
            
            const attackNames = {
                'high': 'ğŸŒŸ ë³„ë˜¥ë² ê¸°',
                'middle': 'ğŸ¬ ìŠˆê°€ìŠ¤íŒ…',
                'low': 'ğŸ„ ë²„ì„¯íŒ¡'
            };
            
            let resultEmbed;
            
            if (isSuccess) {
                // ê°•í™” ì„±ê³µ
                user.pvp.attackEnhancement[position]++;
                if (user.pvp.attackEnhancement[position] > user.pvp.pvpEnhanceHistory.maxLevel) {
                    user.pvp.pvpEnhanceHistory.maxLevel = user.pvp.attackEnhancement[position];
                }
                
                resultEmbed = new EmbedBuilder()
                    .setColor('#00ff00')
                    .setTitle('âœ¨ ê°•í™” ì„±ê³µ!')
                    .setDescription(`${attackNames[position]} ê°•í™”ì— ì„±ê³µí–ˆìŠµë‹ˆë‹¤!`)
                    .addFields(
                        { name: 'ê°•í™” ê²°ê³¼', value: `+${currentLevel} â†’ **+${user.pvp.attackEnhancement[position]}**`, inline: true },
                        { name: 'ì‚¬ìš© ê³¨ë“œ', value: `${cost.toLocaleString()}G`, inline: true },
                        { name: 'ë‚¨ì€ ê³¨ë“œ', value: `${user.gold.toLocaleString()}G`, inline: true }
                    );
            } else {
                // ê°•í™” ì‹¤íŒ¨
                if (currentLevel >= 15 && Math.random() < 0.3) {
                    // íŒŒê´´ (30% í™•ë¥ )
                    user.pvp.attackEnhancement[position] = 0;
                    user.pvp.pvpEnhanceHistory.destroyCount++;
                    
                    resultEmbed = new EmbedBuilder()
                        .setColor('#ff0000')
                        .setTitle('ğŸ’¥ ê°•í™” íŒŒê´´!')
                        .setDescription(`${attackNames[position]} ê°•í™”ê°€ íŒŒê´´ë˜ì–´ 0ê°•ìœ¼ë¡œ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤!`)
                        .addFields(
                            { name: 'ê°•í™” ê²°ê³¼', value: `+${currentLevel} â†’ **+0** ğŸ’€`, inline: true },
                            { name: 'ì‚¬ìš© ê³¨ë“œ', value: `${cost.toLocaleString()}G`, inline: true },
                            { name: 'ë‚¨ì€ ê³¨ë“œ', value: `${user.gold.toLocaleString()}G`, inline: true }
                        );
                } else {
                    // í•˜ë½
                    const dropLevel = Math.floor(Math.random() * 3) + 1; // 1~3 í•˜ë½
                    user.pvp.attackEnhancement[position] = Math.max(0, currentLevel - dropLevel);
                    
                    resultEmbed = new EmbedBuilder()
                        .setColor('#ff6600')
                        .setTitle('ğŸ“‰ ê°•í™” ì‹¤íŒ¨!')
                        .setDescription(`${attackNames[position]} ê°•í™”ê°€ ì‹¤íŒ¨í•˜ì—¬ ë ˆë²¨ì´ í•˜ë½í–ˆìŠµë‹ˆë‹¤!`)
                        .addFields(
                            { name: 'ê°•í™” ê²°ê³¼', value: `+${currentLevel} â†’ **+${user.pvp.attackEnhancement[position]}** (-${dropLevel})`, inline: true },
                            { name: 'ì‚¬ìš© ê³¨ë“œ', value: `${cost.toLocaleString()}G`, inline: true },
                            { name: 'ë‚¨ì€ ê³¨ë“œ', value: `${user.gold.toLocaleString()}G`, inline: true }
                        );
                }
            }
            
            // PVP ê°•í™” ë°ì´í„° ë³€ê²½ ì‚¬í•­ì„ MongoDBê°€ ì¸ì‹í•˜ë„ë¡ markModified í˜¸ì¶œ
            user.markModified('pvp');
            user.markModified('pvp.attackEnhancement');
            user.markModified('pvp.pvpEnhanceHistory');
            
            await user.save();
            
            await interaction.reply({ embeds: [resultEmbed], flags: 64 });
            
            // 3ì´ˆ í›„ ê°•í™” ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸°
            setTimeout(async () => {
                const enhanceLevels = user.pvp.attackEnhancement;
                
                const enhanceEmbed = new EmbedBuilder()
                    .setColor('#ff69b4')
                    .setTitle('ğŸ’ PVP ê³µê²© ê°•í™”')
                    .setDescription('ê³µê²© ìŠ¤í‚¬ì„ ê°•í™”í•˜ì—¬ ë” ê°•ë ¥í•œ ë°ë¯¸ì§€ë¥¼ ì…íˆì„¸ìš”!\nê°•í™” ì‹œ **ë°ë¯¸ì§€ +1**ì”© ì¦ê°€í•©ë‹ˆë‹¤.')
                    .addFields(
                        { 
                            name: 'ğŸŒŸ ë³„ë˜¥ë² ê¸° (ìƒë‹¨)', 
                            value: `ë ˆë²¨: **+${enhanceLevels.high}**\nì„±ê³µë¥ : ${getSuccessRate(enhanceLevels.high)}%\në¹„ìš©: ${getEnhanceCost(enhanceLevels.high).toLocaleString()}G`, 
                            inline: true 
                        },
                        { 
                            name: 'ğŸ¬ ìŠˆê°€ìŠ¤íŒ… (ì¤‘ë‹¨)', 
                            value: `ë ˆë²¨: **+${enhanceLevels.middle}**\nì„±ê³µë¥ : ${getSuccessRate(enhanceLevels.middle)}%\në¹„ìš©: ${getEnhanceCost(enhanceLevels.middle).toLocaleString()}G`, 
                            inline: true 
                        },
                        { 
                            name: 'ğŸ„ ë²„ì„¯íŒ¡ (í•˜ë‹¨)', 
                            value: `ë ˆë²¨: **+${enhanceLevels.low}**\nì„±ê³µë¥ : ${getSuccessRate(enhanceLevels.low)}%\në¹„ìš©: ${getEnhanceCost(enhanceLevels.low).toLocaleString()}G`, 
                            inline: true 
                        },
                        { name: 'ğŸ’° ë³´ìœ  ê³¨ë“œ', value: `${user.gold.toLocaleString()}G`, inline: true },
                        { name: 'ğŸ“Š ê°•í™” í†µê³„', value: `ì‹œë„: ${user.pvp.pvpEnhanceHistory.totalAttempts}íšŒ\níŒŒê´´: ${user.pvp.pvpEnhanceHistory.destroyCount}íšŒ`, inline: true }
                    )
                    .setFooter({ text: 'âš ï¸ ì‹¤íŒ¨ ì‹œ ê°•í™” ë ˆë²¨ì´ í•˜ë½í•˜ê±°ë‚˜ 0ìœ¼ë¡œ ì´ˆê¸°í™”ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤!' });
                
                const enhanceButtons = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('pvp_enhance_high')
                            .setLabel('ğŸŒŸ ë³„ë˜¥ë² ê¸° ê°•í™”')
                            .setStyle(ButtonStyle.Primary)
                            .setDisabled(user.gold < getEnhanceCost(enhanceLevels.high)),
                        new ButtonBuilder()
                            .setCustomId('pvp_enhance_middle')
                            .setLabel('ğŸ¬ ìŠˆê°€ìŠ¤íŒ… ê°•í™”')
                            .setStyle(ButtonStyle.Primary)
                            .setDisabled(user.gold < getEnhanceCost(enhanceLevels.middle)),
                        new ButtonBuilder()
                            .setCustomId('pvp_enhance_low')
                            .setLabel('ğŸ„ ë²„ì„¯íŒ¡ ê°•í™”')
                            .setStyle(ButtonStyle.Primary)
                            .setDisabled(user.gold < getEnhanceCost(enhanceLevels.low))
                    );
                
                const backButton = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('back_to_pvp')
                            .setLabel('ğŸ”™ PVP ë©”ë‰´')
                            .setStyle(ButtonStyle.Secondary)
                    );
                
                await interaction.editReply({ 
                    embeds: [enhanceEmbed], 
                    components: [enhanceButtons, backButton]
                });
            }, 3000);
        }
        
        // PVP ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸°
        else if (interaction.customId === 'back_to_pvp') {
            const user = await getUser(interaction.user.id);
            if (!user) {
                await interaction.reply({ content: 'ìœ ì € ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            const pvpEmbed = new EmbedBuilder()
                .setColor('#ff0000')
                .setTitle('âš”ï¸ PVP ëŒ€ì „ì¥')
                .setDescription('ë‹¤ë¥¸ í”Œë ˆì´ì–´ì™€ ì‹¤ë ¥ì„ ê²¨ë¤„ë³´ì„¸ìš”!')
                .addFields(
                    { name: 'ğŸ–ï¸ ë‚˜ì˜ ë ˆì´íŒ…', value: `${user.pvp?.rating || 1000}ì `, inline: true },
                    { name: 'ğŸ… í‹°ì–´', value: user.pvp?.tier || 'Bronze', inline: true },
                    { name: 'ğŸ« ê²°íˆ¬ê¶Œ', value: `${user.pvp?.duelTickets || 20}ê°œ`, inline: true }
                );
            
            const pvpButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('pvp_matchmaking')
                        .setLabel('âš”ï¸ ëŒ€ì „ ì‹œì‘')
                        .setStyle(ButtonStyle.Danger),
                    new ButtonBuilder()
                        .setCustomId('pvp_enhance')
                        .setLabel('ğŸ’ ê³µê²© ê°•í™”')
                        .setStyle(ButtonStyle.Success),
                    new ButtonBuilder()
                        .setCustomId('pvp_ranking')
                        .setLabel('ğŸ† PVP ë­í‚¹')
                        .setStyle(ButtonStyle.Secondary),
                    new ButtonBuilder()
                        .setCustomId('pvp_info')
                        .setLabel('ğŸ“– PVP ì •ë³´')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            await interaction.update({ embeds: [pvpEmbed], components: [pvpButtons] });
        }
        
        // ë³´ìŠ¤ ê³µê²© ë²„íŠ¼ ì²˜ë¦¬
        else if (interaction.customId === 'boss_attack') {
            const boss = BOSS_SYSTEM.activeBoss;
            if (!boss) {
                await interaction.reply({ content: 'âŒ ë³´ìŠ¤ê°€ ì‚¬ë¼ì¡ŒìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            const user = await getUser(interaction.user.id);
            if (!BOSS_SYSTEM.participants.has(interaction.user.id)) {
                await interaction.reply({ content: 'âŒ ë³´ìŠ¤ ë ˆì´ë“œì— ì°¸ê°€í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            // í”Œë ˆì´ì–´ ê³µê²©ë ¥ ê³„ì‚°
            const combatPower = calculateCombatPower(user);
            const damage = Math.floor(combatPower * (0.8 + Math.random() * 0.4));
            
            // ë³´ìŠ¤ HP ê°ì†Œ
            boss.currentHp = Math.max(0, boss.currentHp - damage);
            
            // ë°ë¯¸ì§€ ê¸°ë¡
            const currentDamage = BOSS_SYSTEM.damageDealt.get(interaction.user.id) || 0;
            BOSS_SYSTEM.damageDealt.set(interaction.user.id, currentDamage + damage);
            
            const attackEmbed = new EmbedBuilder()
                .setColor('#00ff00')
                .setTitle('âš”ï¸ ê³µê²© ì„±ê³µ!')
                .setDescription(`**${user.nickname}**ë‹˜ì´ **${damage}**ì˜ ë°ë¯¸ì§€ë¥¼ ì…í˜”ìŠµë‹ˆë‹¤!`)
                .addFields(
                    { name: 'â¤ï¸ ë³´ìŠ¤ HP', value: `${boss.currentHp.toLocaleString()} / ${boss.hp.toLocaleString()}`, inline: true },
                    { name: 'ğŸ’¥ ëˆ„ì  ë°ë¯¸ì§€', value: `${(currentDamage + damage).toLocaleString()}`, inline: true }
                );
            
            // ë³´ìŠ¤ ê²©íŒŒ ì²´í¬
            if (boss.currentHp <= 0) {
                await interaction.reply({ embeds: [attackEmbed], flags: 64 });
                await handleBossDefeat(interaction.channel);
                return;
            }
            
            // ë³´ìŠ¤ ë°˜ê²©
            const bossSkill = boss.skills[Math.floor(Math.random() * boss.skills.length)];
            if (Math.random() < bossSkill.chance) {
                attackEmbed.addFields({
                    name: 'âš¡ ë³´ìŠ¤ ë°˜ê²©!',
                    value: `${boss.emoji} ${boss.name}ì´(ê°€) **${bossSkill.name}**ì„(ë¥¼) ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤!`,
                    inline: false
                });
            }
            
            await interaction.reply({ embeds: [attackEmbed], flags: 64 });
        }
        
        // ë³´ìŠ¤ ìŠ¤í‚¬ ì‚¬ìš© ë²„íŠ¼ ì²˜ë¦¬
        else if (interaction.customId === 'boss_skill') {
            const boss = BOSS_SYSTEM.activeBoss;
            if (!boss) {
                await interaction.reply({ content: 'âŒ ë³´ìŠ¤ê°€ ì‚¬ë¼ì¡ŒìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            const user = await getUser(interaction.user.id);
            if (!BOSS_SYSTEM.participants.has(interaction.user.id)) {
                await interaction.reply({ content: 'âŒ ë³´ìŠ¤ ë ˆì´ë“œì— ì°¸ê°€í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            // ìŠ¤í‚¬ ì¿¨ë‹¤ìš´ ì²´í¬ (5ì´ˆ)
            const lastSkillTime = user.lastBossSkillTime || 0;
            const cooldown = 5000;
            if (Date.now() - lastSkillTime < cooldown) {
                const remaining = Math.ceil((cooldown - (Date.now() - lastSkillTime)) / 1000);
                await interaction.reply({ content: `â±ï¸ ìŠ¤í‚¬ ì¿¨ë‹¤ìš´: ${remaining}ì´ˆ ë‚¨ìŒ`, flags: 64 });
                return;
            }
            
            // í”Œë ˆì´ì–´ ìŠ¤í‚¬ ë°ë¯¸ì§€ ê³„ì‚° (ì¼ë°˜ ê³µê²©ì˜ 2ë°°)
            const combatPower = calculateCombatPower(user);
            const damage = Math.floor(combatPower * 2 * (0.8 + Math.random() * 0.4));
            
            // ë³´ìŠ¤ HP ê°ì†Œ
            boss.currentHp = Math.max(0, boss.currentHp - damage);
            
            // ë°ë¯¸ì§€ ê¸°ë¡
            const currentDamage = BOSS_SYSTEM.damageDealt.get(interaction.user.id) || 0;
            BOSS_SYSTEM.damageDealt.set(interaction.user.id, currentDamage + damage);
            
            // ì¿¨ë‹¤ìš´ ê¸°ë¡
            user.lastBossSkillTime = Date.now();
            await user.save();
            
            const skillEmbed = new EmbedBuilder()
                .setColor('#ffff00')
                .setTitle('ğŸ’« ìŠ¤í‚¬ ë°œë™!')
                .setDescription(`**${user.nickname}**ë‹˜ì´ í•„ì‚´ê¸°ë¡œ **${damage}**ì˜ ë°ë¯¸ì§€ë¥¼ ì…í˜”ìŠµë‹ˆë‹¤!`)
                .addFields(
                    { name: 'â¤ï¸ ë³´ìŠ¤ HP', value: `${boss.currentHp.toLocaleString()} / ${boss.hp.toLocaleString()}`, inline: true },
                    { name: 'ğŸ’¥ ëˆ„ì  ë°ë¯¸ì§€', value: `${(currentDamage + damage).toLocaleString()}`, inline: true }
                );
            
            // ë³´ìŠ¤ ê²©íŒŒ ì²´í¬
            if (boss.currentHp <= 0) {
                await interaction.reply({ embeds: [skillEmbed], flags: 64 });
                await handleBossDefeat(interaction.channel);
                return;
            }
            
            await interaction.reply({ embeds: [skillEmbed], flags: 64 });
        }
        
        // ë³´ìŠ¤ ë°©ì–´ ë²„íŠ¼ ì²˜ë¦¬
        else if (interaction.customId === 'boss_defend') {
            await interaction.reply({ 
                content: 'ğŸ›¡ï¸ ë°©ì–´ íƒœì„¸ë¥¼ ì·¨í–ˆìŠµë‹ˆë‹¤! (ë‹¤ìŒ ê³µê²© ë°ë¯¸ì§€ 50% ê°ì†Œ)', 
                flags: 64 
            });
        }
        
        else if (interaction.customId === 'stock_portfolio') {
            const portfolio = await getPlayerPortfolio(interaction.user.id);
            
            let portfolioText = `ğŸ’° **í˜„ê¸ˆ**: ${portfolio.cash.toLocaleString()}<:currency_emoji:1377404064316522778>\n\n`;
            let totalValue = portfolio.cash;
            
            if (portfolio.stocks.size > 0) {
                portfolioText += 'ğŸ“ˆ **ë³´ìœ  ì£¼ì‹ ìƒì„¸:**\n';
                for (const [companyId, holding] of portfolio.stocks) {
                    const company = findCompany(companyId);
                    if (company) {
                        const currentValue = company.price * holding.shares;
                        const totalCost = holding.avgPrice * holding.shares;
                        const profit = currentValue - totalCost;
                        const profitPercent = ((profit / totalCost) * 100).toFixed(1);
                        
                        portfolioText += `\n**${company.name}**\n`;
                        portfolioText += `â€¢ ë³´ìœ ìˆ˜ëŸ‰: ${holding.shares}ì£¼\n`;
                        portfolioText += `â€¢ í‰ê· ë‹¨ê°€: ${holding.avgPrice.toLocaleString()}<:currency_emoji:1377404064316522778>\n`;
                        portfolioText += `â€¢ í˜„ì¬ê°€ê²©: ${company.price.toLocaleString()}<:currency_emoji:1377404064316522778>\n`;
                        portfolioText += `â€¢ í‰ê°€ì†ìµ: ${profit >= 0 ? '+' : ''}${profit.toLocaleString()}<:currency_emoji:1377404064316522778> (${profitPercent >= 0 ? '+' : ''}${profitPercent}%)\n`;
                        
                        totalValue += currentValue;
                    }
                }
            } else {
                portfolioText += 'ğŸ“Š ë³´ìœ  ì£¼ì‹ì´ ì—†ìŠµë‹ˆë‹¤.\n\n';
            }
            
            portfolioText += `\nğŸ’ **ì´ ìì‚°**: ${totalValue.toLocaleString()}<:currency_emoji:1377404064316522778>`;
            
            // ì‹¤ì œ íˆ¬ì ì›ê¸ˆ ê³„ì‚° (ì£¼ì‹ êµ¬ë§¤ì— ì‚¬ìš©í•œ ê¸ˆì•¡)
            let totalInvested = 0;
            if (portfolio.stocks.size > 0) {
                for (const [companyId, holding] of portfolio.stocks) {
                    totalInvested += holding.avgPrice * holding.shares;
                }
                const profitLoss = totalValue - portfolio.cash - totalInvested;
                const profitRate = totalInvested > 0 ? (profitLoss / totalInvested * 100) : 0;
                portfolioText += `\nğŸ“Š **ìˆ˜ìµë¥ **: ${profitRate >= 0 ? '+' : ''}${profitRate.toFixed(1)}%`;
            } else {
                portfolioText += `\nğŸ“Š **ìˆ˜ìµë¥ **: 0.0%`;
            }

            const portfolioEmbed = new EmbedBuilder()
                .setColor('#9b59b6')
                .setTitle('ğŸ’¼ ë‚´ í¬íŠ¸í´ë¦¬ì˜¤')
                .setDescription(portfolioText)
                .setFooter({ text: 'í¬íŠ¸í´ë¦¬ì˜¤ëŠ” ì‹¤ì‹œê°„ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤!' });

            const backButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('stock_main')
                        .setLabel('ğŸ”™ ì£¼ì‹ ë©”ì¸')
                        .setStyle(ButtonStyle.Primary)
                );

            await interaction.update({
                embeds: [portfolioEmbed],
                components: [backButton]
            });
        }
        
        else if (interaction.customId === 'stock_news') {
            // ìµœê·¼ ì‹œì¥ ì´ë²¤íŠ¸ì™€ NPC ê°ì • ìƒíƒœ í‘œì‹œ
            const emotions = STOCK_MARKET.npc_emotions;
            const marketState = STOCK_MARKET.market_state;
            
            let newsText = 'ğŸ“Š **ì‹œì¥ í˜„í™©**\n';
            newsText += `â€¢ ì „ì²´ íŠ¸ë Œë“œ: ${marketState.overall_trend > 0 ? 'ğŸ“ˆ ìƒìŠ¹' : marketState.overall_trend < 0 ? 'ğŸ“‰ í•˜ë½' : 'â¡ï¸ ë³´í•©'}\n`;
            newsText += `â€¢ ë³€ë™ì„±: ${marketState.volatility}%\n\n`;
            
            newsText += 'ğŸ˜Š **NPC ê°ì • í˜„í™©**\n';
            newsText += `â€¢ ë§ˆì„ì£¼ë¯¼ í–‰ë³µë„: ${emotions.villagers.happiness.toFixed(0)}%\n`;
            newsText += `â€¢ ìƒì¸ ë§Œì¡±ë„: ${emotions.merchants.satisfaction.toFixed(0)}%\n`;
            newsText += `â€¢ ì—¬í–‰ì í˜¸ê¸°ì‹¬: ${emotions.travelers.curiosity.toFixed(0)}%\n\n`;
            
            newsText += 'ğŸ¯ **í”Œë ˆì´ì–´ í™œë™ í†µê³„**\n';
            newsText += `â€¢ ì´ ê°•í™” ì‹œë„: ${marketState.player_actions.total_enhancement_attempts}íšŒ\n`;
            newsText += `â€¢ ê°•í™” ì„±ê³µ: ${marketState.player_actions.successful_enhancements}íšŒ\n`;
            newsText += `â€¢ ìƒì  êµ¬ë§¤: ${marketState.player_actions.shop_purchases}íšŒ\n`;
            
            const newsEmbed = new EmbedBuilder()
                .setColor('#f39c12')
                .setTitle('ğŸ“° ê¹€í—Œí„° ì‹œì¥ ë‰´ìŠ¤')
                .setDescription(newsText)
                .setFooter({ text: 'ì‹œì¥ì€ ì—¬ëŸ¬ë¶„ì˜ ëª¨ë“  í–‰ë™ì— ë°˜ì‘í•©ë‹ˆë‹¤!' });

            const backButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('stock_main')
                        .setLabel('ğŸ”™ ì£¼ì‹ ë©”ì¸')
                        .setStyle(ButtonStyle.Primary)
                );

            await interaction.update({
                embeds: [newsEmbed],
                components: [backButton]
            });
        }
        
        else if (interaction.customId === 'stock_chart') {
            await interaction.deferUpdate();
            
            try {
                const chartHistory = STOCK_MARKET.chart_history;
                
                if (chartHistory.timestamps.length === 0) {
                    await interaction.editReply({
                        content: 'ğŸ“Š ì°¨íŠ¸ ë°ì´í„°ê°€ ì•„ì§ ìˆ˜ì§‘ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤! ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
                        embeds: [],
                        components: []
                    });
                    return;
                }
                
                // QuickChartë¡œ ì‹¤ì œ ì°¨íŠ¸ URL ìƒì„±
                const chartUrl = await generateMarketOverviewChart();
                
                if (!chartUrl) {
                    await interaction.editReply({
                        content: 'âŒ ì°¨íŠ¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
                        embeds: [],
                        components: []
                    });
                    return;
                }
                
                // ì‹œì¥ ìƒíƒœ ì •ë³´
                const marketTrend = STOCK_MARKET.market_state.overall_trend;
                const trendIcon = marketTrend > 5 ? 'ğŸ“ˆ' : marketTrend < -5 ? 'ğŸ“‰' : 'â¡ï¸';
                const trendText = marketTrend > 5 ? 'ìƒìŠ¹ì„¸' : marketTrend < -5 ? 'í•˜ë½ì„¸' : 'ë³´í•©ì„¸';
                
                // ìƒìœ„ ê¸°ì—… ì •ë³´
                const allCompanies = [];
                for (const region of Object.values(STOCK_MARKET.regions)) {
                    allCompanies.push(...region.companies);
                }
                allCompanies.push(...STOCK_MARKET.chains);
                
                const top3Companies = allCompanies
                    .sort((a, b) => b.price - a.price)
                    .slice(0, 3);
                
                let topCompanyInfo = '';
                for (const company of top3Companies) {
                    if (chartHistory.top_companies[company.id] && chartHistory.top_companies[company.id].length > 1) {
                        const prices = chartHistory.top_companies[company.id];
                        const firstPrice = prices[0];
                        const lastPrice = prices[prices.length - 1];
                        const change = ((lastPrice - firstPrice) / firstPrice * 100).toFixed(1);
                        const changeIcon = change > 0 ? 'ğŸ“ˆ' : change < 0 ? 'ğŸ“‰' : 'â¡ï¸';
                        
                        topCompanyInfo += `${changeIcon} **${company.name}** ${company.price.toLocaleString()}G (${change > 0 ? '+' : ''}${change}%)\n`;
                    }
                }
                
                const chartEmbed = new EmbedBuilder()
                    .setColor('#2ecc71')
                    .setTitle('ğŸ“Š ê¹€í—Œí„° ì‹¤ì‹œê°„ ì£¼ì‹ ì°¨íŠ¸')
                    .setDescription(`**ì‹¤ì‹œê°„ ì£¼ì‹ ì‹œì¥ ë™í–¥**\në§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: ${chartHistory.timestamps[chartHistory.timestamps.length - 1]}`)
                    .setImage(chartUrl)
                    .addFields(
                        { name: 'ğŸ“Š ì‹œì¥ í˜„í™©', value: `${trendIcon} ${trendText} (${marketTrend > 0 ? '+' : ''}${marketTrend.toFixed(1)}%)\nğŸ“Š ë³€ë™ì„±: ${STOCK_MARKET.market_state.volatility}%\nğŸ• ë‹¤ìŒ ì—…ë°ì´íŠ¸: 5ë¶„ë§ˆë‹¤`, inline: true },
                        { name: 'ğŸ† ìƒìœ„ ê¸°ì—…', value: topCompanyInfo || 'ë°ì´í„° ì—†ìŒ', inline: true }
                    )
                    .setFooter({ text: 'ì‹¤ì‹œê°„ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë˜ëŠ” ì „ë¬¸ ì°¨íŠ¸ì…ë‹ˆë‹¤!' });
                
                const chartButtons = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('refresh_chart')
                            .setLabel('ğŸ”„ ìƒˆë¡œê³ ì¹¨')
                            .setStyle(ButtonStyle.Success),
                        new ButtonBuilder()
                            .setCustomId('company_charts')
                            .setLabel('ğŸ“ˆ ê¸°ì—…ë³„ ì°¨íŠ¸')
                            .setStyle(ButtonStyle.Secondary),
                        new ButtonBuilder()
                            .setCustomId('stock_main')
                            .setLabel('ğŸ”™ ì£¼ì‹ ë©”ì¸')
                            .setStyle(ButtonStyle.Primary)
                    );
                
                await interaction.editReply({
                    embeds: [chartEmbed],
                    components: [chartButtons]
                });
                
            } catch (error) {
                console.error('ì£¼ì‹ ì°¨íŠ¸ ìƒì„± ì˜¤ë¥˜:', error);
                await interaction.editReply({
                    content: 'âŒ ì°¨íŠ¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
                    embeds: [],
                    components: []
                });
            }
        }
        
        else if (interaction.customId === 'refresh_chart') {
            // ì°¨íŠ¸ ìƒˆë¡œê³ ì¹¨
            await interaction.deferUpdate();
            
            // ì¦‰ì‹œ ì°¨íŠ¸ ë°ì´í„° ì—…ë°ì´íŠ¸
            updateStockPrices();
            updateChartData();
            
            // ìƒˆë¡œìš´ ì°¨íŠ¸ ìƒì„± ë° ì „ì†¡
            try {
                const refreshChartUrl = await generateMarketOverviewChart();
                
                if (!refreshChartUrl) {
                    await interaction.editReply({
                        content: 'âŒ ì°¨íŠ¸ ìƒˆë¡œê³ ì¹¨ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
                        embeds: [],
                        components: []
                    });
                    return;
                }
                const chartHistory = STOCK_MARKET.chart_history;
                
                // ì‹œì¥ ìƒíƒœ ì •ë³´
                const marketTrend = STOCK_MARKET.market_state.overall_trend;
                const trendIcon = marketTrend > 5 ? 'ğŸ“ˆ' : marketTrend < -5 ? 'ğŸ“‰' : 'â¡ï¸';
                const trendText = marketTrend > 5 ? 'ìƒìŠ¹ì„¸' : marketTrend < -5 ? 'í•˜ë½ì„¸' : 'ë³´í•©ì„¸';
                
                // ìƒìœ„ ê¸°ì—… ì •ë³´
                const allCompanies = [];
                for (const region of Object.values(STOCK_MARKET.regions)) {
                    allCompanies.push(...region.companies);
                }
                allCompanies.push(...STOCK_MARKET.chains);
                
                const top3Companies = allCompanies
                    .sort((a, b) => b.price - a.price)
                    .slice(0, 3);
                
                let topCompanyInfo = '';
                for (const company of top3Companies) {
                    if (chartHistory.top_companies[company.id] && chartHistory.top_companies[company.id].length > 1) {
                        const prices = chartHistory.top_companies[company.id];
                        const firstPrice = prices[0];
                        const lastPrice = prices[prices.length - 1];
                        const change = ((lastPrice - firstPrice) / firstPrice * 100).toFixed(1);
                        const changeIcon = change > 0 ? 'ğŸ“ˆ' : change < 0 ? 'ğŸ“‰' : 'â¡ï¸';
                        
                        topCompanyInfo += `${changeIcon} **${company.name}** ${company.price.toLocaleString()}G (${change > 0 ? '+' : ''}${change}%)\n`;
                    }
                }
                
                const refreshEmbed = new EmbedBuilder()
                    .setColor('#27ae60')
                    .setTitle('ğŸ”„ ê¹€í—Œí„° ì‹¤ì‹œê°„ ì£¼ì‹ ì°¨íŠ¸ (ìƒˆë¡œê³ ì¹¨)')
                    .setDescription(`**ì‹¤ì‹œê°„ ì£¼ì‹ ì‹œì¥ ë™í–¥**\në§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: ${new Date().toLocaleTimeString('ko-KR')}`)
                    .setImage(refreshChartUrl)
                    .addFields(
                        { name: 'ğŸ“Š ì‹œì¥ í˜„í™©', value: `${trendIcon} ${trendText} (${marketTrend > 0 ? '+' : ''}${marketTrend.toFixed(1)}%)\nğŸ“Š ë³€ë™ì„±: ${STOCK_MARKET.market_state.volatility}%\nğŸ• ë‹¤ìŒ ì—…ë°ì´íŠ¸: 5ë¶„ë§ˆë‹¤`, inline: true },
                        { name: 'ğŸ† ìƒìœ„ ê¸°ì—…', value: topCompanyInfo || 'ë°ì´í„° ì—†ìŒ', inline: true }
                    )
                    .setFooter({ text: 'ğŸ”„ ì°¨íŠ¸ê°€ ìƒˆë¡œê³ ì¹¨ë˜ì—ˆìŠµë‹ˆë‹¤! Powered by QuickChart' });
                
                const chartButtons = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('refresh_chart')
                            .setLabel('ğŸ”„ ìƒˆë¡œê³ ì¹¨')
                            .setStyle(ButtonStyle.Success),
                        new ButtonBuilder()
                            .setCustomId('company_charts')
                            .setLabel('ğŸ“ˆ ê¸°ì—…ë³„ ì°¨íŠ¸')
                            .setStyle(ButtonStyle.Secondary),
                        new ButtonBuilder()
                            .setCustomId('stock_main')
                            .setLabel('ğŸ”™ ì£¼ì‹ ë©”ì¸')
                            .setStyle(ButtonStyle.Primary)
                    );
                
                await interaction.editReply({
                    embeds: [refreshEmbed],
                    components: [chartButtons]
                });
                
            } catch (error) {
                console.error('ì°¨íŠ¸ ìƒˆë¡œê³ ì¹¨ ì˜¤ë¥˜:', error);
                await interaction.editReply({
                    content: 'âŒ ì°¨íŠ¸ ìƒˆë¡œê³ ì¹¨ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
                    embeds: [],
                    components: []
                });
            }
        }
        
        else if (interaction.customId === 'company_charts') {
            await interaction.deferUpdate();
            
            try {
                // ê°œë³„ ê¸°ì—… ì°¨íŠ¸ ì„ íƒ ë©”ë‰´ ìƒì„±
                const allCompanies = [];
                for (const region of Object.values(STOCK_MARKET.regions)) {
                    allCompanies.push(...region.companies);
                }
                allCompanies.push(...STOCK_MARKET.chains);
                
                const top10Companies = allCompanies
                    .sort((a, b) => b.price - a.price)
                    .slice(0, 10);
                
                const companyOptions = top10Companies.map((company, index) => {
                    const chartHistory = STOCK_MARKET.chart_history;
                    let changeText = '';
                    
                    if (chartHistory.top_companies[company.id] && chartHistory.top_companies[company.id].length > 1) {
                        const prices = chartHistory.top_companies[company.id];
                        const change = ((prices[prices.length - 1] - prices[0]) / prices[0] * 100).toFixed(1);
                        changeText = ` (${change > 0 ? '+' : ''}${change}%)`;
                    }
                    
                    return {
                        label: company.name + changeText,
                        description: `í˜„ì¬ ì£¼ê°€: ${company.price.toLocaleString()}G`,
                        value: `company_chart_${company.id}`,
                        emoji: index === 0 ? 'ğŸ¥‡' : index === 1 ? 'ğŸ¥ˆ' : index === 2 ? 'ğŸ¥‰' : 'ğŸ“ˆ'
                    };
                });
                
                const companySelect = new StringSelectMenuBuilder()
                    .setCustomId('select_company_chart')
                    .setPlaceholder('ê¸°ì—…ì„ ì„ íƒí•˜ì—¬ ê°œë³„ ì°¨íŠ¸ ë³´ê¸°')
                    .addOptions(companyOptions);
                
                const selectRow = new ActionRowBuilder().addComponents(companySelect);
                
                const backButton = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('all_companies_chart')
                            .setLabel('ğŸ“Š ì „ì²´ ê¸°ì—… ì°¨íŠ¸')
                            .setStyle(ButtonStyle.Secondary),
                        new ButtonBuilder()
                            .setCustomId('stock_chart')
                            .setLabel('ğŸ”™ ì „ì²´ ì°¨íŠ¸')
                            .setStyle(ButtonStyle.Primary)
                    );
                
                const embed = new EmbedBuilder()
                    .setColor('#3498db')
                    .setTitle('ğŸ“ˆ ê¸°ì—…ë³„ ê°œë³„ ì°¨íŠ¸')
                    .setDescription('ì•„ë˜ ë©”ë‰´ì—ì„œ ê¸°ì—…ì„ ì„ íƒí•˜ë©´ í•´ë‹¹ ê¸°ì—…ì˜ ìƒì„¸ ì°¨íŠ¸ë¥¼ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.')
                    .addFields(
                        { name: 'ğŸ† ìƒìœ„ ê¸°ì—… ëª©ë¡', value: top10Companies.map((c, i) => `${i+1}. **${c.name}** - ${c.price.toLocaleString()}G`).join('\n'), inline: false }
                    );
                
                await interaction.editReply({
                    embeds: [embed],
                    components: [selectRow, backButton],
                    files: []
                });
                
            } catch (error) {
                console.error('ê¸°ì—… ì°¨íŠ¸ ë©”ë‰´ ì˜¤ë¥˜:', error);
                await interaction.editReply({
                    content: 'âŒ ê¸°ì—… ì°¨íŠ¸ ë©”ë‰´ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
                    embeds: [],
                    components: []
                });
            }
        }
        
        else if (interaction.customId === 'stock_analysis') {
            // ìƒì„¸ ì‹œì¥ ë¶„ì„
            const analysis = [];
            
            // ì‹œì¥ ë™í–¥ ë¶„ì„
            const marketTrend = STOCK_MARKET.market_state.overall_trend;
            if (marketTrend > 10) {
                analysis.push('ğŸ”¥ **ê°•ë ¥í•œ ìƒìŠ¹ì¥**: ì‹œì¥ì´ ë§¤ìš° í™œë°œí•©ë‹ˆë‹¤!');
            } else if (marketTrend > 5) {
                analysis.push('ğŸ“ˆ **ì˜¨ê±´í•œ ìƒìŠ¹**: ì‹œì¥ì´ ì•ˆì •ì ìœ¼ë¡œ ì„±ì¥í•˜ê³  ìˆìŠµë‹ˆë‹¤.');
            } else if (marketTrend < -10) {
                analysis.push('â„ï¸ **ê°•ë ¥í•œ í•˜ë½ì¥**: ì‹œì¥ì´ í° ì¶©ê²©ì„ ë°›ê³  ìˆìŠµë‹ˆë‹¤.');
            } else if (marketTrend < -5) {
                analysis.push('ğŸ“‰ **ì•½í•œ í•˜ë½**: ì‹œì¥ì´ ì¡°ì •ì„ ë°›ê³  ìˆìŠµë‹ˆë‹¤.');
            } else {
                analysis.push('â¡ï¸ **ë³´í•©ì„¸**: ì‹œì¥ì´ ë°©í–¥ì„±ì„ ì°¾ê³  ìˆìŠµë‹ˆë‹¤.');
            }
            
            // ë³€ë™ì„± ë¶„ì„
            const volatility = STOCK_MARKET.market_state.volatility;
            if (volatility > 50) {
                analysis.push('âš¡ **ê³ ë³€ë™ì„±**: ê¸‰ê²©í•œ ê°€ê²© ë³€ë™ì´ ì˜ˆìƒë©ë‹ˆë‹¤.');
            } else if (volatility > 30) {
                analysis.push('ğŸŒŠ **ì¤‘ê°„ ë³€ë™ì„±**: ì ë‹¹í•œ ê°€ê²© ë³€ë™ì´ ìˆìŠµë‹ˆë‹¤.');
            } else {
                analysis.push('ğŸï¸ **ì €ë³€ë™ì„±**: ì•ˆì •ì ì¸ ì‹œì¥ ìƒí™©ì…ë‹ˆë‹¤.');
            }
            
            // NPC ê°ì • ë¶„ì„
            const emotions = STOCK_MARKET.npc_emotions;
            if (emotions.villagers.happiness > 70) {
                analysis.push('ğŸ˜Š **ë§ˆì„ ë¶„ìœ„ê¸° ì¢‹ìŒ**: ìƒí™œìš©í’ˆ ê´€ë ¨ ì£¼ì‹ ìƒìŠ¹ ìš”ì¸');
            }
            if (emotions.merchants.greed > 80) {
                analysis.push('ğŸ’° **ìƒì¸ë“¤ íƒìš• ì¦ê°€**: ë¬´ì—­/ìƒì—… ê´€ë ¨ ì£¼ì‹ ê³¼ì—´ ì£¼ì˜');
            }
            if (emotions.travelers.curiosity > 85) {
                analysis.push('ğŸ§­ **ì—¬í–‰ì í™œë™ ì¦ê°€**: ì—¬í–‰/ëª¨í—˜ ê´€ë ¨ ì£¼ì‹ í˜¸ì¬');
            }
            
            // í”Œë ˆì´ì–´ í™œë™ ë¶„ì„
            const actions = STOCK_MARKET.market_state.player_actions;
            if (actions.successful_enhancements > actions.total_enhancement_attempts * 0.7) {
                analysis.push('ğŸ”¨ **ê°•í™” ì„±ê³µë¥  ë†’ìŒ**: ì¥ë¹„/ì œì‘ ê´€ë ¨ ì£¼ì‹ ìƒìŠ¹ì„¸');
            }
            if (actions.shop_purchases > 100) {
                analysis.push('ğŸ›’ **í™œë°œí•œ ì†Œë¹„**: ì†Œë§¤ì—… ê´€ë ¨ ì£¼ì‹ í˜¸ì¬');
            }
            
            const analysisEmbed = new EmbedBuilder()
                .setColor('#9b59b6')
                .setTitle('ğŸ” ê¹€í—Œí„° ì‹œì¥ ì‹¬ì¸µ ë¶„ì„')
                .setDescription('AI ê¸°ë°˜ ì‹œì¥ ë¶„ì„ ë¦¬í¬íŠ¸')
                .addFields(
                    { name: 'ğŸ“Š ì¢…í•© ë¶„ì„', value: analysis.join('\n\n'), inline: false },
                    { name: 'ğŸ“ˆ íˆ¬ì ê¶Œì¥ë„', value: marketTrend > 0 ? 'ğŸŸ¢ **ë§¤ìˆ˜ ìš°ìœ„**' : marketTrend < -5 ? 'ğŸ”´ **ë§¤ë„ ìš°ìœ„**' : 'ğŸŸ¡ **ê´€ë§**', inline: true },
                    { name: 'âš ï¸ ë¦¬ìŠ¤í¬ ë ˆë²¨', value: volatility > 50 ? 'ğŸ”´ ë†’ìŒ' : volatility > 30 ? 'ğŸŸ¡ ë³´í†µ' : 'ğŸŸ¢ ë‚®ìŒ', inline: true }
                )
                .setFooter({ text: 'âš ï¸ íˆ¬ì íŒë‹¨ì€ ì‹ ì¤‘í•˜ê²Œ í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤!' });
                
            const backButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('stock_chart')
                        .setLabel('ğŸ”™ ì°¨íŠ¸ë¡œ ëŒì•„ê°€ê¸°')
                        .setStyle(ButtonStyle.Primary)
                );
                
            await interaction.update({
                embeds: [analysisEmbed],
                components: [backButton]
            });
        }
        
        else if (interaction.customId === 'stock_main') {
            // ì£¼ì‹ ë©”ì¸ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°€ê¸° - /ì£¼ì‹ ëª…ë ¹ì–´ì™€ ë™ì¼í•œ ë‚´ìš©
            const portfolio = await getPlayerPortfolio(interaction.user.id);
            
            const allCompanies = [];
            
            for (const region of Object.values(STOCK_MARKET.regions)) {
                region.companies.forEach(company => {
                    allCompanies.push({
                        ...company,
                        region: region.name
                    });
                });
            }
            
            STOCK_MARKET.chains.forEach(company => {
                allCompanies.push({
                    ...company,
                    region: 'ğŸŒ ì „ì§€ì—­'
                });
            });
            
            allCompanies.sort((a, b) => b.price - a.price);
            const topCompanies = allCompanies.slice(0, 10);
            
            let totalPortfolioValue = portfolio.cash;
            let portfolioText = `ğŸ’° í˜„ê¸ˆ: ${portfolio.cash.toLocaleString()}<:currency_emoji:1377404064316522778>\n\n`;
            
            if (portfolio.stocks.size > 0) {
                portfolioText += 'ğŸ“ˆ **ë³´ìœ  ì£¼ì‹:**\n';
                for (const [companyId, holding] of portfolio.stocks) {
                    const company = findCompany(companyId);
                    if (company) {
                        const currentValue = company.price * holding.shares;
                        const profit = currentValue - (holding.avgPrice * holding.shares);
                        const profitPercent = ((profit / (holding.avgPrice * holding.shares)) * 100).toFixed(1);
                        
                        portfolioText += `â€¢ ${company.name}: ${holding.shares}ì£¼ `;
                        portfolioText += `(${profitPercent >= 0 ? '+' : ''}${profitPercent}%)\n`;
                        
                        totalPortfolioValue += currentValue;
                    }
                }
            } else {
                portfolioText += 'ğŸ“Š ë³´ìœ  ì£¼ì‹ì´ ì—†ìŠµë‹ˆë‹¤.\n';
            }
            
            portfolioText += `\nğŸ’ **ì´ ìì‚°**: ${totalPortfolioValue.toLocaleString()}<:currency_emoji:1377404064316522778>`;
            
            let marketText = '';
            topCompanies.forEach((company, index) => {
                const changeIcon = company.change > 0 ? 'ğŸ“ˆ' : company.change < 0 ? 'ğŸ“‰' : 'â¡ï¸';
                const changeColor = company.change > 0 ? '+' : '';
                marketText += `${index + 1}. **${company.name}**\n`;
                marketText += `   ${company.price.toLocaleString()}<:currency_emoji:1377404064316522778> ${changeIcon} ${changeColor}${company.change.toFixed(1)}%\n`;
                marketText += `   ${company.region} | ê±°ë˜ëŸ‰: ${company.volume.toLocaleString()}\n\n`;
            });
            
            const stockEmbed = new EmbedBuilder()
                .setColor('#2ecc71')
                .setTitle('ğŸ“Š ê¹€í—Œí„° ì£¼ì‹ ì‹œì¥')
                .setDescription(`**${user.nickname}**ë‹˜ì˜ íˆ¬ì í˜„í™©\n\n${portfolioText}`)
                .addFields(
                    { 
                        name: 'ğŸ† ìƒìœ„ ê¸°ì—… ìˆœìœ„', 
                        value: marketText || 'ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...', 
                        inline: false 
                    }
                )
                .setFooter({ 
                    text: 'ì‹¤ì‹œê°„ ì£¼ê°€ëŠ” NPC ê°ì •, í”Œë ˆì´ì–´ í–‰ë™, ì‹œê°„ëŒ€ë³„ ì´ë²¤íŠ¸ì— ì˜í–¥ì„ ë°›ìŠµë‹ˆë‹¤!' 
                });
            
            const stockButtons1 = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('stock_regions')
                        .setLabel('ğŸŒ ì§€ì—­ë³„ ê¸°ì—…')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('stock_chains')
                        .setLabel('ğŸ¢ ì²´ì¸ ê¸°ì—…')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('stock_portfolio')
                        .setLabel('ğŸ’¼ ë‚´ í¬íŠ¸í´ë¦¬ì˜¤')
                        .setStyle(ButtonStyle.Secondary),
                    new ButtonBuilder()
                        .setCustomId('stock_chart')
                        .setLabel('ğŸ“ˆ ì°¨íŠ¸')
                        .setStyle(ButtonStyle.Secondary)
                );
                
            const stockButtons2 = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('recover_my_stocks')
                        .setLabel('ğŸ”§ ë‚´ ì£¼ì‹ ë³µêµ¬')
                        .setStyle(ButtonStyle.Danger),
                    new ButtonBuilder()
                        .setCustomId('stock_help')
                        .setLabel('â“ ë„ì›€ë§')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            await interaction.update({
                embeds: [stockEmbed],
                components: [stockButtons1, stockButtons2]
            });
        }
        
        // ë ˆì´ì‹± ë²„íŠ¼ í•¸ë“¤ëŸ¬ë“¤
        else if (interaction.customId === 'join_race') {
            // ë ˆì´ìŠ¤ ì°¸ê°€ í™”ë©´ í‘œì‹œ
            await interaction.deferReply({ flags: 64 });
            
            const raceStatus = raceSystem.getRaceStatus();
            
            // ì§„í–‰ ì¤‘ì¸ ë ˆì´ìŠ¤ê°€ ìˆëŠ”ì§€ í™•ì¸
            if (raceStatus.isRacing) {
                const remainingTime = Math.max(0, raceStatus.raceEndTime - Date.now());
                const seconds = Math.floor(remainingTime / 1000);
                
                await interaction.editReply({ 
                    content: `â±ï¸ í˜„ì¬ ë ˆì´ìŠ¤ê°€ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤! (${seconds}ì´ˆ ë‚¨ìŒ)\në‹¤ìŒ ë ˆì´ìŠ¤ë¥¼ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.` 
                });
                return;
            }
            
            // ì´ë¯¸ ì°¸ê°€í–ˆëŠ”ì§€ í™•ì¸
            const isParticipating = raceStatus.players.some(p => p.userId === interaction.user.id);
            if (isParticipating) {
                await interaction.editReply({ 
                    content: 'âŒ ì´ë¯¸ ë ˆì´ìŠ¤ì— ì°¸ê°€í•˜ì…¨ìŠµë‹ˆë‹¤!' 
                });
                return;
            }
            
            // ì°¸ê°€ ì˜µì…˜ í‘œì‹œ
            const joinEmbed = new EmbedBuilder()
                .setColor('#00ff00')
                .setTitle('ğŸ ë ˆì´ìŠ¤ ì°¸ê°€')
                .setDescription('ë² íŒ… ê¸ˆì•¡ì„ ì„ íƒí•´ì£¼ì„¸ìš”!')
                .addFields(
                    { name: 'ğŸ’° ë³´ìœ  ê³¨ë“œ', value: `${user.gold.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true },
                    { name: 'ğŸ‘¥ í˜„ì¬ ì°¸ê°€ì', value: `${raceStatus.players.length}/${raceSystem.maxPlayers}ëª…`, inline: true },
                    { name: 'ğŸ’ í˜„ì¬ ìƒê¸ˆí’€', value: `${raceStatus.totalPot.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true }
                );
            
            const joinButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('join_race_1000')
                        .setLabel('ğŸ¯ 1,000ê³¨ë“œ')
                        .setStyle(ButtonStyle.Primary)
                        .setDisabled(user.gold < 1000),
                    new ButtonBuilder()
                        .setCustomId('join_race_5000')
                        .setLabel('ğŸ’ 5,000ê³¨ë“œ')
                        .setStyle(ButtonStyle.Success)
                        .setDisabled(user.gold < 5000),
                    new ButtonBuilder()
                        .setCustomId('join_race_custom')
                        .setLabel('ğŸ’° ì§ì ‘ ì…ë ¥')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(user.gold < raceSystem.minBet),
                    new ButtonBuilder()
                        .setCustomId('racing')
                        .setLabel('ğŸ”™ ëŒì•„ê°€ê¸°')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            await interaction.editReply({ 
                embeds: [joinEmbed], 
                components: [joinButtons] 
            });
        }
        
        else if (interaction.customId === 'join_race_1000') {
            const result = await raceSystem.joinRace(
                interaction.user.id, 
                1000, 
                user, 
                interaction.user.displayAvatarURL({ extension: 'png', size: 128 }),
                interaction.channel
            );
            
            if (result.success) {
                await interaction.reply({ 
                    content: `âœ… ${result.message}\nğŸ’° ìƒê¸ˆí’€: ${result.totalPot.toLocaleString()}<:currency_emoji:1377404064316522778> | ğŸ‘¥ ì°¸ê°€ì: ${result.currentPlayers}ëª…`, 
                    flags: 64 
                });
            } else {
                await interaction.reply({ content: `âŒ ${result.message}`, flags: 64 });
            }
        }
        
        else if (interaction.customId === 'join_race_5000') {
            const result = await raceSystem.joinRace(
                interaction.user.id, 
                5000, 
                user, 
                interaction.user.displayAvatarURL({ extension: 'png', size: 128 }),
                interaction.channel
            );
            
            if (result.success) {
                await interaction.reply({ 
                    content: `âœ… ${result.message}\nğŸ’° ìƒê¸ˆí’€: ${result.totalPot.toLocaleString()}<:currency_emoji:1377404064316522778> | ğŸ‘¥ ì°¸ê°€ì: ${result.currentPlayers}ëª…`, 
                    flags: 64 
                });
            } else {
                await interaction.reply({ content: `âŒ ${result.message}`, flags: 64 });
            }
        }
        
        else if (interaction.customId === 'join_race_custom') {
            // ì»¤ìŠ¤í…€ ë² íŒ… ê¸ˆì•¡ ëª¨ë‹¬ í‘œì‹œ
            const customBetModal = new ModalBuilder()
                .setCustomId('custom_bet_modal')
                .setTitle('ğŸ ë ˆì´ì‹± ì°¸ê°€');
            
            const betInput = new TextInputBuilder()
                .setCustomId('bet_amount')
                .setLabel('ë² íŒ… ê¸ˆì•¡')
                .setStyle(TextInputStyle.Short)
                .setPlaceholder(`${raceSystem.minBet.toLocaleString()} ~ ${raceSystem.maxBet.toLocaleString()}`)
                .setRequired(true)
                .setMaxLength(10);
            
            const firstActionRow = new ActionRowBuilder().addComponents(betInput);
            customBetModal.addComponents(firstActionRow);
            
            await interaction.showModal(customBetModal);
        }
        
        else if (interaction.customId === 'leave_race') {
            const result = await raceSystem.leaveRace(interaction.user.id);
            
            if (result.success) {
                await interaction.reply({ 
                    content: `âœ… ${result.message}\nğŸ’° ìƒê¸ˆí’€: ${result.totalPot.toLocaleString()}<:currency_emoji:1377404064316522778> | ğŸ‘¥ ì°¸ê°€ì: ${result.currentPlayers}ëª…`, 
                    flags: 64 
                });
            } else {
                await interaction.reply({ content: `âŒ ${result.message}`, flags: 64 });
            }
        }
        
        else if (interaction.customId === 'race_status') {
            // ë ˆì´ìŠ¤ í˜„í™© ë³´ê¸°
            await interaction.deferReply({ flags: 64 });
            
            const raceStatus = raceSystem.getRaceStatus();
            
            const statusEmbed = new EmbedBuilder()
                .setColor('#0099ff')
                .setTitle('ğŸ ë ˆì´ìŠ¤ í˜„í™©')
                .setTimestamp();
            
            if (raceStatus.isRacing) {
                const remainingTime = Math.max(0, raceStatus.raceEndTime - Date.now());
                const seconds = Math.floor(remainingTime / 1000);
                
                statusEmbed.setDescription(`â±ï¸ **ë ˆì´ìŠ¤ ì§„í–‰ ì¤‘!** (${seconds}ì´ˆ ë‚¨ìŒ)`);
                
                // í˜„ì¬ ìˆœìœ„ í‘œì‹œ
                const positions = raceStatus.players
                    .map(p => ({
                        ...p,
                        position: Math.random() * 100 // ì„ì‹œ ìœ„ì¹˜ (ì‹¤ì œë¡œëŠ” ë ˆì´ìŠ¤ ì§„í–‰ ìƒí™©ì— ë”°ë¼)
                    }))
                    .sort((a, b) => b.position - a.position);
                
                let raceField = '```\n';
                positions.forEach((player, index) => {
                    const progress = Math.floor(player.position);
                    const bar = 'â•'.repeat(Math.floor(progress / 5)) + 'ğŸï¸' + 'â”€'.repeat(20 - Math.floor(progress / 5));
                    raceField += `${index + 1}. ${player.name.padEnd(12)} ${bar} ${progress}%\n`;
                });
                raceField += '```';
                
                statusEmbed.addFields(
                    { name: 'ğŸï¸ ë ˆì´ìŠ¤ ì§„í–‰ ìƒí™©', value: raceField },
                    { name: 'ğŸ’° ì´ ìƒê¸ˆí’€', value: `${raceStatus.totalPot.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true }
                );
            } else {
                statusEmbed.setDescription('ğŸ”´ í˜„ì¬ ì§„í–‰ ì¤‘ì¸ ë ˆì´ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤.');
                
                if (raceStatus.players.length > 0) {
                    const playerList = raceStatus.players
                        .map((p, i) => `${i + 1}. ${p.name} - ${p.betAmount.toLocaleString()}G`)
                        .join('\n');
                    
                    statusEmbed.addFields(
                        { name: 'ğŸ‘¥ ëŒ€ê¸° ì¤‘ì¸ ì°¸ê°€ì', value: playerList || 'ì—†ìŒ' },
                        { name: 'ğŸ’° í˜„ì¬ ìƒê¸ˆí’€', value: `${raceStatus.totalPot.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true },
                        { name: 'ğŸ¯ ì°¸ê°€ì ìˆ˜', value: `${raceStatus.players.length}/${raceSystem.maxPlayers}ëª…`, inline: true }
                    );
                    
                    if (raceStatus.players.length >= raceSystem.minPlayers) {
                        statusEmbed.setFooter({ text: `${raceSystem.minPlayers}ëª…ì´ ëª¨ì´ë©´ ìë™ìœ¼ë¡œ ì‹œì‘ë©ë‹ˆë‹¤!` });
                    }
                } else {
                    statusEmbed.addFields(
                        { name: 'ğŸ“¢ ì•ˆë‚´', value: 'ë ˆì´ìŠ¤ì— ì°¸ê°€í•´ë³´ì„¸ìš”!' }
                    );
                }
            }
            
            const backButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('racing')
                        .setLabel('ğŸ”™ ëŒì•„ê°€ê¸°')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            await interaction.editReply({ 
                embeds: [statusEmbed], 
                components: [backButton] 
            });
        }
        
        // ë³´ìŠ¤ ì‹œìŠ¤í…œ í•¸ë“¤ëŸ¬
        else if (interaction.customId === 'boss_challenge') {
            // ë³´ìŠ¤ ë„ì „í•˜ê¸°
            if (!BOSS_SYSTEM.activeBoss) {
                await interaction.reply({ content: 'âŒ í˜„ì¬ í™œì„±í™”ëœ ë³´ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            // ë ˆë²¨ ì²´í¬
            if (user.level < BOSS_SYSTEM.activeBoss.requiredLevel) {
                await interaction.reply({ 
                    content: `âŒ ë ˆë²¨ì´ ë¶€ì¡±í•©ë‹ˆë‹¤! (ìš”êµ¬ ë ˆë²¨: ${BOSS_SYSTEM.activeBoss.requiredLevel})`, 
                    flags: 64 
                });
                return;
            }
            
            // ì´ë¯¸ ì°¸ê°€í–ˆëŠ”ì§€ ì²´í¬
            if (BOSS_SYSTEM.participants.has(interaction.user.id)) {
                await interaction.reply({ content: 'âœ… ì´ë¯¸ ë³´ìŠ¤ ë ˆì´ë“œì— ì°¸ê°€í•˜ì…¨ìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            // ì„œë²„ ë©¤ë²„ ì„ íƒ ë©”ë‰´ ìƒì„±
            const guild = interaction.guild;
            const members = await guild.members.fetch();
            
            // ë´‡ê³¼ ìì‹ ì„ ì œì™¸í•œ ì˜¨ë¼ì¸ ë©¤ë²„ë§Œ í•„í„°ë§
            const onlineMembers = members.filter(member => 
                !member.user.bot && 
                member.user.id !== interaction.user.id &&
                member.presence?.status !== 'offline'
            ).first(24); // ìµœëŒ€ 24ëª… (ì…€ë ‰íŠ¸ ë©”ë‰´ ì œí•œ)
            
            if (onlineMembers.length === 0) {
                // í˜¼ì ì°¸ê°€
                BOSS_SYSTEM.participants.add(interaction.user.id);
                await interaction.reply({ 
                    content: `âš”ï¸ **${user.nickname}**ë‹˜ì´ ë³´ìŠ¤ ë ˆì´ë“œì— ì°¸ê°€í–ˆìŠµë‹ˆë‹¤!\ní˜„ì¬ ì°¸ê°€ì: ${BOSS_SYSTEM.participants.size}ëª…`, 
                    flags: 64 
                });
                return;
            }
            
            const memberOptions = onlineMembers.map(member => ({
                label: member.user.username,
                description: member.nickname || 'íŒŒí‹° ì´ˆëŒ€',
                value: member.user.id,
                emoji: 'ğŸ‘¤'
            }));
            
            const partySelect = new StringSelectMenuBuilder()
                .setCustomId('boss_party_invite')
                .setPlaceholder('í•¨ê»˜ ë³´ìŠ¤ë¥¼ ì¡ì„ íŒŒí‹°ì›ì„ ì„ íƒí•˜ì„¸ìš” (ì„ íƒì‚¬í•­)')
                .setMinValues(0)
                .setMaxValues(Math.min(4, memberOptions.length)) // ìµœëŒ€ 4ëª…ê¹Œì§€ ì´ˆëŒ€
                .addOptions(memberOptions);
            
            const selectRow = new ActionRowBuilder().addComponents(partySelect);
            
            const skipButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('boss_solo_join')
                        .setLabel('ğŸ—¡ï¸ í˜¼ì ì°¸ê°€í•˜ê¸°')
                        .setStyle(ButtonStyle.Primary)
                );
            
            await interaction.reply({
                content: 'ğŸ‘¥ í•¨ê»˜ ë³´ìŠ¤ë¥¼ ì¡ì„ íŒŒí‹°ì›ì„ ì„ íƒí•˜ì„¸ìš”!',
                components: [selectRow, skipButton],
                flags: 64
            });
        }
        
        else if (interaction.customId === 'boss_solo_join') {
            // í˜¼ì ì°¸ê°€
            if (BOSS_SYSTEM.participants.has(interaction.user.id)) {
                await interaction.update({ 
                    content: 'âœ… ì´ë¯¸ ë³´ìŠ¤ ë ˆì´ë“œì— ì°¸ê°€í•˜ì…¨ìŠµë‹ˆë‹¤!', 
                    components: [] 
                });
                return;
            }
            
            BOSS_SYSTEM.participants.add(interaction.user.id);
            await interaction.update({ 
                content: `âš”ï¸ **${user.nickname}**ë‹˜ì´ ë³´ìŠ¤ ë ˆì´ë“œì— ì°¸ê°€í–ˆìŠµë‹ˆë‹¤!\ní˜„ì¬ ì°¸ê°€ì: ${BOSS_SYSTEM.participants.size}ëª…`, 
                components: [] 
            });
            
            // ì±„ë„ì—ë„ ì•Œë¦¼
            const bossChannel = client.channels.cache.get(BOSS_SYSTEM.activeBoss.channelId);
            if (bossChannel) {
                await bossChannel.send(`âš”ï¸ **${user.nickname}**ë‹˜ì´ ë³´ìŠ¤ ë ˆì´ë“œì— ì°¸ê°€í–ˆìŠµë‹ˆë‹¤! (ì°¸ê°€ì: ${BOSS_SYSTEM.participants.size}ëª…)`);
            }
        }
        
        else if (interaction.customId === 'boss_info') {
            // ë³´ìŠ¤ ì •ë³´ í‘œì‹œ
            if (!BOSS_SYSTEM.activeBoss) {
                await interaction.reply({ content: 'âŒ í˜„ì¬ í™œì„±í™”ëœ ë³´ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            const boss = BOSS_SYSTEM.activeBoss;
            const remainingTime = Math.max(0, boss.endTime - Date.now());
            const minutes = Math.floor(remainingTime / 60000);
            const seconds = Math.floor((remainingTime % 60000) / 1000);
            
            const infoEmbed = new EmbedBuilder()
                .setColor('#ff0000')
                .setTitle(`${boss.emoji} ${boss.name} ì •ë³´`)
                .setDescription(`ë ˆë²¨ ${boss.level} ë³´ìŠ¤`)
                .addFields(
                    { name: 'â¤ï¸ í˜„ì¬ HP', value: `${boss.currentHp.toLocaleString()} / ${boss.hp.toLocaleString()}`, inline: true },
                    { name: 'âš”ï¸ ê³µê²©ë ¥', value: `${boss.attack}`, inline: true },
                    { name: 'ğŸ›¡ï¸ ë°©ì–´ë ¥', value: `${boss.defense}`, inline: true },
                    { name: 'â±ï¸ ë‚¨ì€ ì‹œê°„', value: `${minutes}ë¶„ ${seconds}ì´ˆ`, inline: true },
                    { name: 'ğŸ‘¥ ì°¸ê°€ì', value: `${BOSS_SYSTEM.participants.size}ëª…`, inline: true },
                    { name: 'ğŸ¯ ìš”êµ¬ ë ˆë²¨', value: `${boss.requiredLevel}`, inline: true }
                )
                .addFields(
                    { 
                        name: 'ğŸ’€ ë³´ìŠ¤ ìŠ¤í‚¬', 
                        value: boss.skills.map(skill => `â€¢ **${skill.name}** (ë°ë¯¸ì§€: ${skill.damage || 'íŠ¹ìˆ˜'})`).join('\n'),
                        inline: false
                    },
                    {
                        name: 'ğŸ ì˜ˆìƒ ë³´ìƒ',
                        value: `â€¢ ê²½í—˜ì¹˜: ${boss.rewards.exp.toLocaleString()}\nâ€¢ ê³¨ë“œ: ${boss.rewards.gold.toLocaleString()}<:currency_emoji:1377404064316522778>\nâ€¢ íŠ¹ë³„ ì•„ì´í…œ ë“œë¡­ ê°€ëŠ¥`,
                        inline: false
                    }
                );
            
            await interaction.reply({ embeds: [infoEmbed], flags: 64 });
        }
        
        else if (interaction.customId === 'boss_participants') {
            // ì°¸ê°€ì ëª©ë¡
            if (!BOSS_SYSTEM.activeBoss) {
                await interaction.reply({ content: 'âŒ í˜„ì¬ í™œì„±í™”ëœ ë³´ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            if (BOSS_SYSTEM.participants.size === 0) {
                await interaction.reply({ content: 'ğŸ“‹ ì•„ì§ ì°¸ê°€ìê°€ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            const participantList = [];
            for (const userId of BOSS_SYSTEM.participants) {
                const participant = await User.findOne({ discordId: userId });
                if (participant) {
                    const damage = BOSS_SYSTEM.damageDealt.get(userId) || 0;
                    participantList.push(`â€¢ **${participant.nickname}** (Lv.${participant.level}) - ë°ë¯¸ì§€: ${damage.toLocaleString()}`);
                }
            }
            
            const listEmbed = new EmbedBuilder()
                .setColor('#0099ff')
                .setTitle('ğŸ‘¥ ë³´ìŠ¤ ë ˆì´ë“œ ì°¸ê°€ì')
                .setDescription(participantList.join('\n') || 'ì°¸ê°€ìê°€ ì—†ìŠµë‹ˆë‹¤.')
                .setFooter({ text: `ì´ ${BOSS_SYSTEM.participants.size}ëª… ì°¸ê°€ ì¤‘` });
            
            await interaction.reply({ embeds: [listEmbed], flags: 64 });
        }
        
        else if (interaction.customId === 'racing_stats') {
            // ê°œì¸ ë ˆì´ì‹± í†µê³„ í‘œì‹œ
            const stats = user.racingStats || {
                totalRaces: 0, wins: 0, totalWinnings: 0, totalSpent: 0,
                longestWinStreak: 0, currentWinStreak: 0, biggestWin: 0
            };
            
            const winRate = stats.totalRaces > 0 ? ((stats.wins / stats.totalRaces) * 100).toFixed(1) : '0.0';
            const profitLoss = stats.totalWinnings - stats.totalSpent;
            const profitRate = stats.totalSpent > 0 ? ((profitLoss / stats.totalSpent) * 100).toFixed(1) : '0.0';
            
            const statsEmbed = new EmbedBuilder()
                .setColor('#9B59B6')
                .setTitle(`ğŸ ${user.nickname}ë‹˜ì˜ ë ˆì´ì‹± í†µê³„`)
                .addFields(
                    { name: 'ğŸ† ì´ ê²½ê¸°', value: `${stats.totalRaces}íšŒ`, inline: true },
                    { name: 'ğŸ¥‡ ìš°ìŠ¹', value: `${stats.wins}íšŒ`, inline: true },
                    { name: 'ğŸ“Š ìŠ¹ë¥ ', value: `${winRate}%`, inline: true },
                    { name: 'ğŸ’° ì´ íšë“', value: `${stats.totalWinnings.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true },
                    { name: 'ğŸ’¸ ì´ ë² íŒ…', value: `${stats.totalSpent.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true },
                    { name: 'ğŸ“ˆ ì†ìµ', value: `${profitLoss >= 0 ? '+' : ''}${profitLoss.toLocaleString()}<:currency_emoji:1377404064316522778> (${profitRate >= 0 ? '+' : ''}${profitRate}%)`, inline: true },
                    { name: 'ğŸ”¥ ìµœì¥ ì—°ìŠ¹', value: `${stats.longestWinStreak}ì—°ìŠ¹`, inline: true },
                    { name: 'âš¡ í˜„ì¬ ì—°ìŠ¹', value: `${stats.currentWinStreak}ì—°ìŠ¹`, inline: true },
                    { name: 'ğŸ’ ìµœëŒ€ ìƒê¸ˆ', value: `${stats.biggestWin.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true }
                )
                .setFooter({ text: 'ğŸ² ìš´ì´ ì¢‹ì„ ë•Œë¥¼ ë…¸ë ¤ë³´ì„¸ìš”!' });
            
            await interaction.reply({ embeds: [statsEmbed], flags: 64 });
        }
        
        else if (interaction.customId === 'pvp_menu') {
            const user = await getUser(interaction.user.id);
            
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }

            const pvpInfo = await pvpSystem.getPVPInfo(user);
            
            const embed = new EmbedBuilder()
                .setColor('#ff6b6b')
                .setTitle('âš”ï¸ PVP ì•„ë ˆë‚˜')
                .setDescription('í”Œë ˆì´ì–´ë“¤ê³¼ ì¹˜ì—´í•œ ì „íˆ¬ë¥¼ ë²Œì—¬ë³´ì„¸ìš”!')
                .addFields(
                    { name: `${pvpInfo.tierEmoji} í‹°ì–´`, value: `${pvpInfo.tier}`, inline: true },
                    { name: 'ğŸ† ë ˆì´íŒ…', value: `${pvpInfo.rating}`, inline: true },
                    { name: 'ğŸ’³ ê²°íˆ¬ê¶Œ', value: `${pvpInfo.duelTickets}/20`, inline: true },
                    { name: 'ğŸ“Š ì „ì ', value: `${pvpInfo.wins}ìŠ¹ ${pvpInfo.losses}íŒ¨ (${pvpInfo.winRate}%)`, inline: true },
                    { name: 'ğŸ”¥ ì—°ìŠ¹', value: `${pvpInfo.winStreak}ì—°ìŠ¹`, inline: true },
                    { name: 'ğŸŒŸ ìµœê³  ë ˆì´íŒ…', value: `${pvpInfo.highestRating}`, inline: true }
                )
                .setFooter({ text: 'ê²°íˆ¬ê¶Œì€ 1ì‹œê°„ë§ˆë‹¤ 1ì¥ì”© ì¬ìƒì„±ë©ë‹ˆë‹¤!' });

            const pvpButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('start_pvp_duel')
                        .setLabel('âš”ï¸ ê²°íˆ¬ ì‹œì‘')
                        .setStyle(ButtonStyle.Danger)
                        .setDisabled(pvpInfo.duelTickets <= 0),
                    new ButtonBuilder()
                        .setCustomId('pvp_ranking')
                        .setLabel('ğŸ† PVP ë­í‚¹')
                        .setStyle(ButtonStyle.Secondary),
                    new ButtonBuilder()
                        .setCustomId('pvp_info')
                        .setLabel('ğŸ“Š ë‚´ PVP ì •ë³´')
                        .setStyle(ButtonStyle.Secondary)
                );

            const backButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('back_to_game_menu')
                        .setLabel('ğŸ® ê²Œì„ ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸°')
                        .setStyle(ButtonStyle.Success)
                );

            await interaction.reply({ 
                embeds: [embed], 
                components: [pvpButtons, backButton], 
                flags: 64 
            });
        }
        
        else if (interaction.customId === 'start_pvp_duel') {
            const user = await getUser(interaction.user.id);
            
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }

            const result = await pvpSystem.joinQueue(interaction.user.id, user, interaction.channel);
            
            if (result.success) {
                const embed = new EmbedBuilder()
                    .setColor('#ff6b6b')
                    .setTitle('âš”ï¸ PVP ë§¤ì¹˜ë©”ì´í‚¹')
                    .setDescription(result.message)
                    .addFields(
                        { name: 'ğŸ’³ ë³´ìœ  ê²°íˆ¬ê¶Œ', value: `${result.tickets || user.pvp.duelTickets}/20`, inline: true },
                        { name: 'ğŸ† í˜„ì¬ ë ˆì´íŒ…', value: `${user.pvp.rating} (${user.pvp.tier})`, inline: true }
                    )
                    .setFooter({ text: 'ë§¤ì¹˜ê°€ ì„±ì‚¬ë˜ë©´ ìë™ìœ¼ë¡œ ì „íˆ¬ê°€ ì‹œì‘ë©ë‹ˆë‹¤!' });

                const cancelButton = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('cancel_pvp_queue')
                            .setLabel('âŒ ë§¤ì¹˜ë©”ì´í‚¹ ì·¨ì†Œ')
                            .setStyle(ButtonStyle.Danger)
                    );

                await interaction.update({ 
                    embeds: [embed], 
                    components: [cancelButton]
                });
            } else {
                await interaction.reply({ content: `âŒ ${result.message}`, flags: 64 });
            }
        }
        
        else if (interaction.customId === 'pvp_ranking') {
            // PVP ë­í‚¹ í˜ì´ì§€ë¡œ ì´ë™
            await showRankingMenu(interaction, 4);
        }
        
        else if (interaction.customId === 'pvp_info') {
            const user = await getUser(interaction.user.id);
            
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }

            const pvpInfo = await pvpSystem.getPVPInfo(user);
            
            let matchHistoryText = '';
            if (pvpInfo.matchHistory.length > 0) {
                pvpInfo.matchHistory.slice(0, 5).forEach((match, index) => {
                    const resultEmoji = match.result === 'win' ? 'ğŸ†' : 'ğŸ’”';
                    const ratingText = match.ratingChange > 0 ? `+${match.ratingChange}` : `${match.ratingChange}`;
                    matchHistoryText += `${resultEmoji} vs ${match.opponent} (${ratingText})\n`;
                });
            } else {
                matchHistoryText = 'ì•„ì§ ê²°íˆ¬ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.';
            }

            const embed = new EmbedBuilder()
                .setColor('#ff6b6b')
                .setTitle(`âš”ï¸ ${user.nickname}ë‹˜ì˜ PVP ì •ë³´`)
                .addFields(
                    { name: `${pvpInfo.tierEmoji} í‹°ì–´`, value: `${pvpInfo.tier}`, inline: true },
                    { name: 'ğŸ† ë ˆì´íŒ…', value: `${pvpInfo.rating}`, inline: true },
                    { name: 'ğŸ’³ ê²°íˆ¬ê¶Œ', value: `${pvpInfo.duelTickets}/20`, inline: true },
                    { name: 'ğŸ“Š ì „ì ', value: `${pvpInfo.wins}ìŠ¹ ${pvpInfo.losses}íŒ¨ (${pvpInfo.winRate}%)`, inline: true },
                    { name: 'ğŸ”¥ ì—°ìŠ¹', value: `${pvpInfo.winStreak}ì—°ìŠ¹ (ìµœê³ : ${pvpInfo.maxWinStreak})`, inline: true },
                    { name: 'ğŸŒŸ ìµœê³  ë ˆì´íŒ…', value: `${pvpInfo.highestRating}`, inline: true },
                    { name: 'ğŸ“œ ìµœê·¼ ê²½ê¸°', value: matchHistoryText, inline: false }
                )
                .setFooter({ text: 'ê²°íˆ¬ê¶Œì€ 1ì‹œê°„ë§ˆë‹¤ 1ì¥ì”© ì¬ìƒì„±ë©ë‹ˆë‹¤!' });

            const backButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('pvp_menu')
                        .setLabel('ğŸ”™ PVP ë©”ë‰´')
                        .setStyle(ButtonStyle.Primary)
                );

            await interaction.update({ embeds: [embed], components: [backButton] });
        }
        
        else if (interaction.customId === 'cancel_pvp_queue') {
            const result = pvpSystem.leaveQueue(interaction.user.id);
            
            if (result.success) {
                await interaction.update({ 
                    content: `âœ… ${result.message}`, 
                    embeds: [], 
                    components: [] 
                });
            } else {
                await interaction.reply({ 
                    content: `âŒ ${result.message}`, 
                    flags: 64 
                });
            }
        }
        
        else if (interaction.customId === 'racing_ranking') {
            // ë ˆì´ì‹± ë­í‚¹ í˜ì´ì§€ë¡œ ì´ë™
            await showRankingMenu(interaction, 5);
        }
        
        else if (interaction.customId === 'back_to_inventory_menu') {
            // ì¸ë²¤í† ë¦¬ ë©”ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°
            await interaction.deferUpdate();
            
            const user = await getUser(interaction.user.id);
            if (!user) {
                return await interaction.editReply({ content: 'ìœ ì € ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!' });
            }
            
            const inventoryEmbed = new EmbedBuilder()
                .setColor('#8a2be2')
                .setTitle('ğŸ’ ì¸ë²¤í† ë¦¬')
                .setDescription(`ë³´ìœ ì¤‘ì¸ ì•„ì´í…œì„ í™•ì¸í•˜ì„¸ìš”\n\nğŸ”„ ìŠ¬ë¡¯: ${user.inventory.length}/${user.maxInventorySlots}`)
                .setFooter({ text: 'ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•˜ì—¬ ì•„ì´í…œì„ í™•ì¸í•˜ì„¸ìš”' });
            
            // ì¸ë²¤í† ë¦¬ ì¹´í…Œê³ ë¦¬ ë³„ ì•„ì´í…œ ìˆ˜ ê³„ì‚°
            const categoryCounts = {
                weapon: 0,
                armor: 0,
                helmet: 0,
                gloves: 0,
                boots: 0,
                accessory: 0,
                consumable: 0,
                coin: 0,
                scroll: 0
            };
            
            user.inventory.forEach(item => {
                if (categoryCounts[item.type] !== undefined) {
                    categoryCounts[item.type]++;
                }
            });
            
            // ì¸ë²¤í† ë¦¬ ì¹´í…Œê³ ë¦¬ ë“œë¡­ë‹¤ìš´
            const invOptions = [
                {
                    label: `âš”ï¸ ë¬´ê¸° (${categoryCounts.weapon}ê°œ)`,
                    description: 'ë³´ìœ í•œ ë¬´ê¸°ë¥¼ í™•ì¸í•©ë‹ˆë‹¤',
                    value: 'inv_weapon',
                    emoji: 'âš”ï¸'
                },
                {
                    label: `ğŸ›¡ï¸ ê°‘ì˜· (${categoryCounts.armor}ê°œ)`,
                    description: 'ë³´ìœ í•œ ê°‘ì˜·ì„ í™•ì¸í•©ë‹ˆë‹¤',
                    value: 'inv_armor',
                    emoji: 'ğŸ›¡ï¸'
                },
                {
                    label: `â›‘ï¸ í—¬ë©§ (${categoryCounts.helmet}ê°œ)`,
                    description: 'ë³´ìœ í•œ í—¬ë©‡ì„ í™•ì¸í•©ë‹ˆë‹¤',
                    value: 'inv_helmet',
                    emoji: 'â›‘ï¸'
                },
                {
                    label: `ğŸ§¬ ì¥ê°‘ (${categoryCounts.gloves}ê°œ)`,
                    description: 'ë³´ìœ í•œ ì¥ê°‘ì„ í™•ì¸í•©ë‹ˆë‹¤',
                    value: 'inv_gloves',
                    emoji: 'ğŸ§¬'
                },
                {
                    label: `ğŸ‘¢ ë¶€ì¸  (${categoryCounts.boots}ê°œ)`,
                    description: 'ë³´ìœ í•œ ë¶€ì¸ ë¥¼ í™•ì¸í•©ë‹ˆë‹¤',
                    value: 'inv_boots',
                    emoji: 'ğŸ‘¢'
                },
                {
                    label: `ğŸ’ ì•¡ì„¸ì„œë¦¬ (${categoryCounts.accessory}ê°œ)`,
                    description: 'ë³´ìœ í•œ ì•¡ì„¸ì„œë¦¬ë¥¼ í™•ì¸í•©ë‹ˆë‹¤',
                    value: 'inv_accessory',
                    emoji: 'ğŸ’'
                },
                {
                    label: `ğŸ“œ ì£¼ë¬¸ì„œ (${categoryCounts.scroll}ê°œ)`,
                    description: 'ë³´ìœ í•œ ì£¼ë¬¸ì„œë¥¼ í™•ì¸í•©ë‹ˆë‹¤',
                    value: 'inv_scroll',
                    emoji: 'ğŸ“œ'
                },
                {
                    label: `ğŸ§ª ì†Œë¹„ (${categoryCounts.consumable}ê°œ)`,
                    description: 'ë³´ìœ í•œ ì†Œë¹„ ì•„ì´í…œì„ í™•ì¸í•©ë‹ˆë‹¤',
                    value: 'inv_consumable',
                    emoji: 'ğŸ§ª'
                },
                {
                    label: `ğŸª™ ì½”ì¸ (${categoryCounts.coin}ê°œ)`,
                    description: 'ë³´ìœ í•œ ì½”ì¸ì„ í™•ì¸í•©ë‹ˆë‹¤',
                    value: 'inv_coin',
                    emoji: 'ğŸª™'
                }
            ];
            
            const invSelectMenu = new StringSelectMenuBuilder()
                .setCustomId('inventory_category_select')
                .setPlaceholder('ğŸ“¦ í™•ì¸í•  ì•„ì´í…œ ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•˜ì„¸ìš”')
                .addOptions(invOptions);
            
            const selectRow = new ActionRowBuilder().addComponents(invSelectMenu);
            
            const invButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('inventory_sort')
                        .setLabel('ğŸ”„ ì •ë ¬')
                        .setStyle(ButtonStyle.Secondary),
                    new ButtonBuilder()
                        .setCustomId('inventory_sell')
                        .setLabel('ğŸ’° íŒë§¤')
                        .setStyle(ButtonStyle.Danger),
                    new ButtonBuilder()
                        .setCustomId('back_to_game_menu')
                        .setLabel('ğŸ® ê²Œì„ ë©”ë‰´')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            await interaction.editReply({ 
                embeds: [inventoryEmbed], 
                components: [selectRow, invButtons] 
            });
        }
        
        else if (interaction.customId === 'back_to_game_menu') {
            // /ê²Œì„ ëª…ë ¹ì–´ì™€ ì™„ì „íˆ ë™ì¼í•œ ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸°
            // ì‹œê°„ëŒ€ë³„ ì´ë¯¸ì§€ ë° ì¸ì‚¬ë§ ì„¤ì •
            const now = new Date();
            const hour = now.getHours();
            
            let timeImage = '';
            let timeColor = '';
            
            if (hour >= 6 && hour < 12) {
                // ì•„ì¹¨ ì‹œê°„ëŒ€ (6:00 - 11:59)
                timeImage = 'kim_main_morning.png';
                timeColor = '#ffeb3b'; // ë…¸ë€ìƒ‰
            } else if (hour >= 12 && hour < 18) {
                // ì ì‹¬ ì‹œê°„ëŒ€ (12:00 - 17:59)
                timeImage = 'kim_main_lunch.png';
                timeColor = '#ff9800'; // ì£¼í™©ìƒ‰
            } else {
                // ì €ë…/ë°¤ ì‹œê°„ëŒ€ (18:00 - 5:59)
                timeImage = 'kim_main_night.png';
                timeColor = '#3f51b5'; // ë‚¨ìƒ‰
            }

            // ìƒíƒœì°½ (RPG ìŠ¤íƒ€ì¼)
            const greetings = [
                'ì˜¤ëŠ˜ë„ í˜ì°¨ê²Œ ëª¨í—˜ì„ ë– ë‚˜ë³¼ê¹Œìš”?',
                'ìƒˆë¡œìš´ í•˜ë£¨ê°€ ì‹œì‘ë˜ì—ˆë„¤ìš”!',
                'ëª¨í—˜ê°€ë‹˜, ì¤€ë¹„ëŠ” ë˜ì…¨ë‚˜ìš”?',
                'ì˜¤ëŠ˜ì€ ì–´ë–¤ ì¬ë¯¸ìˆëŠ” ì¼ì´ ìˆì„ê¹Œìš”?',
                'ê°•í™”ì™•ì˜ ì„¸ê³„ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!',
                'ë ˆë²¨ì—…ì„ í–¥í•´ ë‹¬ë ¤ê°€ë³¼ê¹Œìš”?',
                'ì˜¤ëŠ˜ë„ ì¢‹ì€ í•˜ë£¨ ë˜ì„¸ìš”!',
                'ëª¨í—˜ì´ ì—¬ëŸ¬ë¶„ì„ ê¸°ë‹¤ë¦¬ê³  ìˆì–´ìš”!',
                'í–‰ìš´ì´ í•¨ê»˜í•˜ê¸¸ ë°”ëë‹ˆë‹¤!',
                'ìƒˆë¡œìš´ ë„ì „ì´ ì‹œì‘ë©ë‹ˆë‹¤!'
            ];
            
            const randomGreeting = greetings[Math.floor(Math.random() * greetings.length)];
            
            // ê²½í—˜ì¹˜ ê³„ì‚° ìˆ˜ì • (ë ˆë²¨ì—… ì‹œ í•„ìš” ê²½í—˜ì¹˜ = ë ˆë²¨ * 100)
            const maxExp = user.level * 100;
            
            // ì¶œì„ í˜„í™© ê³„ì‚° (ì˜¤ëŠ˜ ì¶œì„ì²´í¬ ì—¬ë¶€)
            const today = new Date().toDateString();
            const attendanceStatus = user.lastDaily === today ? 'ì¶œì„' : 'ê²°ì„';

            const statusEmbed = new EmbedBuilder()
                .setColor(timeColor)
                .setTitle(`${getUserTitle(user)} ${user.nickname}ë‹˜, ${randomGreeting}`)
                .addFields(
                    { name: 'â­ ë ˆë²¨', value: `\`\`\`Lv.${user.level}\`\`\``, inline: true },
                    { name: 'âœ¨ ê²½í—˜ì¹˜', value: `\`\`\`${user.exp}/${maxExp}\`\`\``, inline: true },
                    { name: '<:currency_emoji:1377404064316522778> ê³¨ë“œ', value: `\`\`\`${user.gold.toLocaleString()}\`\`\``, inline: true },
                    { name: 'ğŸ“… ì¶œì„í˜„í™©', value: `\`\`\`${attendanceStatus}\`\`\``, inline: true },
                    { name: 'ğŸ† ì¢…í•©ìˆœìœ„', value: `\`\`\`ì¤€ë¹„ì¤‘\`\`\``, inline: true },
                    { name: 'ğŸ’– ì¸ê¸°ë„', value: `\`\`\`${user.popularity}\`\`\``, inline: true }
                )
                .setImage(`attachment://${timeImage}`)
                .setFooter({ text: 'ê²Œì„ ë©”ë‰´ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!' });

            // /ê²Œì„ ëª…ë ¹ì–´ì™€ ë™ì¼í•œ ì¹´í…Œê³ ë¦¬ ë©”ë‰´ ìƒì„±
            const mainMenu = createCategoryMenu();
            const menuRow = new ActionRowBuilder().addComponents(mainMenu);
            
            // ë¹ ë¥¸ ì ‘ê·¼ ë²„íŠ¼ë“¤ ì¶”ê°€ (/ê²Œì„ê³¼ ë™ì¼)
            const quickButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('daily')
                        .setLabel('ğŸ ì¼ì¼ë³´ìƒ')
                        .setStyle(ButtonStyle.Success),
                    new ButtonBuilder()
                        .setCustomId('hunting')
                        .setLabel('ğŸ¯ ì‚¬ëƒ¥í•˜ê¸°')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('equipment')
                        .setLabel('âš”ï¸ ì¥ë¹„ê´€ë¦¬')
                        .setStyle(ButtonStyle.Secondary),
                    new ButtonBuilder()
                        .setCustomId('shop')
                        .setLabel('ğŸ›’ ìƒì ')
                        .setStyle(ButtonStyle.Secondary)
                );
                
            const attachment = new AttachmentBuilder(path.join(__dirname, 'resource', timeImage), { name: timeImage });

            await interaction.update({ 
                embeds: [statusEmbed], 
                components: [menuRow, quickButtons], 
                files: [attachment] 
            });
        }
        
        // íšŒì›ê°€ì… ë²„íŠ¼ ì²˜ë¦¬
        else if (interaction.customId === 'register') {
            const modal = new ModalBuilder()
                .setCustomId('registerModal')
                .setTitle('ğŸ® ê¹€í—Œí„° íšŒì›ê°€ì…');
            
            const nicknameInput = new TextInputBuilder()
                .setCustomId('nickname')
                .setLabel('ë‹‰ë„¤ì„ì„ ì…ë ¥í•˜ì„¸ìš”')
                .setStyle(TextInputStyle.Short)
                .setPlaceholder('2-10ì ì‚¬ì´ì˜ ë‹‰ë„¤ì„')
                .setMinLength(2)
                .setMaxLength(10)
                .setRequired(true);
            
            const emailInput = new TextInputBuilder()
                .setCustomId('email')
                .setLabel('ì´ë©”ì¼ì„ ì…ë ¥í•˜ì„¸ìš”')
                .setStyle(TextInputStyle.Short)
                .setPlaceholder('example@email.com')
                .setRequired(true);
            
            modal.addComponents(
                new ActionRowBuilder().addComponents(nicknameInput),
                new ActionRowBuilder().addComponents(emailInput)
            );
            
            await interaction.showModal(modal);
        }
        
        else if (interaction.customId === 'game_page_1') {
            // game_page_1ë„ ë“œë¡­ë‹¤ìš´ ë©”ë‰´ ì‹œìŠ¤í…œìœ¼ë¡œ ë³€ê²½
            // ì‹œê°„ëŒ€ë³„ ì´ë¯¸ì§€ ë° ì¸ì‚¬ë§ ì„¤ì •
            const now = new Date();
            const hour = now.getHours();
            
            let timeImage = '';
            let timeColor = '';
            
            if (hour >= 6 && hour < 12) {
                timeImage = 'kim_main_morning.png';
                timeColor = '#ffeb3b';
            } else if (hour >= 12 && hour < 18) {
                timeImage = 'kim_main_lunch.png';
                timeColor = '#ff9800';
            } else {
                timeImage = 'kim_main_night.png';
                timeColor = '#3f51b5';
            }

            const greetings = [
                'ğŸŒŸ ê°•í™”ì™• ê¹€í—Œí„°ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!',
                'âš”ï¸ ì˜¤ëŠ˜ë„ ëª¨í—˜ì„ ë– ë‚  ì¤€ë¹„ê°€ ë˜ì…¨ë‚˜ìš”?',
                'ğŸ† ìƒˆë¡œìš´ ë„ì „ì´ ë‹¹ì‹ ì„ ê¸°ë‹¤ë¦¬ê³  ìˆìŠµë‹ˆë‹¤!',
                'ğŸ’ ìš´ëª…ì˜ ê°•í™”ì„ì´ ë‹¹ì‹ ì„ ë¶€ë¥´ê³  ìˆì–´ìš”!',
                'ğŸ¯ ëª©í‘œë¥¼ í–¥í•´ ì „ì§„í•˜ì„¸ìš”, ìš©ê°í•œ ëª¨í—˜ê°€!'
            ];
            
            const randomGreeting = greetings[Math.floor(Math.random() * greetings.length)];
            const user = await User.findOne({ discordId: interaction.user.id });
            const combatPower = calculateCombatPower(user);
            
            // ê²½í—˜ì¹˜ ê³„ì‚°
            const maxExp = user.level * 100;
            
            // ì¶œì„ í˜„í™© ê³„ì‚°
            const today = new Date().toDateString();
            const attendanceStatus = user.lastDaily === today ? 'ì¶œì„' : 'ê²°ì„';
            
            const statusEmbed = new EmbedBuilder()
                .setColor(timeColor)
                .setTitle(`${getUserTitle(user)} ${user.nickname}ë‹˜, ${randomGreeting}`)
                .addFields(
                    { name: 'â­ ë ˆë²¨', value: `\`\`\`Lv.${user.level}\`\`\``, inline: true },
                    { name: 'âœ¨ ê²½í—˜ì¹˜', value: `\`\`\`${user.exp}/${maxExp}\`\`\``, inline: true },
                    { name: '<:currency_emoji:1377404064316522778> ê³¨ë“œ', value: `\`\`\`${user.gold.toLocaleString()}\`\`\``, inline: true },
                    { name: 'ğŸ“… ì¶œì„í˜„í™©', value: `\`\`\`${attendanceStatus}\`\`\``, inline: true },
                    { name: 'ğŸ† ì¢…í•©ìˆœìœ„', value: `\`\`\`ì¤€ë¹„ì¤‘\`\`\``, inline: true },
                    { name: 'ğŸ’– ì¸ê¸°ë„', value: `\`\`\`${user.popularity}\`\`\``, inline: true }
                )
                .setImage(`attachment://${timeImage}`)
                .setFooter({ text: 'ê²Œì„ ë©”ë‰´ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!' });

            // ì»¤ìŠ¤í„°ë§ˆì´ì§•ëœ ë“œë¡­ë‹¤ìš´ ë©”ë‰´ ìƒì„± (/ê²Œì„ê³¼ ë™ì¼)
            const mainMenu = await createCustomizedMenu(interaction.user.id);
            const menuRow = new ActionRowBuilder().addComponents(mainMenu);
                
            const attachment = new AttachmentBuilder(path.join(__dirname, 'resource', timeImage), { name: timeImage });

            await interaction.update({ 
                embeds: [statusEmbed], 
                components: [menuRow], 
                files: [attachment] 
            });
        }
        
        // ğŸº ìœ ë¬¼íƒì‚¬ ë²„íŠ¼ í•¸ë“¤ëŸ¬ë“¤
        else if (interaction.customId === 'artifact_direct_explore') {
            const user = await getUser(interaction.user.id);
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            await showDirectExplorationMenu(interaction, user);
        }
        
        else if (interaction.customId === 'artifact_companies') {
            const user = await getUser(interaction.user.id);
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            // íƒì‚¬íšŒì‚¬ íˆ¬ì ë©”ë‰´ (ì£¼ì‹ ì‹œìŠ¤í…œê³¼ ì—°ë™)
            const companies = STOCK_MARKET.exploration_companies;
            
            let companyList = '';
            companies.forEach(company => {
                const changeIcon = company.change > 0 ? 'ğŸ“ˆ' : company.change < 0 ? 'ğŸ“‰' : 'â¡ï¸';
                const changeColor = company.change > 0 ? '+' : '';
                companyList += `ğŸ“Š **${company.name}**\n`;
                companyList += `   ì£¼ê°€: ${company.price.toLocaleString()}G ${changeIcon} ${changeColor}${company.change.toFixed(1)}%\n`;
                companyList += `   ê±°ë˜ëŸ‰: ${company.volume.toLocaleString()}\n\n`;
            });
            
            const embed = new EmbedBuilder()
                .setColor('#f39c12')
                .setTitle('ğŸ¢ ìœ ë¬¼íƒì‚¬íšŒì‚¬ íˆ¬ì')
                .setDescription('íƒì‚¬íšŒì‚¬ì— íˆ¬ìí•˜ì—¬ ìˆ˜ìµì„ ì–»ìœ¼ì„¸ìš”!\níƒì‚¬ ì„±ê³µ/ì‹¤íŒ¨ì— ë”°ë¼ ì£¼ê°€ê°€ ë³€ë™ë©ë‹ˆë‹¤.')
                .addFields(
                    { name: 'ğŸ“ˆ ìœ ë¬¼íƒì‚¬íšŒì‚¬ ì£¼ì‹', value: companyList, inline: false },
                    { name: 'ğŸ’¡ íˆ¬ì íŒ', value: 'â€¢ íƒì‚¬ ì„±ê³µ ì‹œ ì£¼ê°€ ìƒìŠ¹\nâ€¢ ë ˆì–´ ìœ ë¬¼ ë°œê²¬ ì‹œ ëŒ€í­ ìƒìŠ¹\nâ€¢ ì‹¤íŒ¨ ì‹œ ì£¼ê°€ í•˜ë½', inline: false }
                );

            const stockButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('stock_main')
                        .setLabel('ğŸ“Š ì£¼ì‹ ê±°ë˜ì†Œ')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('artifact_main_menu')
                        .setLabel('ğŸ”™ ìœ ë¬¼íƒì‚¬ ë©”ë‰´')
                        .setStyle(ButtonStyle.Secondary)
                );

            await interaction.update({
                embeds: [embed],
                components: [stockButton]
            });
        }
        
        else if (interaction.customId === 'artifact_inventory') {
            const user = await getUser(interaction.user.id);
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            const artifacts = user.artifacts || [];
            
            if (artifacts.length === 0) {
                const embed = new EmbedBuilder()
                    .setColor('#95a5a6')
                    .setTitle('ğŸ’ ìœ ë¬¼ ë³´ê´€í•¨')
                    .setDescription('ë³´ê´€ ì¤‘ì¸ ìœ ë¬¼ì´ ì—†ìŠµë‹ˆë‹¤.\n\nì§ì ‘ íƒì‚¬ë¥¼ í†µí•´ ìœ ë¬¼ì„ ë°œê²¬í•´ë³´ì„¸ìš”!')
                    .addFields(
                        { name: 'ğŸ’¡ ìœ ë¬¼ íšë“ ë°©ë²•', value: 'â›ï¸ ì§ì ‘ íƒì‚¬ë¥¼ í†µí•œ ë°œê²¬\nğŸ¢ íƒì‚¬íšŒì‚¬ íˆ¬ì ìˆ˜ìµ', inline: false }
                    );

                const backButton = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('artifact_main_menu')
                            .setLabel('ğŸ”™ ìœ ë¬¼íƒì‚¬ ë©”ë‰´')
                            .setStyle(ButtonStyle.Secondary)
                    );

                await interaction.update({
                    embeds: [embed],
                    components: [backButton]
                });
                return;
            }
            
            // ìœ ë¬¼ì„ ë“±ê¸‰ë³„ë¡œ ì •ë ¬
            const sortedArtifacts = artifacts.sort((a, b) => {
                const rarityOrder = { 'legendary': 4, 'epic': 3, 'rare': 2, 'common': 1 };
                return (rarityOrder[b.rarity] || 0) - (rarityOrder[a.rarity] || 0);
            });
            
            // í˜ì´ì§€ë„¤ì´ì…˜ (í•œ í˜ì´ì§€ì— 5ê°œ)
            const itemsPerPage = 5;
            const totalPages = Math.ceil(sortedArtifacts.length / itemsPerPage);
            const currentPage = 0;
            
            const startIndex = currentPage * itemsPerPage;
            const pageArtifacts = sortedArtifacts.slice(startIndex, startIndex + itemsPerPage);
            
            let artifactList = '';
            pageArtifacts.forEach((artifact, index) => {
                const date = new Date(artifact.foundDate).toLocaleDateString('ko-KR');
                const currentValue = calculateArtifactValue(artifact);
                const originalValue = artifact.value || 0;
                
                // NaN ë°©ì§€ë¥¼ ìœ„í•œ ì•ˆì „í•œ ê³„ì‚°
                let changePercent = '0';
                let changeIcon = 'â¡ï¸';
                
                if (originalValue > 0) {
                    const percentValue = ((currentValue - originalValue) / originalValue * 100);
                    changePercent = isNaN(percentValue) ? '0' : percentValue.toFixed(1);
                    changeIcon = currentValue > originalValue ? 'ğŸ“ˆ' : currentValue < originalValue ? 'ğŸ“‰' : 'â¡ï¸';
                }
                
                artifactList += `${artifact.emoji} **${artifact.name}** (${getRarityText(artifact.rarity)})\n`;
                artifactList += `   ğŸ’° ì‹œì¥ê°€: ${currentValue.toLocaleString()}G ${changeIcon} ${changePercent > 0 ? '+' : ''}${changePercent}%\n`;
                artifactList += `   ğŸ“Š ê¸°ì¤€ê°€: ${originalValue.toLocaleString()}G\n`;
                artifactList += `   ğŸ“… ë°œê²¬ì¼: ${date}`;
                if (artifact.company) artifactList += ` | ğŸ¢ ${artifact.company}`;
                artifactList += '\n\n';
            });
            
            // í†µê³„ ê³„ì‚° (í˜„ì¬ ì‹œì¥ ê°€ì¹˜ ê¸°ì¤€)
            const totalValue = artifacts.reduce((sum, artifact) => sum + calculateArtifactValue(artifact), 0);
            const originalTotalValue = artifacts.reduce((sum, artifact) => sum + (artifact.value || 0), 0);
            
            // NaN ë°©ì§€ë¥¼ ìœ„í•œ ì•ˆì „í•œ ê³„ì‚°
            let totalChangePercent = '0';
            if (originalTotalValue > 0) {
                const percentValue = ((totalValue - originalTotalValue) / originalTotalValue * 100);
                totalChangePercent = isNaN(percentValue) ? '0' : percentValue.toFixed(1);
            }
            const rarityCount = {
                common: artifacts.filter(a => a.rarity === 'common').length,
                rare: artifacts.filter(a => a.rarity === 'rare').length,
                epic: artifacts.filter(a => a.rarity === 'epic').length,
                legendary: artifacts.filter(a => a.rarity === 'legendary').length
            };
            
            const totalChangeIcon = totalValue > originalTotalValue ? 'ğŸ“ˆ' : totalValue < originalTotalValue ? 'ğŸ“‰' : 'â¡ï¸';
            
            const embed = new EmbedBuilder()
                .setColor('#e67e22')
                .setTitle('ğŸ’ ìœ ë¬¼ ë³´ê´€í•¨')
                .setDescription(`**${user.nickname}**ë‹˜ì˜ ìœ ë¬¼ ì»¬ë ‰ì…˜\n\nğŸ’° **ì´ ì‹œì¥ê°€ì¹˜**: ${totalValue.toLocaleString()}G ${totalChangeIcon} ${totalChangePercent > 0 ? '+' : ''}${totalChangePercent}%`)
                .addFields(
                    { name: 'ğŸ“Š ë³´ê´€ í˜„í™©', value: `ì´ ${artifacts.length}ê°œ | ğŸ“Š ê¸°ì¤€ê°€ì¹˜: ${originalTotalValue.toLocaleString()}G`, inline: false },
                    { name: 'ğŸ† ë“±ê¸‰ë³„ ë³´ìœ ëŸ‰', value: `ğŸ’› ì „ì„¤: ${rarityCount.legendary}ê°œ\nğŸ’œ ì—í”½: ${rarityCount.epic}ê°œ\nğŸ’™ í¬ê·€: ${rarityCount.rare}ê°œ\nğŸ¤ ì¼ë°˜: ${rarityCount.common}ê°œ`, inline: true },
                    { name: `ğŸ“œ ìœ ë¬¼ ëª©ë¡ (${currentPage + 1}/${totalPages})`, value: artifactList, inline: false }
                );

            const navButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('artifact_inv_prev')
                        .setLabel('â—€ ì´ì „')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(currentPage === 0),
                    new ButtonBuilder()
                        .setCustomId('artifact_inv_next')
                        .setLabel('ë‹¤ìŒ â–¶')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(currentPage >= totalPages - 1),
                    new ButtonBuilder()
                        .setCustomId('artifact_market_chart')
                        .setLabel('ğŸ“ˆ ì‹œì¥ ì°¨íŠ¸')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('artifact_my_charts')
                        .setLabel('ğŸ“Š ë‚´ ìœ ë¬¼ ì°¨íŠ¸')
                        .setStyle(ButtonStyle.Info),
                    new ButtonBuilder()
                        .setCustomId('artifact_shop')
                        .setLabel('ğŸª ìƒì ì—ì„œ íŒë§¤')
                        .setStyle(ButtonStyle.Success)
                );
                
            const menuButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('artifact_main_menu')
                        .setLabel('ğŸ”™ ë©”ë‰´')
                        .setStyle(ButtonStyle.Secondary)
                );

            await interaction.update({
                embeds: [embed],
                components: [navButtons, menuButtons]
            });
        }
        
        else if (interaction.customId === 'artifact_shop') {
            const user = await getUser(interaction.user.id);
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            const artifacts = user.artifacts || [];
            
            if (artifacts.length === 0) {
                await interaction.update({
                    content: 'íŒë§¤í•  ìœ ë¬¼ì´ ì—†ìŠµë‹ˆë‹¤! ë¨¼ì € íƒì‚¬ë¥¼ í†µí•´ ìœ ë¬¼ì„ ë°œê²¬í•´ë³´ì„¸ìš”.',
                    embeds: [],
                    components: []
                });
                return;
            }
            
            // íŒë§¤ ê°€ëŠ¥í•œ ìœ ë¬¼ ëª©ë¡
            let sellList = '';
            artifacts.forEach((artifact, index) => {
                const currentPrice = calculateArtifactValue(artifact);
                const basePrice = artifact.value || 0;
                
                // NaN ë°©ì§€ë¥¼ ìœ„í•œ ì•ˆì „í•œ ê³„ì‚°
                let changePercent = '0';
                let changeIcon = 'â¡ï¸';
                
                if (basePrice > 0) {
                    const percentValue = ((currentPrice - basePrice) / basePrice * 100);
                    changePercent = isNaN(percentValue) ? '0' : percentValue.toFixed(1);
                    changeIcon = currentPrice > basePrice ? 'ğŸ“ˆ' : currentPrice < basePrice ? 'ğŸ“‰' : 'â¡ï¸';
                }
                
                sellList += `${index + 1}. ${artifact.emoji} **${artifact.name}** (${getRarityText(artifact.rarity)})\n`;
                sellList += `   ğŸ’° íŒë§¤ê°€: ${currentPrice.toLocaleString()}G ${changeIcon} ${changePercent > 0 ? '+' : ''}${changePercent}%\n\n`;
            });
            
            const embed = new EmbedBuilder()
                .setColor('#2ecc71')
                .setTitle('ğŸª ìœ ë¬¼ ìƒì ')
                .setDescription(`**${user.nickname}**ë‹˜ì˜ ìœ ë¬¼ì„ íŒë§¤í•˜ì„¸ìš”!`)
                .addFields(
                    { name: 'ğŸ’° íŒë§¤ ê°€ëŠ¥ ìœ ë¬¼', value: sellList || 'íŒë§¤í•  ìœ ë¬¼ì´ ì—†ìŠµë‹ˆë‹¤.', inline: false },
                    { name: 'ğŸ’¡ íŒë§¤ ì•ˆë‚´', value: 'â€¢ ìœ ë¬¼ íŒë§¤ëŠ” ì¦‰ì‹œ ê³¨ë“œë¡œ ì „í™˜ë©ë‹ˆë‹¤\nâ€¢ í¬ê·€í• ìˆ˜ë¡ ë†’ì€ ê°€ê²©ì— íŒë§¤ë©ë‹ˆë‹¤\nâ€¢ íŒë§¤ëœ ìœ ë¬¼ì€ ë³µêµ¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤', inline: false }
                );

            // ìœ ë¬¼ì´ ìˆìœ¼ë©´ ì„ íƒ ë©”ë‰´ ìƒì„±
            if (artifacts.length > 0) {
                const selectOptions = artifacts.slice(0, 25).map((artifact, index) => {
                    const currentPrice = calculateArtifactValue(artifact);
                    const changePercent = ((currentPrice - artifact.value) / artifact.value * 100).toFixed(0);
                    const trend = currentPrice > artifact.value ? 'â†‘' : currentPrice < artifact.value ? 'â†“' : '';
                    
                    return {
                        label: `${artifact.name} (${currentPrice.toLocaleString()}G ${trend}${changePercent}%)`,
                        description: `${getRarityText(artifact.rarity)} - ${artifact.description.substring(0, 50)}`,
                        value: `sell_artifact_${index}`,
                        emoji: artifact.emoji
                    };
                });

                const selectMenu = new StringSelectMenuBuilder()
                    .setCustomId('sell_artifact_select')
                    .setPlaceholder('íŒë§¤í•  ìœ ë¬¼ì„ ì„ íƒí•˜ì„¸ìš”')
                    .addOptions(selectOptions);

                const selectRow = new ActionRowBuilder().addComponents(selectMenu);
                
                const backButton = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('artifact_inventory')
                            .setLabel('ğŸ’ ë³´ê´€í•¨')
                            .setStyle(ButtonStyle.Secondary),
                        new ButtonBuilder()
                            .setCustomId('artifact_main_menu')
                            .setLabel('ğŸ”™ ë©”ë‰´')
                            .setStyle(ButtonStyle.Secondary)
                    );

                await interaction.update({
                    embeds: [embed],
                    components: [selectRow, backButton]
                });
            }
        }
        
        else if (interaction.customId === 'artifact_market_chart') {
            const user = await getUser(interaction.user.id);
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            await interaction.deferUpdate();
            
            // ì‚¬ìš©ìê°€ ë³´ìœ í•œ ìœ ë¬¼ë“¤ì˜ ì‹œì„¸ ì°¨íŠ¸ í‘œì‹œ
            const artifacts = user.artifacts || [];
            if (artifacts.length === 0) {
                await interaction.editReply({
                    content: 'ë³´ìœ í•œ ìœ ë¬¼ì´ ì—†ì–´ ì‹œì„¸ë¥¼ í™•ì¸í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.',
                    embeds: [],
                    components: []
                });
                return;
            }
            
            // ê³ ìœ í•œ ìœ ë¬¼ íƒ€ì…ë³„ë¡œ ê·¸ë£¹í™”
            const uniqueArtifacts = new Map();
            artifacts.forEach(artifact => {
                if (!uniqueArtifacts.has(artifact.name)) {
                    uniqueArtifacts.set(artifact.name, {
                        ...artifact,
                        count: 1,
                        totalValue: calculateArtifactValue(artifact)
                    });
                } else {
                    const existing = uniqueArtifacts.get(artifact.name);
                    existing.count++;
                    existing.totalValue += calculateArtifactValue(artifact);
                }
            });
            
            // ì‹œì„¸ ì •ë³´ í…ìŠ¤íŠ¸ ìƒì„±
            let marketInfo = '';
            let totalCurrentValue = 0;
            let totalOriginalValue = 0;
            
            uniqueArtifacts.forEach((artifactData, name) => {
                const priceData = artifactMarket.priceHistory.get(name);
                if (priceData) {
                    const currentPrice = priceData.currentPrice;
                    // artifactData.valueê°€ ë°°ì—´ì´ ì•„ë‹ ìˆ˜ ìˆìœ¼ë¯€ë¡œ baseValueë¥¼ ì‚¬ìš©
                    const basePrice = artifactData.baseValue || artifactData.value || priceData.basePrice || 0;
                    
                    // NaN ë°©ì§€ë¥¼ ìœ„í•œ ì•ˆì „í•œ ê³„ì‚°
                    let changePercent = '0';
                    let trend = 'â¡ï¸';
                    
                    if (basePrice > 0) {
                        const percentValue = ((currentPrice - basePrice) / basePrice * 100);
                        changePercent = isNaN(percentValue) ? '0' : percentValue.toFixed(1);
                        trend = currentPrice > basePrice ? 'ğŸ“ˆ' : currentPrice < basePrice ? 'ğŸ“‰' : 'â¡ï¸';
                    }
                    
                    marketInfo += `${artifactData.emoji} **${name}** (x${artifactData.count})\n`;
                    marketInfo += `   í˜„ì¬ê°€: ${currentPrice.toLocaleString()}G ${trend} ${changePercent > 0 ? '+' : ''}${changePercent}%\n`;
                    marketInfo += `   ë³´ìœ  ê°€ì¹˜: ${(currentPrice * artifactData.count).toLocaleString()}G\n\n`;
                    
                    totalCurrentValue += currentPrice * artifactData.count;
                    totalOriginalValue += basePrice * artifactData.count;
                }
            });
            
            // NaN ë°©ì§€ë¥¼ ìœ„í•œ ì•ˆì „í•œ ì´ ë³€ë™ë¥  ê³„ì‚°
            let totalChangePercent = '0';
            if (totalOriginalValue > 0) {
                const percentValue = ((totalCurrentValue - totalOriginalValue) / totalOriginalValue * 100);
                totalChangePercent = isNaN(percentValue) ? '0' : percentValue.toFixed(1);
            }
            const marketEvent = artifactMarket.currentEvent;
            
            const embed = new EmbedBuilder()
                .setColor('#f39c12')
                .setTitle('ğŸ“ˆ ìœ ë¬¼ ì‹œì„¸ ì°¨íŠ¸')
                .setDescription(`**${user.nickname}**ë‹˜ì˜ ìœ ë¬¼ í¬íŠ¸í´ë¦¬ì˜¤`)
                .addFields(
                    { 
                        name: 'ğŸ’° ì´ í‰ê°€ì•¡', 
                        value: `${totalCurrentValue.toLocaleString()}G (${totalChangePercent > 0 ? '+' : ''}${totalChangePercent}%)`, 
                        inline: true 
                    },
                    { 
                        name: 'ğŸ“Š ë³´ìœ  ì¢…ë¥˜', 
                        value: `${uniqueArtifacts.size}ì¢…`, 
                        inline: true 
                    },
                    { 
                        name: 'ğŸ¯ ì´ ë³´ìœ ëŸ‰', 
                        value: `${artifacts.length}ê°œ`, 
                        inline: true 
                    }
                );
            
            if (marketEvent) {
                embed.addFields({
                    name: 'ğŸŒŸ ì‹œì¥ ì´ë²¤íŠ¸',
                    value: `**${marketEvent.name}**\n${marketEvent.description}\níš¨ê³¼: ì‹œì„¸ ${marketEvent.effect > 1 ? '+' : ''}${((marketEvent.effect - 1) * 100).toFixed(0)}%`,
                    inline: false
                });
            }
            
            embed.addFields({
                name: 'ğŸ“Š ë³´ìœ  ìœ ë¬¼ ì‹œì„¸',
                value: marketInfo || 'ì‹œì„¸ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.',
                inline: false
            });
            
            // ì‹œì„¸ ë³€ë™ íŒ
            const tips = [
                'ğŸ’¡ ìœ ë¬¼ ì‹œì„¸ëŠ” 10ë¶„ë§ˆë‹¤ ë³€ë™ë©ë‹ˆë‹¤.',
                'ğŸ’¡ ì‹œê°„ëŒ€ì— ë”°ë¼ ê±°ë˜ëŸ‰ì´ ë‹¬ë¼ì§‘ë‹ˆë‹¤.',
                'ğŸ’¡ íŠ¹ë³„ ì´ë²¤íŠ¸ ë°œìƒì‹œ ì‹œì„¸ê°€ í¬ê²Œ ë³€ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
                'ğŸ’¡ í¬ê·€ë„ê°€ ë†’ì„ìˆ˜ë¡ ë³€ë™í­ì´ í½ë‹ˆë‹¤.'
            ];
            embed.setFooter({ text: tips[Math.floor(Math.random() * tips.length)] });
            
            const buttons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('artifact_inventory')
                        .setLabel('ğŸ’ ë³´ê´€í•¨ìœ¼ë¡œ')
                        .setStyle(ButtonStyle.Secondary),
                    new ButtonBuilder()
                        .setCustomId('artifact_shop')
                        .setLabel('ğŸª íŒë§¤í•˜ê¸°')
                        .setStyle(ButtonStyle.Success),
                    new ButtonBuilder()
                        .setCustomId('artifact_main_menu')
                        .setLabel('ğŸ”™ ë©”ë‰´')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            await interaction.editReply({
                embeds: [embed],
                components: [buttons]
            });
        }
        
        else if (interaction.customId === 'artifact_main_menu') {
            const user = await getUser(interaction.user.id);
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            await showArtifactExplorationMenu(interaction, user);
        }
        
        else if (interaction.customId === 'artifact_rankings') {
            // ìœ ë¬¼ ë­í‚¹ í˜ì´ì§€ë¡œ ì´ë™
            await showRankingMenu(interaction, 8);
        }
        
        else if (interaction.customId === 'artifact_guide') {
            const user = await getUser(interaction.user.id);
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            const embed = new EmbedBuilder()
                .setColor('#3498db')
                .setTitle('ğŸ“– ìœ ë¬¼íƒì‚¬ ì™„ì „ ê°€ì´ë“œ')
                .setDescription('ìœ ë¬¼íƒì‚¬ì˜ ëª¨ë“  ê²ƒì„ ì•Œë ¤ë“œë¦½ë‹ˆë‹¤!')
                .addFields(
                    { 
                        name: 'â›ï¸ ì§ì ‘ íƒì‚¬', 
                        value: 'â€¢ íƒì‚¬íšŒì‚¬ë¥¼ ì„ íƒí•˜ì—¬ ì§ì ‘ íˆ¬ì\nâ€¢ íˆ¬ì ê¸ˆì•¡ì´ í´ìˆ˜ë¡ ì„±ê³µë¥ ê³¼ ë³´ìƒ ì¦ê°€\nâ€¢ ì„±ê³µ ì‹œ ìœ ë¬¼ íšë“, ì‹¤íŒ¨ ì‹œ ê³¨ë“œ ì†ì‹¤', 
                        inline: false 
                    },
                    { 
                        name: 'ğŸ¢ íƒì‚¬íšŒì‚¬ íˆ¬ì', 
                        value: 'â€¢ íƒì‚¬íšŒì‚¬ ì£¼ì‹ì— íˆ¬ìí•˜ì—¬ ìˆ˜ìµ ì°½ì¶œ\nâ€¢ íƒì‚¬ ì„±ê³µ/ì‹¤íŒ¨ì— ë”°ë¼ ì£¼ê°€ ë³€ë™\nâ€¢ ë ˆì–´ ìœ ë¬¼ ë°œê²¬ ì‹œ ì£¼ê°€ ëŒ€í­ ìƒìŠ¹', 
                        inline: false 
                    },
                    { 
                        name: 'ğŸ’ ìœ ë¬¼ ë“±ê¸‰', 
                        value: 'ğŸ¤ **ì¼ë°˜** (70%) - ê¸°ë³¸ ìœ ë¬¼\nğŸ’™ **í¬ê·€** (20%) - ì¤‘ê¸‰ ê°€ì¹˜\nğŸ’œ **ì—í”½** (8%) - ê³ ê¸‰ ê°€ì¹˜\nğŸ’› **ì „ì„¤** (2%) - ìµœê³  ê°€ì¹˜', 
                        inline: false 
                    },
                    { 
                        name: 'ğŸ—ºï¸ íƒì‚¬ ì§€ì—­', 
                        value: 'ğŸœï¸ **ì‚¬ë§‰** - ì•ˆì •ì , ë‚®ì€ ìœ„í—˜\nğŸŒŠ **ì‹¬í•´** - ê³ ìœ„í—˜ ê³ ìˆ˜ìµ\nâ›°ï¸ **ì„¤ì‚°** - ê· í˜•ì¡íŒ ìˆ˜ìµ\nğŸŒ´ **ì •ê¸€** - ë†’ì€ ì„±ê³µë¥ \nğŸš€ **ìš°ì£¼** - ìµœê³  ë‚œì´ë„, ìµœê³  ë³´ìƒ', 
                        inline: false 
                    },
                    { 
                        name: 'ğŸ’¡ ì„±ê³µ íŒ', 
                        value: 'â€¢ ì‹œì‘ì€ ì •ê¸€ì´ë‚˜ ì‚¬ë§‰ íƒì‚¬ë¡œ!\nâ€¢ íˆ¬ì ê¸ˆì•¡ì„ ì ì§„ì ìœ¼ë¡œ ëŠ˜ë ¤ê°€ì„¸ìš”\nâ€¢ íƒì‚¬íšŒì‚¬ ì£¼ì‹ë„ í•¨ê»˜ íˆ¬ìí•˜ì„¸ìš”\nâ€¢ ìœ ë¬¼ì€ ì ì ˆí•œ íƒ€ì´ë°ì— íŒë§¤í•˜ì„¸ìš”', 
                        inline: false 
                    }
                );

            const backButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('artifact_main_menu')
                        .setLabel('ğŸ”™ ìœ ë¬¼íƒì‚¬ ë©”ë‰´')
                        .setStyle(ButtonStyle.Primary)
                );

            await interaction.update({
                embeds: [embed],
                components: [backButton]
            });
        }
        
        else if (interaction.customId === 'artifact_market_chart') {
            const user = await getUser(interaction.user.id);
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            await interaction.deferUpdate();
            
            try {
                // ìœ ë¬¼ ì‹œì¥ ì°¨íŠ¸ ìƒì„±
                const marketChartUrl = await generateArtifactChart('market');
                const individualChartUrl = await generateArtifactChart('individual');
                
                if (!marketChartUrl) {
                    await interaction.editReply({
                        content: 'âŒ ìœ ë¬¼ ì‹œì¥ ë°ì´í„°ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
                        embeds: [],
                        components: []
                    });
                    return;
                }
                
                // í˜„ì¬ ì‹œì¥ ìƒí™© ë¶„ì„
                const artifactMarket = STOCK_MARKET.artifact_market;
                const multipliers = Object.values(artifactMarket.value_multipliers);
                const averageMultiplier = multipliers.reduce((sum, m) => sum + m, 0) / multipliers.length;
                const marketTrend = averageMultiplier > 1.0 ? 'ìƒìŠ¹' : averageMultiplier < 1.0 ? 'í•˜ë½' : 'ë³´í•©';
                const trendIcon = averageMultiplier > 1.0 ? 'ğŸ“ˆ' : averageMultiplier < 1.0 ? 'ğŸ“‰' : 'â¡ï¸';
                
                // ìƒìœ„ ë³€ë™ ìœ ë¬¼ë“¤
                const topGainers = Object.entries(artifactMarket.value_multipliers)
                    .filter(([name, multiplier]) => multiplier > 1.0)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 3);
                
                const topLosers = Object.entries(artifactMarket.value_multipliers)
                    .filter(([name, multiplier]) => multiplier < 1.0)
                    .sort(([,a], [,b]) => a - b)
                    .slice(0, 3);
                
                let marketAnalysis = `${trendIcon} **ì‹œì¥ ë™í–¥**: ${marketTrend} (í‰ê·  ${(averageMultiplier * 100).toFixed(1)}%)\n\n`;
                
                if (topGainers.length > 0) {
                    marketAnalysis += `ğŸ“ˆ **ìƒìŠ¹ ìœ ë¬¼**:\n`;
                    topGainers.forEach(([name, multiplier]) => {
                        marketAnalysis += `â€¢ ${name}: +${((multiplier - 1) * 100).toFixed(1)}%\n`;
                    });
                    marketAnalysis += '\n';
                }
                
                if (topLosers.length > 0) {
                    marketAnalysis += `ğŸ“‰ **í•˜ë½ ìœ ë¬¼**:\n`;
                    topLosers.forEach(([name, multiplier]) => {
                        marketAnalysis += `â€¢ ${name}: ${((multiplier - 1) * 100).toFixed(1)}%\n`;
                    });
                }
                
                // í™œì„± ì´ë²¤íŠ¸ í‘œì‹œ
                let activeEvents = '';
                if (artifactMarket.active_events.length > 0) {
                    activeEvents = '\nğŸ‰ **í™œì„± ì´ë²¤íŠ¸**:\n';
                    artifactMarket.active_events.forEach(event => {
                        const remainingTime = Math.max(0, event.start_time + event.duration - Date.now());
                        const hours = Math.floor(remainingTime / (60 * 60 * 1000));
                        const minutes = Math.floor((remainingTime % (60 * 60 * 1000)) / (60 * 1000));
                        activeEvents += `â€¢ ${event.name} (${hours}ì‹œê°„ ${minutes}ë¶„ ë‚¨ìŒ)\n`;
                    });
                }
                
                const embed = new EmbedBuilder()
                    .setColor('#f39c12')
                    .setTitle('ğŸ“ˆ ìœ ë¬¼ ì‹œì¥ ì°¨íŠ¸')
                    .setDescription('ì‹¤ì‹œê°„ ìœ ë¬¼ ì‹œì¥ ë™í–¥ì„ í™•ì¸í•˜ì„¸ìš”!')
                    .setImage(marketChartUrl)
                    .addFields(
                        { name: 'ğŸ“Š ì‹œì¥ ë¶„ì„', value: marketAnalysis + activeEvents, inline: false }
                    )
                    .setFooter({ text: `ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: ${new Date().toLocaleTimeString('ko-KR')} | 5ë¶„ë§ˆë‹¤ ìë™ ì—…ë°ì´íŠ¸` });

                const chartButtons = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('artifact_chart_individual')
                            .setLabel('ğŸ’ ê°œë³„ ìœ ë¬¼ ì°¨íŠ¸')
                            .setStyle(ButtonStyle.Primary)
                            .setDisabled(!individualChartUrl),
                        new ButtonBuilder()
                            .setCustomId('artifact_inventory')
                            .setLabel('ğŸ’ ë³´ê´€í•¨')
                            .setStyle(ButtonStyle.Secondary),
                        new ButtonBuilder()
                            .setCustomId('artifact_main_menu')
                            .setLabel('ğŸ”™ ë©”ë‰´')
                            .setStyle(ButtonStyle.Secondary)
                    );

                await interaction.editReply({
                    embeds: [embed],
                    components: [chartButtons]
                });
                
            } catch (error) {
                console.error('ìœ ë¬¼ ì‹œì¥ ì°¨íŠ¸ ì˜¤ë¥˜:', error);
                await interaction.editReply({
                    content: 'âŒ ì°¨íŠ¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
                    embeds: [],
                    components: []
                });
            }
        }
        
        else if (interaction.customId === 'artifact_my_charts') {
            const user = await getUser(interaction.user.id);
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            const artifacts = user.artifacts || [];
            
            if (artifacts.length === 0) {
                await interaction.update({
                    content: 'ë³´ìœ í•œ ìœ ë¬¼ì´ ì—†ìŠµë‹ˆë‹¤! ë¨¼ì € íƒì‚¬ë¥¼ í†µí•´ ìœ ë¬¼ì„ ë°œê²¬í•´ë³´ì„¸ìš”.',
                    embeds: [],
                    components: []
                });
                return;
            }
            
            // ìœ ë¬¼ë³„ ê°€ê²© ë³€ë™ ì°¨íŠ¸ ìƒì„±
            let chartText = '```\n';
            chartText += 'ìœ ë¬¼ë³„ ê°€ê²© ë³€ë™ ì°¨íŠ¸\n';
            chartText += 'â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n';
            
            artifacts.forEach((artifact, index) => {
                chartText += `${index + 1}. ${artifact.emoji} ${artifact.name}\n`;
                chartText += `   ë“±ê¸‰: ${artifact.rarity} | ë°œê²¬ì¼: ${new Date(artifact.foundDate).toLocaleDateString()}\n`;
                
                // ìµœê·¼ 5ê°œ ê°€ê²© ê¸°ë¡ë§Œ í‘œì‹œ
                const recentPrices = artifact.priceHistory.slice(-5);
                if (recentPrices.length > 0) {
                    chartText += '   ê°€ê²© ì¶”ì´: ';
                    const maxPrice = Math.max(...recentPrices.map(p => p.price));
                    const minPrice = Math.min(...recentPrices.map(p => p.price));
                    const range = maxPrice - minPrice || 1;
                    
                    recentPrices.forEach((priceData, i) => {
                        const normalized = ((priceData.price - minPrice) / range) * 5;
                        const bar = 'â–â–‚â–ƒâ–„â–…'[Math.floor(normalized)];
                        chartText += bar;
                    });
                    
                    const currentPrice = calculateArtifactValue(artifact);
                    const lastPrice = recentPrices[recentPrices.length - 1].price;
                    const change = ((currentPrice - lastPrice) / lastPrice * 100).toFixed(1);
                    chartText += ` ${currentPrice}G (${change > 0 ? '+' : ''}${change}%)\n`;
                } else {
                    chartText += '   ê°€ê²© ê¸°ë¡ ì—†ìŒ\n';
                }
                chartText += '\n';
            });
            
            chartText += '```';
            
            const chartEmbed = new EmbedBuilder()
                .setColor('#3498db')
                .setTitle('ğŸ“Š ë‚´ ìœ ë¬¼ ê°€ê²© ì°¨íŠ¸')
                .setDescription(chartText)
                .addFields(
                    { name: 'ğŸ“ˆ ì´ ë³´ìœ  ìœ ë¬¼', value: `${artifacts.length}ê°œ`, inline: true },
                    { name: 'ğŸ’° ì´ ê°€ì¹˜', value: `${artifacts.reduce((sum, a) => sum + calculateArtifactValue(a), 0).toLocaleString()}G`, inline: true }
                )
                .setFooter({ text: 'ê°€ê²©ì€ ì‹¤ì‹œê°„ìœ¼ë¡œ ë³€ë™ë©ë‹ˆë‹¤' });
            
            const backButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('artifact_inventory')
                        .setLabel('ğŸ”™ ë³´ê´€í•¨ìœ¼ë¡œ')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            await interaction.update({
                embeds: [chartEmbed],
                components: [backButton]
            });
        }
        
        else if (interaction.customId === 'artifact_chart_individual') {
            await interaction.deferUpdate();
            
            try {
                const individualChartUrl = await generateArtifactChart('individual');
                
                if (!individualChartUrl) {
                    await interaction.editReply({
                        content: 'âŒ ê°œë³„ ìœ ë¬¼ ì°¨íŠ¸ ë°ì´í„°ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.',
                        embeds: [],
                        components: []
                    });
                    return;
                }
                
                const embed = new EmbedBuilder()
                    .setColor('#9b59b6')
                    .setTitle('ğŸ’ ì£¼ìš” ìœ ë¬¼ ê°€ì¹˜ ë³€ë™ ì°¨íŠ¸')
                    .setDescription('ìƒìœ„ ìœ ë¬¼ë“¤ì˜ ê°œë³„ ê°€ì¹˜ ë³€ë™ì„ í™•ì¸í•˜ì„¸ìš”!')
                    .setImage(individualChartUrl)
                    .setFooter({ text: `ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: ${new Date().toLocaleTimeString('ko-KR')} | ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸` });

                const backButtons = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('artifact_market_chart')
                            .setLabel('ğŸ“ˆ ì‹œì¥ ì§€ìˆ˜ ì°¨íŠ¸')
                            .setStyle(ButtonStyle.Primary),
                        new ButtonBuilder()
                            .setCustomId('artifact_inventory')
                            .setLabel('ğŸ’ ë³´ê´€í•¨')
                            .setStyle(ButtonStyle.Secondary),
                        new ButtonBuilder()
                            .setCustomId('artifact_main_menu')
                            .setLabel('ğŸ”™ ë©”ë‰´')
                            .setStyle(ButtonStyle.Secondary)
                    );

                await interaction.editReply({
                    embeds: [embed],
                    components: [backButtons]
                });
                
            } catch (error) {
                console.error('ê°œë³„ ìœ ë¬¼ ì°¨íŠ¸ ì˜¤ë¥˜:', error);
                await interaction.editReply({
                    content: 'âŒ ê°œë³„ ì°¨íŠ¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
                    embeds: [],
                    components: []
                });
            }
        }
        
        // íƒì‚¬íšŒì‚¬ë³„ ì§ì ‘ íƒì‚¬ ë²„íŠ¼ë“¤
        else if (interaction.customId.startsWith('explore_')) {
            const companyId = interaction.customId.replace('explore_', '');
            const company = ARTIFACT_SYSTEM.companies[companyId];
            
            if (!company) {
                await interaction.followUp({ content: 'âŒ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” íƒì‚¬íšŒì‚¬ì…ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            const user = await getUser(interaction.user.id);
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            // íˆ¬ì ê¸ˆì•¡ ì…ë ¥ ëª¨ë‹¬ í‘œì‹œ
            const investModal = new ModalBuilder()
                .setCustomId(`invest_modal_${companyId}`)
                .setTitle(`${company.emoji} ${company.name} íƒì‚¬ íˆ¬ì`);
            
            const costs = ARTIFACT_SYSTEM.explorationCosts[company.specialty];
            const investInput = new TextInputBuilder()
                .setCustomId('investment_amount')
                .setLabel('íˆ¬ì ê¸ˆì•¡')
                .setStyle(TextInputStyle.Short)
                .setPlaceholder(`${costs.min.toLocaleString()} ~ ${costs.max.toLocaleString()}G`)
                .setRequired(true)
                .setMaxLength(10);
            
            const firstActionRow = new ActionRowBuilder().addComponents(investInput);
            investModal.addComponents(firstActionRow);
            
            await interaction.showModal(investModal);
        }
        
    } catch (error) {
        console.error('ì¸í„°ë ‰ì…˜ ì²˜ë¦¬ ì˜¤ë¥˜:', error);
    }
});

// Modal ì œì¶œ ì²˜ë¦¬
client.on('interactionCreate', async (interaction) => {
    if (!interaction.isModalSubmit()) return;
    
    console.log('ğŸ”µ ëª¨ë‹¬ ì œì¶œë¨:', interaction.customId);
    
    // ìš´ë™ ì‹œê°„ ì„¤ì • ëª¨ë‹¬
    if (interaction.customId.startsWith('exercise_modal_')) {
        const exerciseId = interaction.customId.replace('exercise_modal_', '');
        const durationInput = interaction.fields.getTextInputValue('duration');
        const duration = parseInt(durationInput);
        
        const exercise = EXERCISE_SYSTEM.exercises[exerciseId];
        if (!exercise) {
            await interaction.reply({ content: 'ìš´ë™ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
            return;
        }
        
        const maxMinutes = Math.floor(exercise.maxDuration / 60000);
        if (isNaN(duration) || duration < 1 || duration > maxMinutes) {
            await interaction.reply({ content: `ìš´ë™ ì‹œê°„ì€ 1ë¶„ì—ì„œ ${maxMinutes}ë¶„ ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤!`, flags: 64 });
            return;
        }
        
        const user = await getUser(interaction.user.id);
        if (!user || !user.registered) {
            await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
            return;
        }
        
        // í”¼ë¡œë„ í™•ì¸
        if (user.fitness.fatigue >= EXERCISE_SYSTEM.fatigue.exerciseLimit) {
            await interaction.reply({ content: 'í”¼ë¡œë„ê°€ ë„ˆë¬´ ë†’ì•„ ìš´ë™í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤! íœ´ì‹ì´ í•„ìš”í•©ë‹ˆë‹¤.', flags: 64 });
            return;
        }
        
        // ì´ë¯¸ ìš´ë™ ì¤‘ì¸ì§€ í™•ì¸
        if (user.fitness.currentExercise.type) {
            await interaction.reply({ content: 'ì´ë¯¸ ìš´ë™ ì¤‘ì…ë‹ˆë‹¤!', flags: 64 });
            return;
        }
        
        // ìš´ë™ ì‹œì‘
        const now = Date.now();
        const durationMs = duration * 60000;
        
        user.fitness.currentExercise = {
            type: exerciseId,
            startTime: now,
            duration: durationMs,
            accumulated: 0
        };
        
        // ì—°ì† ìš´ë™ ì²´í¬
        const today = new Date().toDateString();
        const yesterday = new Date(Date.now() - 86400000).toDateString();
        
        if (user.fitness.lastExerciseDate !== today) {
            if (user.fitness.lastExerciseDate === yesterday) {
                user.fitness.streak += 1;
            } else {
                user.fitness.streak = 1;
            }
            user.fitness.lastExerciseDate = today;
        }
        
        await user.save();
        
        // ìš´ë™ ì‹œì‘ ì„ë² ë“œ
        const embed = new EmbedBuilder()
            .setColor('#00b894')
            .setTitle(`${exercise.emoji} ${exercise.name} ì‹œì‘!`)
            .setDescription(`**${user.nickname}**ë‹˜ì´ ìš´ë™ì„ ì‹œì‘í–ˆìŠµë‹ˆë‹¤!`)
            .addFields(
                { name: 'â±ï¸ ìš´ë™ ì‹œê°„', value: `${duration}ë¶„`, inline: true },
                { name: 'ğŸ ì™„ë£Œ ì˜ˆì •', value: `<t:${Math.floor((now + durationMs) / 1000)}:R>`, inline: true },
                { name: 'ğŸ”¥ ì—°ì† ìš´ë™', value: `${user.fitness.streak}ì¼`, inline: true },
                { name: 'ğŸ’° ì˜ˆìƒ ë³´ìƒ', value: `ê³¨ë“œ: ~${(exercise.rewards.goldPerMinute * duration).toLocaleString()}G\nê²½í—˜ì¹˜: ~${(exercise.rewards.expPerMinute * duration).toLocaleString()} EXP`, inline: false }
            )
            .setFooter({ text: 'ìš´ë™ì´ ëë‚˜ë©´ ë‹¤ì‹œ ìš´ë™ ë©”ë‰´ë¥¼ ì—´ì–´ ë³´ìƒì„ í™•ì¸í•˜ì„¸ìš”!' });
        
        const backButton = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('work')
                    .setLabel('ğŸƒ ìš´ë™ ìƒíƒœ í™•ì¸')
                    .setStyle(ButtonStyle.Primary)
            );
        
        await interaction.reply({
            embeds: [embed],
            components: [backButton]
        });
        
        // í”¼ë¡œë„ ì¦ê°€ (ì‹œì‘ì‹œ ì¼ë¶€ë§Œ ì¦ê°€)
        const fatigueIncrease = Math.floor(exercise.fatigueRate * duration * 0.5);
        user.fitness.fatigue = Math.min(100, user.fitness.fatigue + fatigueIncrease);
        await user.save();
    }
    
    else if (interaction.customId === 'registerModal') {
        const nickname = interaction.fields.getTextInputValue('nickname');
        const email = interaction.fields.getTextInputValue('email');
        
        try {
            const user = await User.findOne({ discordId: interaction.user.id });
            if (!user) {
                await interaction.reply({ content: 'ë“±ë¡ë˜ì§€ ì•Šì€ ì‚¬ìš©ìì…ë‹ˆë‹¤. ë¨¼ì € /ê°€ì… ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•´ ê°€ì…í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }

            // ì´ë¯¸ íšŒì›ê°€ì… í–ˆëŠ”ì§€ í™•ì¸
            if (user.registered) {
                await interaction.editReply({ content: 'ì´ë¯¸ íšŒì›ê°€ì…ì„ ì™„ë£Œí•˜ì…¨ìŠµë‹ˆë‹¤!' });
                return;
            }

            // ë‹‰ë„¤ì„ ì¤‘ë³µ ì²´í¬
            const existingUser = await User.findOne({ nickname });
            if (existingUser) {
                await interaction.editReply({ content: 'ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ë‹‰ë„¤ì„ì…ë‹ˆë‹¤!' });
                return;
            }

            // ì´ë©”ì¼ í˜•ì‹ ê²€ì¦
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(email)) {
                await interaction.editReply({ content: 'ì˜¬ë°”ë¥¸ ì´ë©”ì¼ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤!' });
                return;
            }

            // ì¸ì¦ì½”ë“œ ìƒì„± ë° ì €ì¥
            const verificationCode = generateVerificationCode();
            const expiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10ë¶„ í›„ ë§Œë£Œ

            user.nickname = nickname;
            user.email = email;
            user.emailVerificationCode = verificationCode;
            user.emailVerificationExpires = expiresAt;
            
            await user.save();

            // ì´ë©”ì¼ ì „ì†¡
            try {
                await sendVerificationEmail(email, verificationCode);
                await interaction.editReply({ 
                    content: `íšŒì›ê°€ì… ì •ë³´ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤! \n**${email}**ë¡œ ì¸ì¦ì½”ë“œë¥¼ ë°œì†¡í–ˆìŠµë‹ˆë‹¤.\n\`/ì¸ì¦ [ì½”ë“œ]\` ëª…ë ¹ì–´ë¡œ ì´ë©”ì¼ ì¸ì¦ì„ ì™„ë£Œí•´ì£¼ì„¸ìš”.`
                });
            } catch (emailError) {
                console.error('ì´ë©”ì¼ ì „ì†¡ ì˜¤ë¥˜:', emailError);
                await interaction.editReply({ 
                    content: 'íšŒì›ê°€ì… ì •ë³´ëŠ” ì €ì¥ë˜ì—ˆì§€ë§Œ ì´ë©”ì¼ ì „ì†¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•´ì£¼ì„¸ìš”.'
                });
            }
        } catch (error) {
            console.error('íšŒì›ê°€ì… ì²˜ë¦¬ ì˜¤ë¥˜:', error);
            await interaction.editReply({ content: 'íšŒì›ê°€ì… ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤!' });
        }
    }
    
    // ì£¼ì‹ ë§¤ìˆ˜ ëª¨ë‹¬ ì²˜ë¦¬
    else if (interaction.customId.startsWith('buy_modal_')) {
        console.log('ğŸŸ¢ ë§¤ìˆ˜ ëª¨ë‹¬ ì²˜ë¦¬ ì‹œì‘:', interaction.customId);
        const companyId = interaction.customId.replace('buy_modal_', '');
        const sharesText = interaction.fields.getTextInputValue('shares');
        const shares = parseInt(sharesText);
        
        console.log(`ğŸŸ¢ ë§¤ìˆ˜ ì •ë³´: ê¸°ì—…=${companyId}, ìˆ˜ëŸ‰=${shares}`);
        
        if (isNaN(shares) || shares <= 0) {
            console.log('âŒ ì˜ëª»ëœ ìˆ˜ëŸ‰:', sharesText);
            await interaction.reply({ content: 'ì˜¬ë°”ë¥¸ ìˆ˜ëŸ‰ì„ ì…ë ¥í•´ì£¼ì„¸ìš”!', flags: 64 });
            return;
        }
        
        console.log('ğŸŸ¢ buyStock í•¨ìˆ˜ í˜¸ì¶œ ì¤‘...');
        const result = await buyStock(interaction.user.id, companyId, shares);
        
        if (result.success) {
            // ì£¼ì‹ ê±°ë˜ ê¸°ë¡
            recordPlayerAction('stock_trade');
            
            await interaction.reply({ 
                content: `âœ… ${result.message}`, 
                flags: 64 
            });
        } else {
            await interaction.reply({ 
                content: `âŒ ${result.message}`, 
                flags: 64 
            });
        }
    }
    
    // ì£¼ì‹ ë§¤ë„ ëª¨ë‹¬ ì²˜ë¦¬  
    else if (interaction.customId.startsWith('sell_modal_')) {
        console.log('ğŸ”´ ë§¤ë„ ëª¨ë‹¬ ì²˜ë¦¬ ì‹œì‘:', interaction.customId);
        const companyId = interaction.customId.replace('sell_modal_', '');
        const sharesText = interaction.fields.getTextInputValue('shares');
        const shares = parseInt(sharesText);
        
        console.log(`ğŸ”´ ë§¤ë„ ì •ë³´: ê¸°ì—…=${companyId}, ìˆ˜ëŸ‰=${shares}`);
        
        if (isNaN(shares) || shares <= 0) {
            console.log('âŒ ì˜ëª»ëœ ìˆ˜ëŸ‰:', sharesText);
            await interaction.reply({ content: 'ì˜¬ë°”ë¥¸ ìˆ˜ëŸ‰ì„ ì…ë ¥í•´ì£¼ì„¸ìš”!', flags: 64 });
            return;
        }
        
        console.log('ğŸ”´ sellStock í•¨ìˆ˜ í˜¸ì¶œ ì¤‘...');
        const result = await sellStock(interaction.user.id, companyId, shares);
        
        if (result.success) {
            // ì£¼ì‹ ê±°ë˜ ê¸°ë¡
            recordPlayerAction('stock_trade');
            
            await interaction.reply({ 
                content: `âœ… ${result.message}`, 
                flags: 64 
            });
        } else {
            await interaction.reply({ 
                content: `âŒ ${result.message}`, 
                flags: 64 
            });
        }
    }
    
    // ì»¤ìŠ¤í…€ ë² íŒ… ëª¨ë‹¬ ì²˜ë¦¬
    else if (interaction.customId === 'custom_bet_modal') {
        const betAmountText = interaction.fields.getTextInputValue('bet_amount');
        const betAmount = parseInt(betAmountText.replace(/[^\d]/g, '')); // ìˆ«ìë§Œ ì¶”ì¶œ
        
        if (isNaN(betAmount) || betAmount <= 0) {
            await interaction.reply({ content: 'ì˜¬ë°”ë¥¸ ë² íŒ… ê¸ˆì•¡ì„ ì…ë ¥í•´ì£¼ì„¸ìš”!', flags: 64 });
            return;
        }
        
        const user = await getUser(interaction.user.id);
        const result = await raceSystem.joinRace(
            interaction.user.id, 
            betAmount, 
            user, 
            interaction.user.displayAvatarURL({ extension: 'png', size: 128 }),
            interaction.channel
        );
        
        if (result.success) {
            await interaction.reply({ 
                content: `âœ… ${result.message}\nğŸ’° ìƒê¸ˆí’€: ${result.totalPot.toLocaleString()}<:currency_emoji:1377404064316522778> | ğŸ‘¥ ì°¸ê°€ì: ${result.currentPlayers}ëª…`, 
                flags: 64 
            });
        } else {
            await interaction.reply({ content: `âŒ ${result.message}`, flags: 64 });
        }
    }
    
    // ë² íŒ… ëª¨ë‹¬ ì²˜ë¦¬ (í™€/ì§, ì†Œ/ëŒ€, ëŸ­í‚¤7)
    else if (interaction.customId === 'bet_modal_odd' || interaction.customId === 'bet_modal_even' || 
             interaction.customId === 'bet_modal_small' || interaction.customId === 'bet_modal_big' || 
             interaction.customId === 'bet_modal_lucky7') {
        
        const betAmountText = interaction.fields.getTextInputValue('bet_amount');
        const betAmount = parseInt(betAmountText.replace(/[^\d]/g, '')); // ìˆ«ìë§Œ ì¶”ì¶œ
        
        if (isNaN(betAmount) || betAmount <= 0) {
            await interaction.reply({ content: 'ì˜¬ë°”ë¥¸ ë² íŒ… ê¸ˆì•¡ì„ ì…ë ¥í•´ì£¼ì„¸ìš”!', flags: 64 });
            return;
        }
        
        // ë² íŒ… íƒ€ì… ê²°ì •
        let betType;
        switch (interaction.customId) {
            case 'bet_modal_odd':
                betType = 'odd';
                break;
            case 'bet_modal_even':
                betType = 'even';
                break;
            case 'bet_modal_small':
                betType = 'small';
                break;
            case 'bet_modal_big':
                betType = 'big';
                break;
            case 'bet_modal_lucky7':
                betType = 'lucky7';
                break;
        }
        
        try {
            await oddEvenGame.addBet(interaction, betType, betAmount);
        } catch (error) {
            console.error('ë² íŒ… ì²˜ë¦¬ ì˜¤ë¥˜:', error);
            if (!interaction.replied && !interaction.deferred) {
                await interaction.reply({ content: 'ë² íŒ… ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤!', flags: 64 });
            }
        }
    }
    
    // ì­íŒŸ ëª¨ë‹¬ ì²˜ë¦¬
    else if (interaction.customId === 'jackpot_modal') {
        const betAmountText = interaction.fields.getTextInputValue('bet_amount');
        const targetNumberText = interaction.fields.getTextInputValue('target_number');
        
        const betAmount = parseInt(betAmountText.replace(/[^\d]/g, ''));
        const targetNumber = parseInt(targetNumberText.replace(/[^\d]/g, ''));
        
        if (isNaN(betAmount) || betAmount <= 0) {
            await interaction.reply({ content: 'ì˜¬ë°”ë¥¸ ë² íŒ… ê¸ˆì•¡ì„ ì…ë ¥í•´ì£¼ì„¸ìš”!', flags: 64 });
            return;
        }
        
        if (isNaN(targetNumber) || targetNumber < 1 || targetNumber > 100) {
            await interaction.reply({ content: '1ë¶€í„° 100ê¹Œì§€ì˜ ìˆ«ìë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”!', flags: 64 });
            return;
        }
        
        try {
            await oddEvenGame.addBet(interaction, 'jackpot', betAmount, targetNumber);
        } catch (error) {
            console.error('ì­íŒŸ ë² íŒ… ì²˜ë¦¬ ì˜¤ë¥˜:', error);
            await interaction.reply({ content: 'ì­íŒŸ ë² íŒ… ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤!', flags: 64 });
        }
    }
    
    // ìœ ë¬¼íƒì‚¬ íˆ¬ì ëª¨ë‹¬ ì²˜ë¦¬
    else if (interaction.customId.startsWith('invest_modal_')) {
        const companyId = interaction.customId.replace('invest_modal_', '');
        const investmentText = interaction.fields.getTextInputValue('investment_amount');
        const investmentAmount = parseInt(investmentText.replace(/[^\d]/g, ''));
        
        if (isNaN(investmentAmount) || investmentAmount <= 0) {
            await interaction.reply({ content: 'ì˜¬ë°”ë¥¸ íˆ¬ì ê¸ˆì•¡ì„ ì…ë ¥í•´ì£¼ì„¸ìš”!', flags: 64 });
            return;
        }
        
        const company = ARTIFACT_SYSTEM.companies[companyId];
        if (!company) {
            await interaction.reply({ content: 'ì¡´ì¬í•˜ì§€ ì•ŠëŠ” íƒì‚¬íšŒì‚¬ì…ë‹ˆë‹¤!', flags: 64 });
            return;
        }
        
        const costs = ARTIFACT_SYSTEM.explorationCosts[company.specialty];
        if (investmentAmount < costs.min || investmentAmount > costs.max) {
            await interaction.reply({ 
                content: `íˆ¬ì ê¸ˆì•¡ì€ ${costs.min.toLocaleString()}G ~ ${costs.max.toLocaleString()}G ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤!`, 
                flags: 64 
            });
            return;
        }
        
        // íƒì‚¬ ì‹¤í–‰
        await interaction.deferReply({ flags: 64 });
        const user = await getUser(interaction.user.id);
        await executeExploration(interaction, user, companyId, investmentAmount);
    }
});

// ì´ëª¨ì§€ ë°˜ì‘ ì¶”ê°€ ì´ë²¤íŠ¸
client.on('messageReactionAdd', async (reaction, user) => {
    try {
        // ë´‡ì˜ ë°˜ì‘ì€ ë¬´ì‹œ
        if (user.bot) return;
        
        // ë¶€ë¶„ì ì¸ ë©”ì‹œì§€ì¸ ê²½ìš° ì „ì²´ ë©”ì‹œì§€ ê°€ì ¸ì˜¤ê¸°
        if (reaction.partial) {
            try {
                await reaction.fetch();
            } catch (error) {
                console.error('ë°˜ì‘ fetch ì˜¤ë¥˜:', error);
                return;
            }
        }
        
        // ë©”ì‹œì§€ ì‘ì„±ìê°€ ë´‡ì¸ ê²½ìš° ë¬´ì‹œ
        if (reaction.message.author.bot) return;
        
        // ìê¸° ìì‹ ì˜ ë©”ì‹œì§€ì— ëŒ€í•œ ë°˜ì‘ ë¬´ì‹œ
        if (reaction.message.author.id === user.id) return;
        
        // ì¸ê¸°ë„ ê´€ë ¨ ì´ëª¨ì§€ í™•ì¸
        const popularityEmojis = {
            'â¤ï¸': 1,    // í•˜íŠ¸: +1
            'ğŸ‘': 1,    // ë”°ë´‰: +1
            'ğŸ˜¢': -1,   // ìŠ¬í””: -1
            'ğŸ˜­': -1    // ëŒ€ì„±í†µê³¡: -1 (ì¶”ê°€)
        };
        
        const emojiName = reaction.emoji.name;
        if (!popularityEmojis.hasOwnProperty(emojiName)) return;
        
        const value = popularityEmojis[emojiName];
        const result = await updatePopularity(
            reaction.message.author.id,
            emojiName,
            value,
            reaction.message.id,
            reaction.message.guild
        );
        
        // ê²°ê³¼ ë¡œê·¸
        if (result.success) {
            console.log(`ì¸ê¸°ë„ ì—…ë°ì´íŠ¸: ${reaction.message.author.tag} ${result.message}`);
        }
    } catch (error) {
        console.error('ë©”ì‹œì§€ ë°˜ì‘ ì²˜ë¦¬ ì˜¤ë¥˜:', error);
    }
});

// ì´ëª¨ì§€ ë°˜ì‘ ì œê±° ì´ë²¤íŠ¸ (ì„ íƒì‚¬í•­)
client.on('messageReactionRemove', async (reaction, user) => {
    try {
        // ë´‡ì˜ ë°˜ì‘ì€ ë¬´ì‹œ
        if (user.bot) return;
        
        // ë¶€ë¶„ì ì¸ ë©”ì‹œì§€ì¸ ê²½ìš° ì „ì²´ ë©”ì‹œì§€ ê°€ì ¸ì˜¤ê¸°
        if (reaction.partial) {
            try {
                await reaction.fetch();
            } catch (error) {
                console.error('ë°˜ì‘ fetch ì˜¤ë¥˜:', error);
                return;
            }
        }
        
        // ë©”ì‹œì§€ ì‘ì„±ìê°€ ë´‡ì¸ ê²½ìš° ë¬´ì‹œ
        if (reaction.message.author.bot) return;
        
        // ìê¸° ìì‹ ì˜ ë©”ì‹œì§€ì— ëŒ€í•œ ë°˜ì‘ ë¬´ì‹œ
        if (reaction.message.author.id === user.id) return;
        
        // ë°˜ì‘ ì œê±° ì‹œ ì¸ê¸°ë„ ì›ë³µ (ì„ íƒì‚¬í•­)
        // í•„ìš”í•œ ê²½ìš° êµ¬í˜„ ê°€ëŠ¥
    } catch (error) {
        console.error('ë©”ì‹œì§€ ë°˜ì‘ ì œê±° ì²˜ë¦¬ ì˜¤ë¥˜:', error);
    }
});

// ì— ë¸”ëŸ¼ ì‹œìŠ¤í…œ ìƒí˜¸ì‘ìš© ì²˜ë¦¬
client.on('interactionCreate', async (interaction) => {
    if (!interaction.isStringSelectMenu() && !interaction.isButton()) return;
    
    // ì²« ë²ˆì§¸ handlerì—ì„œ ì²˜ë¦¬í•˜ëŠ” ìƒí˜¸ì‘ìš©ë“¤ì€ ê±´ë„ˆë›°ê¸°
    const excludedIds = ['equipment', 'game_page_', 'inventory', 'quest', 'pvp', 'shop', 'hunting', 'register', 'equip_item_', 'equip_category_', 'equip_', 'unequip_', 'buy_stock_', 'sell_stock_', 'stock_regions', 'stock_chains', 'stock_portfolio', 'stock_news', 'stock_chart', 'stock_analysis', 'all_companies_chart', 'artifact_direct_explore', 'artifact_companies', 'artifact_inventory', 'artifact_shop', 'artifact_main_menu', 'artifact_rankings', 'artifact_guide', 'artifact_market_chart', 'artifact_chart_individual', 'artifact_my_charts', 'artifact_inv_', 'explore_', 'daily', 'work', 'exercise_select', 'select_exercise_type', 'main_menu', 'racing', 'join_race_', 'leave_race', 'racing_stats', 'racing_ranking'];  // 'inv_' ì œê±°í•˜ì—¬ inv_use_ ë²„íŠ¼ì´ ì‘ë™í•˜ë„ë¡ í•¨
    
    if (excludedIds.some(id => interaction.customId.includes(id))) {
        console.log(`ğŸŸ¡ ë‘ ë²ˆì§¸ í•¸ë“¤ëŸ¬ì—ì„œ ì œì™¸ë¨: ${interaction.customId}`);
        return;
    }
    
    if (interaction.isButton()) {
        console.log(`ğŸ”µ ë‘ ë²ˆì§¸ í•¸ë“¤ëŸ¬ì—ì„œ ì²˜ë¦¬: ${interaction.customId}`);
    }
    
    try {
        const user = await getUser(interaction.user.id);
        if (!user || !user.registered) {
            await interaction.reply({ content: 'ë“±ë¡ë˜ì§€ ì•Šì€ ì‚¬ìš©ìì…ë‹ˆë‹¤. ë¨¼ì € /ê°€ì…ì„ ì™„ë£Œí•´ì£¼ì„¸ìš”!', flags: 64 });
            return;
        }

        // ë­í‚¹ ì¹´í…Œê³ ë¦¬ ì„ íƒ ì²˜ë¦¬
        if (interaction.customId === 'ranking_category_select') {
            const selectedValue = interaction.values[0];
            const page = parseInt(selectedValue.replace('ranking_goto_', ''));
            await showRankingMenu(interaction, page);
        }
        
        // ê°œë³„ ë­í‚¹ ë²„íŠ¼ ì²˜ë¦¬
        else if (interaction.customId === 'ranking_level') {
            await showRankingMenu(interaction, 0); // ë ˆë²¨ ë­í‚¹
        }
        else if (interaction.customId === 'ranking_gold') {
            await showRankingMenu(interaction, 1); // ì¬ì‚° ë­í‚¹
        }
        else if (interaction.customId === 'ranking_popularity') {
            await showRankingMenu(interaction, 2); // ì¸ê¸°ë„ ë­í‚¹
        }
        else if (interaction.customId === 'ranking_pvp') {
            await showRankingMenu(interaction, 4); // PVP ë­í‚¹
        }
        else if (interaction.customId === 'ranking_racing') {
            await showRankingMenu(interaction, 5); // ë ˆì´ì‹± ë­í‚¹
        }
        else if (interaction.customId === 'ranking_energy') {
            await showRankingMenu(interaction, 8); // ìœµí•© ë­í‚¹
        }
        
        // ë…ë²„ì„¯ ê²Œì„ ë²„íŠ¼ ì²˜ë¦¬
        else if (interaction.customId === 'mushroom_solo') {
            console.log('ğŸ„ ë…ë²„ì„¯ ê²Œì„ ë²„íŠ¼ í´ë¦­ë¨!');
            await interaction.deferReply({ flags: 64 });
            
            const user = await getUser(interaction.user.id);
            
            // ë´‡ ì„ íƒ ë©”ë‰´ í‘œì‹œ
            const botSelectEmbed = new EmbedBuilder()
                .setColor('#2ecc71')
                .setTitle('ğŸ„ ê¹€í—Œí„°ì˜ ì‹ ë¹„í•œ ìˆ² íƒí—˜')
                .setDescription('ì–´ë–¤ ë´‡ê³¼ ëŒ€ê²°í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')
                .setImage('attachment://kim_hunting_main.png');
            
            const botOptions = Object.entries(MUSHROOM_GAME.botCharacters).map(([id, bot]) => ({
                label: bot.name,
                description: bot.description,
                value: `start_mushroom_${id}`,
                emoji: bot.emoji
            }));
            
            const botSelectMenu = new StringSelectMenuBuilder()
                .setCustomId('select_mushroom_bot')
                .setPlaceholder('ëŒ€ê²°í•  ë´‡ì„ ì„ íƒí•˜ì„¸ìš”')
                .addOptions(botOptions);
            
            const selectRow = new ActionRowBuilder().addComponents(botSelectMenu);
            
            const mainGif = new AttachmentBuilder(path.join(__dirname, 'resource', 'kim_hunting_main.png'));
            
            await interaction.editReply({ 
                embeds: [botSelectEmbed], 
                components: [selectRow],
                files: [mainGif]
            });
        }
        
        // ë…ë²„ì„¯ ê²Œì„ ë‹¤ì‹œí•˜ê¸°
        else if (interaction.customId === 'mushroom_play_again') {
            console.log('ğŸ„ ë…ë²„ì„¯ ê²Œì„ ë‹¤ì‹œí•˜ê¸° ë²„íŠ¼ í´ë¦­ë¨!');
            await interaction.deferUpdate();
            
            const user = await getUser(interaction.user.id);
            
            // ë´‡ ì„ íƒ ë©”ë‰´ í‘œì‹œ
            const botSelectEmbed = new EmbedBuilder()
                .setColor('#2ecc71')
                .setTitle('ğŸ„ ê¹€í—Œí„°ì˜ ì‹ ë¹„í•œ ìˆ² íƒí—˜')
                .setDescription('ì–´ë–¤ ë´‡ê³¼ ëŒ€ê²°í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')
                .setImage('attachment://kim_hunting_main.png');
            
            const botOptions = Object.entries(MUSHROOM_GAME.botCharacters).map(([id, bot]) => ({
                label: bot.name,
                description: bot.description,
                value: `start_mushroom_${id}`,
                emoji: bot.emoji
            }));
            
            const botSelectMenu = new StringSelectMenuBuilder()
                .setCustomId('select_mushroom_bot')
                .setPlaceholder('ëŒ€ê²°í•  ë´‡ì„ ì„ íƒí•˜ì„¸ìš”')
                .addOptions(botOptions);
            
            const selectRow = new ActionRowBuilder().addComponents(botSelectMenu);
            
            const mainGif = new AttachmentBuilder(path.join(__dirname, 'resource', 'kim_hunting_main.png'));
            
            await interaction.editReply({ 
                embeds: [botSelectEmbed], 
                components: [selectRow],
                files: [mainGif]
            });
        }
        
        else if (interaction.customId === 'mushroom_pvp') {
            await interaction.deferReply({ flags: 64 });
            
            // PVPëŠ” ë‚˜ì¤‘ì— êµ¬í˜„
            await interaction.editReply({ 
                content: 'ğŸš§ PVP ëª¨ë“œëŠ” ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤! ì†”ë¡œ ëª¨ë“œë¥¼ ì¦ê²¨ì£¼ì„¸ìš”.' 
            });
        }
        
        // ë…ë²„ì„¯ ë´‡ ì„ íƒ ì²˜ë¦¬
        else if (interaction.customId === 'select_mushroom_bot') {
            await interaction.deferUpdate();
            
            const selectedValue = interaction.values[0];
            const botId = selectedValue.replace('start_mushroom_', '');
            const bot = MUSHROOM_GAME.botCharacters[botId];
            const user = await getUser(interaction.user.id);
            
            // ê²Œì„ ì‹œì‘
            const gameId = Date.now().toString();
            const mushrooms = generateMushroomGameRound(1);
            
            mushroomGameSessions.set(gameId, {
                type: 'solo',
                userId: interaction.user.id,
                user: user,
                bot: bot,
                botId: botId,
                round: 1,
                playerAlive: true,
                botAlive: true,
                mushrooms: mushrooms,
                currentTurn: 'player',
                mushroomType: Object.keys(MUSHROOM_GAME.mushroomTypes)[Math.floor(Math.random() * Object.keys(MUSHROOM_GAME.mushroomTypes).length)],
                earnings: 0,
                startTime: Date.now()
            });
            
            const mushroomInfo = MUSHROOM_GAME.mushroomTypes[mushroomGameSessions.get(gameId).mushroomType];
            const gameEmbed = new EmbedBuilder()
                .setColor('#2ecc71')
                .setTitle(`ğŸ„ ${MUSHROOM_GAME.difficultyByRound[1].message}`)
                .setDescription(`${MUSHROOM_GAME.messages.gameStart}\n\n${mushroomInfo.name}ì´ ë‚˜íƒ€ë‚¬ìŠµë‹ˆë‹¤!\në‹¹ì‹ ì˜ ì°¨ë¡€ì…ë‹ˆë‹¤.`)
                .addFields(
                    { name: 'ğŸ‘¤ í”Œë ˆì´ì–´', value: user.nickname, inline: true },
                    { name: 'ğŸ¤– ìƒëŒ€', value: `${bot.emoji} ${bot.name}`, inline: true },
                    { name: 'ğŸ¯ ë¼ìš´ë“œ', value: '1/5', inline: true }
                )
                .setImage('attachment://kim_hunting.gif');
            
            const buttons = createMushroomGameButtons(gameId, mushrooms, 'player');
            const huntingGif = new AttachmentBuilder(path.join(__dirname, 'resource', 'kim_hunting.gif'));
            
            await interaction.editReply({ 
                embeds: [gameEmbed], 
                components: buttons,
                files: [huntingGif]
            });
        }
        
        // ë…ë²„ì„¯ ì„ íƒ ì²˜ë¦¬
        else if (interaction.customId.startsWith('mushroom_select_')) {
            await interaction.deferUpdate();
            
            const [, , gameId, index] = interaction.customId.split('_');
            const session = mushroomGameSessions.get(gameId);
            
            if (!session || session.userId !== interaction.user.id) {
                return await interaction.editReply({ 
                    content: 'âŒ ìœ íš¨í•˜ì§€ ì•Šì€ ê²Œì„ì…ë‹ˆë‹¤!', 
                    components: [] 
                });
            }
            
            if (session.currentTurn !== 'player') {
                return await interaction.followUp({ 
                    content: 'âŒ ë´‡ì´ ì„ íƒí•˜ê³  ìˆìŠµë‹ˆë‹¤!', 
                    flags: 64 
                });
            }
            
            const mushroomIndex = parseInt(index);
            const selectedMushroom = session.mushrooms[mushroomIndex];
            
            if (selectedMushroom.revealed) {
                return await interaction.followUp({ 
                    content: 'âŒ ì´ë¯¸ ì„ íƒëœ ë²„ì„¯ì…ë‹ˆë‹¤!', 
                    flags: 64 
                });
            }
            
            // ë²„ì„¯ ê³µê°œ
            selectedMushroom.revealed = true;
            selectedMushroom.selectedBy = 'player';
            
            const mushroomInfo = MUSHROOM_GAME.mushroomTypes[session.mushroomType];
            const user = await getUser(interaction.user.id);
            
            // í”Œë ˆì´ì–´ê°€ ë…ë²„ì„¯ì„ ì„ íƒí•œ ê²½ìš°
            if (selectedMushroom.isPoisonous) {
                // ê²Œì„ ì¢…ë£Œ ì²˜ë¦¬
                mushroomGameSessions.delete(gameId);
                
                const loseEmbed = new EmbedBuilder()
                    .setColor('#ff0000')
                    .setTitle('â˜ ï¸ ë…ë²„ì„¯!')
                    .setDescription(`${mushroomInfo.poisonDesc}\n\nê²Œì„ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!`)
                    .addFields(
                        { name: 'ğŸ† ìµœì¢… ë¼ìš´ë“œ', value: `${session.round}/5`, inline: true },
                        { name: 'ğŸ’° íšë“ ì‹¤íŒ¨', value: `${session.earnings}G`, inline: true },
                        { name: 'ğŸ¤– ìƒëŒ€ ë´‡', value: `${session.bot.emoji} ${session.bot.name}`, inline: true }
                    )
                    .setImage('attachment://kim_hunting_lose.gif');
                
                const loseGif = new AttachmentBuilder(path.join(__dirname, 'resource', MUSHROOM_GAME.effects.poisonDeath));
                
                await interaction.editReply({ 
                    embeds: [loseEmbed], 
                    components: [],
                    files: [loseGif]
                });
                return;
            }
            
            // ì•ˆì „í•œ ë²„ì„¯ì„ ì„ íƒí•œ ê²½ìš°
            const safeEmbed = new EmbedBuilder()
                .setColor('#32cd32')
                .setTitle('âœ¨ ì•ˆì „í•œ ë²„ì„¯!')
                .setDescription(`${mushroomInfo.safeDesc}\n\nì´ì œ ${session.bot.emoji} ${session.bot.name}ì˜ ì°¨ë¡€ì…ë‹ˆë‹¤...`)
                .setImage('attachment://kim_hunting3.gif');
            
            const safeGif = new AttachmentBuilder(path.join(__dirname, 'resource', mushroomInfo.safeGif));
            
            await interaction.editReply({ 
                embeds: [safeEmbed], 
                components: [],
                files: [safeGif]
            });
            
            // ë´‡ì´ ìƒê°í•˜ëŠ” ì‹œê°„
            await new Promise(resolve => setTimeout(resolve, MUSHROOM_GAME.gameSettings.botThinkingTime));
            
            // ë´‡ í„´ ì²˜ë¦¬
            session.currentTurn = 'bot';
            const botChoice = getBotChoice(session.bot, session.mushrooms, session.round);
            
            if (botChoice === -1) {
                // ëª¨ë“  ë²„ì„¯ì´ ê³µê°œë¨ - ë‹¤ìŒ ë¼ìš´ë“œë¡œ
                await processNextRound(interaction, session, gameId);
                return;
            }
            
            const botMushroom = session.mushrooms[botChoice];
            botMushroom.revealed = true;
            botMushroom.selectedBy = 'bot';
            
            // ë´‡ì´ ë…ë²„ì„¯ì„ ì„ íƒí•œ ê²½ìš°
            if (botMushroom.isPoisonous) {
                // í”Œë ˆì´ì–´ ìŠ¹ë¦¬ - ë¼ìš´ë“œ ë³´ìƒ ê³„ì‚°
                const roundReward = MUSHROOM_GAME.gameSettings.baseReward * session.round;
                session.earnings += roundReward;
                
                // 5ë¼ìš´ë“œ ì™„ë£Œ ì²´í¬
                if (session.round >= MUSHROOM_GAME.gameSettings.maxRounds) {
                    // ì™„ë²½í•œ ìŠ¹ë¦¬
                    const perfectReward = session.earnings + MUSHROOM_GAME.gameSettings.perfectBonus;
                    user.gold += perfectReward;
                    await user.save();
                    
                    mushroomGameSessions.delete(gameId);
                    
                    const perfectWinEmbed = new EmbedBuilder()
                        .setColor('#ffd700')
                        .setTitle('ğŸ† ì™„ë²½í•œ ìŠ¹ë¦¬!')
                        .setDescription(`${session.bot.emoji} ${session.bot.name}ì´(ê°€) ë…ë²„ì„¯ì„ ì„ íƒí–ˆìŠµë‹ˆë‹¤!\n\nëª¨ë“  ë¼ìš´ë“œë¥¼ í†µê³¼í•˜ì—¬ ì™„ë²½í•œ ìŠ¹ë¦¬ë¥¼ ë‹¬ì„±í–ˆìŠµë‹ˆë‹¤!`)
                        .addFields(
                            { name: 'ğŸ’° ë¼ìš´ë“œ ë³´ìƒ', value: `${session.earnings}G`, inline: true },
                            { name: 'ğŸ ì™„ë²½ ë³´ë„ˆìŠ¤', value: `${MUSHROOM_GAME.gameSettings.perfectBonus}G`, inline: true },
                            { name: 'ğŸ’ ì´ íšë“', value: `${perfectReward}G`, inline: true }
                        )
                        .setImage('attachment://kim_hunting_win.gif');
                    
                    const winGif = new AttachmentBuilder(path.join(__dirname, 'resource', MUSHROOM_GAME.effects.victory));
                    
                    await interaction.followUp({ 
                        embeds: [perfectWinEmbed], 
                        files: [winGif]
                    });
                } else {
                    // ë¼ìš´ë“œ ìŠ¹ë¦¬
                    user.gold += session.earnings;
                    await user.save();
                    
                    mushroomGameSessions.delete(gameId);
                    
                    const winEmbed = new EmbedBuilder()
                        .setColor('#00ff00')
                        .setTitle('ğŸ‰ ìŠ¹ë¦¬!')
                        .setDescription(`${session.bot.emoji} ${session.bot.name}ì´(ê°€) ë…ë²„ì„¯ì„ ì„ íƒí–ˆìŠµë‹ˆë‹¤!`)
                        .addFields(
                            { name: 'ğŸ† ìµœì¢… ë¼ìš´ë“œ', value: `${session.round}/5`, inline: true },
                            { name: 'ğŸ’° íšë“ ê¸ˆì•¡', value: `${session.earnings}G`, inline: true },
                            { name: 'ğŸ¯ ìŠ¹ë¦¬ ë°°ìœ¨', value: `x${session.round}`, inline: true }
                        )
                        .setImage('attachment://kim_hunting_win.gif');
                    
                    const winGif = new AttachmentBuilder(path.join(__dirname, 'resource', MUSHROOM_GAME.effects.victory));
                    
                    await interaction.followUp({ 
                        embeds: [winEmbed], 
                        files: [winGif]
                    });
                }
                return;
            }
            
            // ë´‡ë„ ì•ˆì „í•œ ë²„ì„¯ì„ ì„ íƒí•œ ê²½ìš° - ê²Œì„ ê³„ì†
            const botSafeEmbed = new EmbedBuilder()
                .setColor('#3498db')
                .setTitle('ğŸ¤– ë´‡ë„ ì•ˆì „!')
                .setDescription(`${session.bot.emoji} ${session.bot.name}ë„ ì•ˆì „í•œ ë²„ì„¯ì„ ì„ íƒí–ˆìŠµë‹ˆë‹¤!`);
            
            await interaction.followUp({ embeds: [botSafeEmbed] });
            
            // ëª¨ë“  ë²„ì„¯ì´ ê³µê°œë˜ì—ˆëŠ”ì§€ í™•ì¸
            const unrevealed = session.mushrooms.filter(m => !m.revealed);
            
            if (unrevealed.length === 0) {
                // ë¼ìš´ë“œ ì¢…ë£Œ - ë‹¤ìŒ ë¼ìš´ë“œë¡œ
                await processNextRound(interaction, session, gameId);
            } else {
                // ê²Œì„ ê³„ì†
                session.currentTurn = 'player';
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                const continueEmbed = new EmbedBuilder()
                    .setColor('#3498db')
                    .setTitle('ğŸ„ ê²Œì„ ê³„ì†!')
                    .setDescription('ë‹¤ë¥¸ ë²„ì„¯ì„ ì„ íƒí•˜ì„¸ìš”!')
                    .addFields(
                        { name: 'ğŸ¯ í˜„ì¬ ë¼ìš´ë“œ', value: `${session.round}/5`, inline: true },
                        { name: 'ğŸ’° ëˆ„ì  ë³´ìƒ', value: `${session.earnings}G`, inline: true },
                        { name: 'ğŸ„ ë‚¨ì€ ë²„ì„¯', value: `${unrevealed.length}ê°œ`, inline: true }
                    );
                
                const mushroomButtons = createMushroomGameButtons(gameId, session.mushrooms, 'player');
                
                await interaction.followUp({ 
                    embeds: [continueEmbed], 
                    components: mushroomButtons 
                });
            }
        }
        
        // ë…ë²„ì„¯ ê²Œì„ ê³„ì†í•˜ê¸°
        else if (interaction.customId.startsWith('mushroom_continue_')) {
            await interaction.deferUpdate();
            
            const gameId = interaction.customId.split('_')[2];
            const session = mushroomGameSessions.get(gameId);
            
            if (!session) {
                return await interaction.editReply({ 
                    content: 'âŒ ê²Œì„ ì„¸ì…˜ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤!', 
                    components: [] 
                });
            }
            
            // ìƒˆë¡œìš´ ë¼ìš´ë“œ ì‹œì‘
            session.mushrooms = generateMushroomGame();
            
            const gameEmbed = new EmbedBuilder()
                .setColor('#32cd32')
                .setTitle('ğŸ„ ë…ë²„ì„¯ ì°¾ê¸° ê²Œì„')
                .setDescription(`ë¼ìš´ë“œ ${session.round} - í™©ê¸ˆë²„ì„¯ì„ ì°¾ìœ¼ì„¸ìš”!`)
                .addFields(
                    { name: 'ğŸ¯ ë¼ìš´ë“œ', value: `${session.round}`, inline: true },
                    { name: 'ğŸ’° ëˆ„ì  ìƒê¸ˆ', value: `${session.totalEarnings}G`, inline: true },
                    { name: 'ğŸ† ë°°ìœ¨', value: `x${session.round}`, inline: true }
                );
            
            const mushroomButtons = createMushroomButtons(gameId, session.mushrooms);
            
            await interaction.editReply({ 
                embeds: [gameEmbed], 
                components: mushroomButtons 
            });
        }
        
        // ë…ë²„ì„¯ ê²Œì„ ìƒê¸ˆ ë°›ê¸°
        else if (interaction.customId.startsWith('mushroom_cashout_')) {
            await interaction.deferUpdate();
            
            const gameId = interaction.customId.split('_')[2];
            const session = mushroomGameSessions.get(gameId);
            
            if (!session) {
                return await interaction.editReply({ 
                    content: 'âŒ ê²Œì„ ì„¸ì…˜ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤!', 
                    components: [] 
                });
            }
            
            const user = await getUser(interaction.user.id);
            user.gold += session.totalEarnings;
            await user.save();
            
            mushroomGameSessions.delete(gameId);
            
            const cashoutEmbed = new EmbedBuilder()
                .setColor('#00ff00')
                .setTitle('ğŸ’° ìƒê¸ˆ íšë“!')
                .setDescription(`ì¶•í•˜í•©ë‹ˆë‹¤! ${session.totalEarnings}Gë¥¼ íšë“í–ˆìŠµë‹ˆë‹¤!`)
                .addFields(
                    { name: 'ğŸ† ìµœì¢… ë¼ìš´ë“œ', value: `${session.round - 1}`, inline: true },
                    { name: 'ğŸ’° íšë“ ê¸ˆì•¡', value: `${session.totalEarnings}G`, inline: true },
                    { name: 'ğŸ’¸ ìˆœìˆ˜ìµ', value: `${session.totalEarnings - session.betAmount}G`, inline: true }
                );
            
            await interaction.editReply({ 
                embeds: [cashoutEmbed], 
                components: [] 
            });
        }
        
        // ìœ ë¬¼ íŒë§¤ ì„ íƒ
        else if (interaction.customId === 'sell_artifact_select') {
            const selectionValue = interaction.values[0];
            const artifactIndex = parseInt(selectionValue.replace('sell_artifact_', ''));
            
            const artifacts = user.artifacts || [];
            const selectedArtifact = artifacts[artifactIndex];
            
            if (!selectedArtifact) {
                await interaction.reply({ content: 'ì„ íƒí•œ ìœ ë¬¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            // í˜„ì¬ ì‹œì„¸ ê³„ì‚°
            const currentPrice = calculateArtifactValue(selectedArtifact);
            const basePrice = selectedArtifact.value;
            const priceChange = currentPrice - basePrice;
            const changePercent = ((priceChange / basePrice) * 100).toFixed(1);
            const changeIcon = priceChange > 0 ? 'ğŸ“ˆ' : priceChange < 0 ? 'ğŸ“‰' : 'â¡ï¸';
            
            // ê³¨ë“œ ì¶”ê°€ ë° ìœ ë¬¼ ì œê±° (ì‹œì„¸ ë°˜ì˜)
            await User.updateOne(
                { discordId: interaction.user.id },
                { 
                    $inc: { 
                        gold: currentPrice,
                        'explorationStats.totalEarned': currentPrice 
                    },
                    $pull: { artifacts: { _id: selectedArtifact._id } }
                }
            );
            
            const embed = new EmbedBuilder()
                .setColor('#2ecc71')
                .setTitle('ğŸª ìœ ë¬¼ íŒë§¤ ì™„ë£Œ!')
                .setDescription(`**${selectedArtifact.name}**ì„(ë¥¼) ì„±ê³µì ìœ¼ë¡œ íŒë§¤í–ˆìŠµë‹ˆë‹¤!`)
                .addFields(
                    { name: 'ğŸ’ íŒë§¤ ìœ ë¬¼', value: `${selectedArtifact.emoji} **${selectedArtifact.name}**\n${getRarityText(selectedArtifact.rarity)}`, inline: true },
                    { name: 'ğŸ’° íŒë§¤ ê°€ê²©', value: `${currentPrice.toLocaleString()}G ${changeIcon} ${changePercent > 0 ? '+' : ''}${changePercent}%\n(ê¸°ì¤€ê°€: ${basePrice.toLocaleString()}G)`, inline: true },
                    { name: 'ğŸ’³ í˜„ì¬ ê³¨ë“œ', value: `${(user.gold + selectedArtifact.value).toLocaleString()}G`, inline: true }
                )
                .setFooter({ text: 'íŒë§¤ëœ ìœ ë¬¼ì€ ë³µêµ¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤!' });

            const continueButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('artifact_shop')
                        .setLabel('ğŸ”„ ê³„ì† íŒë§¤')
                        .setStyle(ButtonStyle.Success),
                    new ButtonBuilder()
                        .setCustomId('artifact_inventory')
                        .setLabel('ğŸ’ ë³´ê´€í•¨')
                        .setStyle(ButtonStyle.Secondary),
                    new ButtonBuilder()
                        .setCustomId('artifact_main_menu')
                        .setLabel('ğŸ  ë©”ë‰´')
                        .setStyle(ButtonStyle.Primary)
                );

            await interaction.update({
                embeds: [embed],
                components: [continueButtons]
            });
        }

        // ì£¼ì‹ ì§€ì—­ ì„ íƒ
        else if (interaction.customId === 'select_region') {
            const regionKey = interaction.values[0];
            const region = STOCK_MARKET.regions[regionKey];
            
            if (!region) {
                await interaction.reply({ content: 'ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì§€ì—­ì…ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            let regionText = '';
            region.companies.forEach((company, index) => {
                const changeIcon = company.change > 0 ? 'ğŸ“ˆ' : company.change < 0 ? 'ğŸ“‰' : 'â¡ï¸';
                const changeColor = company.change > 0 ? '+' : '';
                regionText += `${index + 1}. **${company.name}**\n`;
                regionText += `   ${company.price.toLocaleString()}<:currency_emoji:1377404064316522778> ${changeIcon} ${changeColor}${company.change.toFixed(1)}%\n`;
                regionText += `   ê±°ë˜ëŸ‰: ${company.volume.toLocaleString()}\n\n`;
            });
            
            const regionEmbed = new EmbedBuilder()
                .setColor('#3498db')
                .setTitle(`${region.name} ê¸°ì—… í˜„í™©`)
                .setDescription(regionText)
                .setFooter({ text: 'ê¸°ì—…ì„ í´ë¦­í•˜ì—¬ ë§¤ìˆ˜/ë§¤ë„í•˜ì„¸ìš”!' });
                
            // ì§€ì—­ ê¸°ì—… ë§¤ìˆ˜/ë§¤ë„ ë²„íŠ¼ë“¤
            const regionButtons = new ActionRowBuilder();
            region.companies.forEach(company => {
                regionButtons.addComponents(
                    new ButtonBuilder()
                        .setCustomId(`trade_${company.id}`)
                        .setLabel(company.name)
                        .setStyle(ButtonStyle.Secondary)
                );
            });
            
            const backButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('stock_regions')
                        .setLabel('ğŸ”™ ì§€ì—­ ëª©ë¡')
                        .setStyle(ButtonStyle.Primary)
                );
            
            await interaction.update({
                embeds: [regionEmbed],
                components: [regionButtons, backButton]
            });
        }
        
        // ê°œë³„ ê¸°ì—… ì°¨íŠ¸ ì„ íƒ
        else if (interaction.customId === 'select_company_chart') {
            await interaction.deferUpdate();
            
            try {
                const companyId = interaction.values[0].replace('company_chart_', '');
                console.log('ì„ íƒëœ ê¸°ì—… ID:', companyId);
                
                // ì„ íƒëœ ê¸°ì—… ì°¾ê¸°
                let selectedCompany = null;
                for (const region of Object.values(STOCK_MARKET.regions)) {
                    selectedCompany = region.companies.find(c => c.id === companyId);
                    if (selectedCompany) break;
                }
                if (!selectedCompany) {
                    selectedCompany = STOCK_MARKET.chains.find(c => c.id === companyId);
                }
                
                if (!selectedCompany) {
                    await interaction.editReply({
                        content: `âŒ ì„ íƒëœ ê¸°ì—…ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (ID: ${companyId})`,
                        embeds: [],
                        components: []
                    });
                    return;
                }
                
                console.log('ì°¾ì€ ê¸°ì—…:', selectedCompany.name);
                
                // ê¸°ì—… ìƒì„¸ ì •ë³´
                const chartHistory = STOCK_MARKET.chart_history;
                
                // ì°¨íŠ¸ ë°ì´í„° í™•ì¸
                const chartData = chartHistory.top_companies[selectedCompany.id] || [];
                console.log(`${selectedCompany.name} ì°¨íŠ¸ ë°ì´í„° ê¸¸ì´:`, chartData.length);
                
                if (chartData.length < 2) {
                    await interaction.editReply({
                        content: `âŒ ${selectedCompany.name}ì˜ ì°¨íŠ¸ ë°ì´í„°ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.`,
                        embeds: [],
                        components: []
                    });
                    return;
                }
                
                // ê¸°ì—… ê°œë³„ ì°¨íŠ¸ ìƒì„±
                const companyChartUrl = await generateRealChart(
                    chartData,
                    `${selectedCompany.name} ì£¼ê°€ ì°¨íŠ¸`
                );
                
                console.log('ìƒì„±ëœ ì°¨íŠ¸ URL:', companyChartUrl ? 'ì„±ê³µ' : 'ì‹¤íŒ¨');
                
                if (!companyChartUrl) {
                    await interaction.editReply({
                        content: 'âŒ ê¸°ì—… ì°¨íŠ¸ URL ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.',
                        embeds: [],
                        components: []
                    });
                    return;
                }
                let changeInfo = '';
                if (chartHistory.top_companies[selectedCompany.id] && chartHistory.top_companies[selectedCompany.id].length > 1) {
                    const prices = chartHistory.top_companies[selectedCompany.id];
                    const firstPrice = prices[0];
                    const lastPrice = prices[prices.length - 1];
                    const change = ((lastPrice - firstPrice) / firstPrice * 100).toFixed(2);
                    const changeIcon = change > 0 ? 'ğŸ“ˆ' : change < 0 ? 'ğŸ“‰' : 'â¡ï¸';
                    changeInfo = `${changeIcon} ${change > 0 ? '+' : ''}${change}% (${firstPrice.toLocaleString()}G â†’ ${lastPrice.toLocaleString()}G)`;
                } else {
                    changeInfo = 'ğŸ“Š ë°ì´í„° ìˆ˜ì§‘ ì¤‘...';
                }
                
                const companyEmbed = new EmbedBuilder()
                    .setColor('#e74c3c')
                    .setTitle(`ğŸ“ˆ ${selectedCompany.name} ê°œë³„ ì°¨íŠ¸`)
                    .setDescription(`**${selectedCompany.name}**ì˜ ìƒì„¸ ì£¼ê°€ ì°¨íŠ¸ì…ë‹ˆë‹¤.`)
                    .setImage(companyChartUrl)
                    .addFields(
                        { name: 'ğŸ’° í˜„ì¬ ì£¼ê°€', value: `${selectedCompany.price.toLocaleString()}G`, inline: true },
                        { name: 'ğŸ“Š ë³€ë™ë¥ ', value: `${selectedCompany.change > 0 ? '+' : ''}${selectedCompany.change.toFixed(1)}%`, inline: true },
                        { name: 'ğŸ“ˆ ì°¨íŠ¸ ê¸°ê°„ ë³€ë™', value: changeInfo, inline: false }
                    )
                    .setFooter({ text: `ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: ${new Date().toLocaleTimeString('ko-KR')} | Powered by QuickChart` });
                
                const companyButtons = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId(`trade_${selectedCompany.id}`)
                            .setLabel(`ğŸ’° ${selectedCompany.name} ê±°ë˜`)
                            .setStyle(ButtonStyle.Success),
                        new ButtonBuilder()
                            .setCustomId('company_charts')
                            .setLabel('ğŸ”™ ê¸°ì—… ëª©ë¡')
                            .setStyle(ButtonStyle.Secondary),
                        new ButtonBuilder()
                            .setCustomId('stock_chart')
                            .setLabel('ğŸ“Š ì „ì²´ ì°¨íŠ¸')
                            .setStyle(ButtonStyle.Primary)
                    );
                
                await interaction.editReply({
                    embeds: [companyEmbed],
                    components: [companyButtons]
                });
                
            } catch (error) {
                console.error('ê°œë³„ ê¸°ì—… ì°¨íŠ¸ ì„ íƒ ì˜¤ë¥˜:', error);
                await interaction.editReply({
                    content: 'âŒ ì°¨íŠ¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
                    embeds: [],
                    components: []
                });
            }
        }
        
        // ì— ë¸”ëŸ¼ ê³„ì—´ ì„ íƒ
        else if (interaction.customId === 'emblem_category') {
            // ì¸í„°ë™ì…˜ ì¦‰ì‹œ defer
            await interaction.deferReply({ flags: 64 });
            
            const category = interaction.values[0];
            const emblemData = EMBLEMS[category];
            
            if (!emblemData) {
                await interaction.editReply({ content: 'ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê³„ì—´ì…ë‹ˆë‹¤!' });
                return;
            }

            // ì´ë¯¸ ì— ë¸”ëŸ¼ ë³´ìœ  í™•ì¸
            if (user.emblem) {
                await interaction.editReply({ 
                    content: `ì´ë¯¸ **${user.emblem}** ì— ë¸”ëŸ¼ì„ ë³´ìœ í•˜ê³  ìˆìŠµë‹ˆë‹¤! ì— ë¸”ëŸ¼ì€ ë³€ê²½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.` 
                });
                return;
            }

            // ë ˆë²¨ 20 ì´ìƒ í™•ì¸
            if (user.level < 20) {
                await interaction.editReply({ 
                    content: `ì— ë¸”ëŸ¼ì„ êµ¬ë§¤í•˜ë ¤ë©´ **ë ˆë²¨ 20 ì´ìƒ**ì´ì–´ì•¼ í•©ë‹ˆë‹¤! (í˜„ì¬ ë ˆë²¨: ${user.level})` 
                });
                return;
            }

            // êµ¬ë§¤ ê°€ëŠ¥í•œ ì— ë¸”ëŸ¼ ëª©ë¡ ìƒì„±
            const availableEmblems = emblemData.emblems.filter(emblem => user.level >= emblem.level);
            
            if (availableEmblems.length === 0) {
                await interaction.editReply({ 
                    content: `ì´ ê³„ì—´ì˜ ì— ë¸”ëŸ¼ì„ êµ¬ë§¤í•˜ë ¤ë©´ ë” ë†’ì€ ë ˆë²¨ì´ í•„ìš”í•©ë‹ˆë‹¤!` 
                });
                return;
            }

            // ì— ë¸”ëŸ¼ ì„ íƒ ì„ë² ë“œ ìƒì„±
            const categoryEmbed = new EmbedBuilder()
                .setColor('#ff6b6b')
                .setTitle(`${emblemData.emoji} ${emblemData.name} ê³„ì—´ ì— ë¸”ëŸ¼`)
                .setDescription(`**${user.nickname}**ë‹˜ì´ êµ¬ë§¤ ê°€ëŠ¥í•œ ì— ë¸”ëŸ¼ ëª©ë¡ì…ë‹ˆë‹¤.\n\n**âš ï¸ í•œ ë²ˆ êµ¬ë§¤í•˜ë©´ ë³€ê²½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤!**`)
                .setFooter({ text: 'ì›í•˜ëŠ” ì— ë¸”ëŸ¼ì„ ì„ íƒí•˜ì—¬ êµ¬ë§¤í•˜ì„¸ìš”!' });

            // ì— ë¸”ëŸ¼ ëª©ë¡ í…ìŠ¤íŠ¸ ìƒì„±
            let emblemList = '';
            availableEmblems.forEach((emblem, index) => {
                const canAfford = user.gold >= emblem.price;
                emblemList += `**${emblem.name}**\n`;
                emblemList += `ğŸ’° ê°€ê²©: ${emblem.price.toLocaleString()}<:currency_emoji:1377404064316522778> ${canAfford ? 'âœ…' : 'âŒ'}\n`;
                emblemList += `ğŸ“Š í•„ìš” ë ˆë²¨: Lv.${emblem.level}\n\n`;
            });

            categoryEmbed.addFields({ name: 'êµ¬ë§¤ ê°€ëŠ¥í•œ ì— ë¸”ëŸ¼', value: emblemList, inline: false });

            // ì— ë¸”ëŸ¼ êµ¬ë§¤ ë²„íŠ¼ë“¤
            const emblemButtons = new ActionRowBuilder();
            availableEmblems.slice(0, 5).forEach((emblem, index) => {
                emblemButtons.addComponents(
                    new ButtonBuilder()
                        .setCustomId(`buy_emblem_${category}_${index}`)
                        .setLabel(`${emblem.name} êµ¬ë§¤`)
                        .setStyle(user.gold >= emblem.price ? ButtonStyle.Primary : ButtonStyle.Secondary)
                        .setDisabled(user.gold < emblem.price)
                );
            });

            await interaction.editReply({
                embeds: [categoryEmbed],
                components: [emblemButtons]
            });
        }

        // ì£¼ì‹ ê±°ë˜
        else if (interaction.customId.startsWith('trade_')) {
            const companyId = interaction.customId.replace('trade_', '');
            const company = findCompany(companyId);
            
            if (!company) {
                await interaction.reply({ content: 'ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê¸°ì—…ì…ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            const portfolio = await getPlayerPortfolio(interaction.user.id);
            const holding = portfolio.stocks.get(companyId);
            
            let tradeText = `**${company.name}**\n`;
            tradeText += `ğŸ’° í˜„ì¬ê°€: ${company.price.toLocaleString()}<:currency_emoji:1377404064316522778>\n`;
            tradeText += `ğŸ“Š ë³€ë™ë¥ : ${company.change >= 0 ? '+' : ''}${company.change.toFixed(1)}%\n`;
            tradeText += `ğŸ“ˆ ê±°ë˜ëŸ‰: ${company.volume.toLocaleString()}\n\n`;
            
            if (holding) {
                const currentValue = company.price * holding.shares;
                const profit = currentValue - (holding.avgPrice * holding.shares);
                const profitPercent = ((profit / (holding.avgPrice * holding.shares)) * 100).toFixed(1);
                
                tradeText += `ğŸ’¼ **ë³´ìœ  í˜„í™©**\n`;
                tradeText += `â€¢ ë³´ìœ ìˆ˜ëŸ‰: ${holding.shares}ì£¼\n`;
                tradeText += `â€¢ í‰ê· ë‹¨ê°€: ${holding.avgPrice.toLocaleString()}<:currency_emoji:1377404064316522778>\n`;
                tradeText += `â€¢ í‰ê°€ì†ìµ: ${profit >= 0 ? '+' : ''}${profit.toLocaleString()}<:currency_emoji:1377404064316522778> (${profitPercent >= 0 ? '+' : ''}${profitPercent}%)\n\n`;
            }
            
            tradeText += `ğŸ’° ë³´ìœ  í˜„ê¸ˆ: ${portfolio.cash.toLocaleString()}<:currency_emoji:1377404064316522778>`;
            
            const tradeEmbed = new EmbedBuilder()
                .setColor('#2ecc71')
                .setTitle('ğŸ“Š ì£¼ì‹ ê±°ë˜')
                .setDescription(tradeText)
                .setFooter({ text: 'ê±°ë˜í•  ì£¼ì‹ ìˆ˜ëŸ‰ì„ ì…ë ¥í•˜ì„¸ìš”!' });
            
            // ê±°ë˜ ë²„íŠ¼ë“¤
            const tradeButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId(`buy_stock_${companyId}`)
                        .setLabel('ğŸ’° ë§¤ìˆ˜')
                        .setStyle(ButtonStyle.Success)
                        .setDisabled(portfolio.cash < company.price),
                    new ButtonBuilder()
                        .setCustomId(`sell_stock_${companyId}`)
                        .setLabel('ğŸ’¸ ë§¤ë„')
                        .setStyle(ButtonStyle.Danger)
                        .setDisabled(!holding || holding.shares === 0)
                );
            
            const backButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('stock_main')
                        .setLabel('ğŸ”™ ì£¼ì‹ ë©”ì¸')
                        .setStyle(ButtonStyle.Primary)
                );
            
            await interaction.update({
                embeds: [tradeEmbed],
                components: [tradeButtons, backButton]
            });
        }
        
        // ì£¼ì‹ ë§¤ìˆ˜
        else if (interaction.customId.startsWith('buy_stock_')) {
            console.log('ğŸ’° ì£¼ì‹ ë§¤ìˆ˜ ë²„íŠ¼ í´ë¦­ë¨:', interaction.customId);
            const companyId = interaction.customId.replace('buy_stock_', '');
            const company = findCompany(companyId);
            
            if (!company) {
                await interaction.reply({ content: 'ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê¸°ì—…ì…ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            const portfolio = await getPlayerPortfolio(interaction.user.id);
            const maxShares = Math.floor(portfolio.cash / company.price);
            
            if (maxShares === 0) {
                await interaction.reply({ content: 'ìê¸ˆì´ ë¶€ì¡±í•©ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            // ë§¤ìˆ˜ ëª¨ë‹¬ ìƒì„±
            const buyModal = new ModalBuilder()
                .setCustomId(`buy_modal_${companyId}`)
                .setTitle(`${company.name} ë§¤ìˆ˜`);
            
            const sharesInput = new TextInputBuilder()
                .setCustomId('shares')
                .setLabel('ë§¤ìˆ˜í•  ì£¼ì‹ ìˆ˜ëŸ‰')
                .setStyle(TextInputStyle.Short)
                .setPlaceholder(`1 ~ ${maxShares}ì£¼`)
                .setRequired(true)
                .setMaxLength(10);
            
            const firstActionRow = new ActionRowBuilder().addComponents(sharesInput);
            buyModal.addComponents(firstActionRow);
            
            await interaction.showModal(buyModal);
        }
        
        // ì£¼ì‹ ë§¤ë„
        else if (interaction.customId.startsWith('sell_stock_')) {
            console.log('ğŸ’¸ ì£¼ì‹ ë§¤ë„ ë²„íŠ¼ í´ë¦­ë¨:', interaction.customId);
            const companyId = interaction.customId.replace('sell_stock_', '');
            const company = findCompany(companyId);
            
            if (!company) {
                await interaction.reply({ content: 'ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê¸°ì—…ì…ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            const portfolio = await getPlayerPortfolio(interaction.user.id);
            const holding = portfolio.stocks.get(companyId);
            
            if (!holding || holding.shares === 0) {
                await interaction.reply({ content: 'ë³´ìœ í•œ ì£¼ì‹ì´ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            // ë§¤ë„ ëª¨ë‹¬ ìƒì„±
            const sellModal = new ModalBuilder()
                .setCustomId(`sell_modal_${companyId}`)
                .setTitle(`${company.name} ë§¤ë„`);
            
            const sharesInput = new TextInputBuilder()
                .setCustomId('shares')
                .setLabel('ë§¤ë„í•  ì£¼ì‹ ìˆ˜ëŸ‰')
                .setStyle(TextInputStyle.Short)
                .setPlaceholder(`1 ~ ${holding.shares}ì£¼`)
                .setRequired(true)
                .setMaxLength(10);
            
            const firstActionRow = new ActionRowBuilder().addComponents(sharesInput);
            sellModal.addComponents(firstActionRow);
            
            await interaction.showModal(sellModal);
        }
        
        // ì— ë¸”ëŸ¼ êµ¬ë§¤
        else if (interaction.customId.startsWith('buy_emblem_')) {
            // ì¸í„°ë™ì…˜ì„ ì¦‰ì‹œ deferí•˜ì—¬ í† í° ë§Œë£Œ ë°©ì§€
            await interaction.deferReply({ flags: 64 });
            
            const parts = interaction.customId.split('_');
            const category = parts[2];
            const emblemIndex = parseInt(parts[3]);

            const emblemData = EMBLEMS[category];
            if (!emblemData || !emblemData.emblems[emblemIndex]) {
                await interaction.editReply({ content: 'ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì— ë¸”ëŸ¼ì…ë‹ˆë‹¤!' });
                return;
            }

            const emblem = emblemData.emblems[emblemIndex];

            // ì¬í™•ì¸
            if (user.emblem) {
                await interaction.editReply({ content: 'ì´ë¯¸ ì— ë¸”ëŸ¼ì„ ë³´ìœ í•˜ê³  ìˆìŠµë‹ˆë‹¤!' });
                return;
            }

            if (user.level < emblem.level) {
                await interaction.editReply({ content: `ë ˆë²¨ì´ ë¶€ì¡±í•©ë‹ˆë‹¤! (í•„ìš”: Lv.${emblem.level}, í˜„ì¬: Lv.${user.level})` });
                return;
            }

            if (user.gold < emblem.price) {
                await interaction.editReply({ content: 'ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!' });
                return;
            }

            // êµ¬ë§¤ ì²˜ë¦¬
            user.gold -= emblem.price;
            user.emblem = emblem.name;
            await user.save();

            // Discord ì—­í•  ë¶€ì—¬
            try {
                const guild = interaction.guild;
                let role = guild.roles.cache.find(r => r.name === emblem.roleName);
                
                if (!role) {
                    role = await guild.roles.create({
                        name: emblem.roleName,
                        color: '#FF6B00',
                        reason: 'ì— ë¸”ëŸ¼ ì‹œìŠ¤í…œ ìë™ ìƒì„±'
                    });
                }

                const member = await guild.members.fetch(interaction.user.id);
                await member.roles.add(role);
            } catch (error) {
                console.error('ì—­í•  ë¶€ì—¬ ì˜¤ë¥˜:', error);
            }

            const purchaseEmbed = new EmbedBuilder()
                .setColor('#00ff00')
                .setTitle('ğŸ† ì— ë¸”ëŸ¼ êµ¬ë§¤ ì„±ê³µ!')
                .setDescription(`**${emblem.name}** ì— ë¸”ëŸ¼ì„ ì„±ê³µì ìœ¼ë¡œ êµ¬ë§¤í–ˆìŠµë‹ˆë‹¤!`)
                .addFields(
                    { name: 'ğŸ’ íšë“í•œ ì¹­í˜¸', value: emblem.name, inline: true },
                    { name: 'ğŸ’° ê²°ì œ ê¸ˆì•¡', value: `${emblem.price.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true },
                    { name: 'ğŸ’° ì”ì—¬ ê³¨ë“œ', value: `${user.gold.toLocaleString()}<:currency_emoji:1377404064316522778>`, inline: true }
                )
                .setFooter({ text: 'ì´ì œ ê²Œì„ì—ì„œ ìƒˆë¡œìš´ ì¹­í˜¸ë¡œ í‘œì‹œë©ë‹ˆë‹¤!' });

            await interaction.editReply({
                embeds: [purchaseEmbed]
            });
        }

        // ëª¬ìŠ¤í„° ë°°í‹€ ì°¸ê°€ ë²„íŠ¼
        else if (interaction.customId === 'monster_battle') {
            console.log('âš”ï¸ ëª¬ìŠ¤í„° ë°°í‹€(í™€ì§) ë²„íŠ¼ í´ë¦­ë¨!');
            try {
                await oddEvenGame.showBettingMenu(interaction);
            } catch (error) {
                console.error('ëª¬ìŠ¤í„° ë°°í‹€ ë©”ë‰´ í‘œì‹œ ì˜¤ë¥˜:', error);
                if (!interaction.replied && !interaction.deferred) {
                    await interaction.reply({ content: 'ëª¬ìŠ¤í„° ë°°í‹€ ë©”ë‰´ë¥¼ í‘œì‹œí•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.', flags: 64 });
                }
            }
        }
        
        // í™€ì§ ê²Œì„ ë² íŒ… ë©”ë‰´
        else if (interaction.customId === 'oddeven_bet') {
            await oddEvenGame.showBettingMenu(interaction);
        }
        
        // í™€ì§ ê²Œì„ ì‹œì‘ ë²„íŠ¼ (ê²Œì„ ë©”ë‰´ì—ì„œ)
        else if (interaction.customId === 'oddeven_play') {
            console.log('ğŸ² í™€ì§ ê²Œì„ ì‹œì‘ ë²„íŠ¼ í´ë¦­ë¨!');
            await oddEvenGame.showMonsterBattleMenu(interaction);
        }

        // ëª¬ìŠ¤í„° ë°°í‹€ í†µê³„
        else if (interaction.customId === 'monster_stats') {
            // ëª¬ìŠ¤í„° ë°°í‹€ í†µê³„ ì²˜ë¦¬ (ì¶”í›„ êµ¬í˜„)
            await interaction.reply({ content: 'ëª¬ìŠ¤í„° í—Œí„° í†µê³„ ê¸°ëŠ¥ì´ ê³§ ì¶œì‹œë©ë‹ˆë‹¤!', flags: 64 });
        }
        
        // í™€ì§ ê²Œì„ í†µê³„
        else if (interaction.customId === 'oddeven_stats') {
            // í™€ì§ ê²Œì„ í†µê³„ ì²˜ë¦¬ (ì¶”í›„ êµ¬í˜„)
            await interaction.reply({ content: 'í™€ì§ ê²Œì„ í†µê³„ ê¸°ëŠ¥ì´ ê³§ ì¶œì‹œë©ë‹ˆë‹¤!', flags: 64 });
        }

        // ëª¬ìŠ¤í„° ë°°í‹€ ê¸°ë¡
        else if (interaction.customId === 'monster_history') {
            // ëª¬ìŠ¤í„° ë°°í‹€ ê¸°ë¡ ì²˜ë¦¬ (ì¶”í›„ êµ¬í˜„)
            await interaction.reply({ content: 'ë°°í‹€ íˆìŠ¤í† ë¦¬ ê¸°ëŠ¥ì´ ê³§ ì¶œì‹œë©ë‹ˆë‹¤!', flags: 64 });
        }

        // í™€ì§ ê²Œì„ ê¸°ë¡
        else if (interaction.customId === 'oddeven_history') {
            // í™€ì§ ê²Œì„ ê¸°ë¡ ì²˜ë¦¬ (ì¶”í›„ êµ¬í˜„)
            await interaction.reply({ content: 'í™€ì§ ê²Œì„ ê¸°ë¡ ê¸°ëŠ¥ì´ ê³§ ì¶œì‹œë©ë‹ˆë‹¤!', flags: 64 });
        }

        // ëª¬ìŠ¤í„° ë°°í‹€ ë­í‚¹
        else if (interaction.customId === 'monster_ranking') {
            // ëª¬ìŠ¤í„° ë°°í‹€ ë­í‚¹ ì²˜ë¦¬ (ì¶”í›„ êµ¬í˜„)
            await interaction.reply({ content: 'í—Œí„° ë­í‚¹ ê¸°ëŠ¥ì´ ê³§ ì¶œì‹œë©ë‹ˆë‹¤!', flags: 64 });
        }

        // í™€ì§ ê²Œì„ ë­í‚¹
        else if (interaction.customId === 'oddeven_ranking') {
            // í™€ì§ ê²Œì„ ë­í‚¹ ì²˜ë¦¬ (ì¶”í›„ êµ¬í˜„)
            await interaction.reply({ content: 'í™€ì§ ê²Œì„ ë­í‚¹ ê¸°ëŠ¥ì´ ê³§ ì¶œì‹œë©ë‹ˆë‹¤!', flags: 64 });
        }

        // í™€ì§ ë² íŒ… ë²„íŠ¼ë“¤
        else if (interaction.customId.startsWith('bet_')) {
            const betType = interaction.customId.replace('bet_', '');
            
            // ì­íŒŸ ë² íŒ…ì€ ìˆ«ìë„ ì…ë ¥ë°›ì•„ì•¼ í•¨
            if (betType === 'jackpot') {
                const modal = new ModalBuilder()
                    .setCustomId(`jackpot_modal`)
                    .setTitle('ğŸ’ ì­íŒŸ ë² íŒ…');

                const amountInput = new TextInputBuilder()
                    .setCustomId('bet_amount')
                    .setLabel('ë² íŒ… ê¸ˆì•¡')
                    .setStyle(TextInputStyle.Short)
                    .setPlaceholder('1000 ~ 1000000')
                    .setRequired(true);

                const numberInput = new TextInputBuilder()
                    .setCustomId('target_number')
                    .setLabel('ì˜ˆìƒ ìˆ«ì (1-100)')
                    .setStyle(TextInputStyle.Short)
                    .setPlaceholder('1ë¶€í„° 100ê¹Œì§€ì˜ ìˆ«ì')
                    .setRequired(true);

                const firstRow = new ActionRowBuilder().addComponents(amountInput);
                const secondRow = new ActionRowBuilder().addComponents(numberInput);
                modal.addComponents(firstRow, secondRow);

                await interaction.showModal(modal);
            } else {
                // ì¼ë°˜ ë² íŒ… (ê¸ˆì•¡ë§Œ ì…ë ¥)
                const modal = new ModalBuilder()
                    .setCustomId(`bet_modal_${betType}`)
                    .setTitle(`${MONSTER_BATTLE.betOptions[betType]?.emoji || 'ğŸ²'} ${MONSTER_BATTLE.betOptions[betType]?.name || betType} ë² íŒ…`);

                const amountInput = new TextInputBuilder()
                    .setCustomId('bet_amount')
                    .setLabel('ë² íŒ… ê¸ˆì•¡')
                    .setStyle(TextInputStyle.Short)
                    .setPlaceholder('1000 ~ 1000000')
                    .setRequired(true);

                const row = new ActionRowBuilder().addComponents(amountInput);
                modal.addComponents(row);

                await interaction.showModal(modal);
            }
        }

        // í™€ì§ ê²Œì„ ë’¤ë¡œê°€ê¸°
        else if (interaction.customId === 'oddeven_back') {
            try {
                await oddEvenGame.showMonsterBattleMenu(interaction);
            } catch (error) {
                console.error('í™€ì§ ê²Œì„ ë’¤ë¡œê°€ê¸° ì˜¤ë¥˜:', error);
                if (!interaction.replied && !interaction.deferred) {
                    await interaction.reply({ content: 'ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.', flags: 64 });
                }
            }
        }

        // í™€ì§ ê²Œì„ ë‹¤ì‹œí•˜ê¸°
        else if (interaction.customId === 'oddeven_play_again') {
            try {
                await oddEvenGame.showBettingMenu(interaction);
            } catch (error) {
                console.error('í™€ì§ ê²Œì„ ë‹¤ì‹œí•˜ê¸° ì˜¤ë¥˜:', error);
                if (!interaction.replied && !interaction.deferred) {
                    await interaction.reply({ content: 'ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.', flags: 64 });
                }
            }
        }

        // í™€ì§ ê²Œì„ ë©”ì¸ìœ¼ë¡œ
        else if (interaction.customId === 'oddeven_main') {
            try {
                await oddEvenGame.showMonsterBattleMenu(interaction);
            } catch (error) {
                console.error('í™€ì§ ê²Œì„ ë©”ì¸ ì˜¤ë¥˜:', error);
                if (!interaction.replied && !interaction.deferred) {
                    await interaction.reply({ content: 'ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.', flags: 64 });
                }
            }
        }
        
        // ê²Œì„ ë©”ì¸ ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸°
        else if (interaction.customId === 'game_main_menu') {
            console.log('ğŸ  ê²Œì„ ë©”ì¸ ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸° ë²„íŠ¼ í´ë¦­ë¨!');
            await showGameMenu(interaction);
        }
        
        // ì—ë„ˆì§€ ì±„êµ´
        else if (interaction.customId === 'energy_mine') {
            const user = await getUser(interaction.user.id);
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            // ì±„êµ´ ì¿¨ë‹¤ìš´ ì²´í¬
            const lastMine = user.energyFragments?.lastMine;
            if (lastMine) {
                const cooldown = 2 * 60 * 1000; // 2ë¶„
                const timeLeft = cooldown - (Date.now() - new Date(lastMine).getTime());
                
                if (timeLeft > 0) {
                    const minutes = Math.floor(timeLeft / 60000);
                    const seconds = Math.floor((timeLeft % 60000) / 1000);
                    await interaction.reply({ 
                        content: `â³ ì±„êµ´ ì¿¨íƒ€ì„ì´ ${minutes}ë¶„ ${seconds}ì´ˆ ë‚¨ì•˜ìŠµë‹ˆë‹¤!`, 
                        flags: 64 
                    });
                    return;
                }
            }
            
            // ê³¨ë“œ ì²´í¬
            const mineCost = 500;
            if (user.gold < mineCost) {
                await interaction.reply({ 
                    content: `ğŸ’° ì±„êµ´í•˜ë ¤ë©´ ${mineCost} ê³¨ë“œê°€ í•„ìš”í•©ë‹ˆë‹¤! (í˜„ì¬: ${user.gold} ê³¨ë“œ)`, 
                    flags: 64 
                });
                return;
            }
            
            // ì±„êµ´ ì‹¤í–‰
            user.gold -= mineCost;
            
            // ëœë¤ ì¡°ê° íšë“ (1-3ë ˆë²¨)
            const fragmentLevel = Math.floor(Math.random() * 3) + 1;
            const fragmentCount = Math.floor(Math.random() * 3) + 1;
            
            if (!user.energyFragments) {
                user.energyFragments = {
                    fragments: new Map(),
                    lastMine: new Date(),
                    dailyFusions: 0,
                    dailyFusionDate: null,
                    totalFusions: 0,
                    successfulFusions: 0,
                    failureStack: 0,
                    highestLevel: 0,
                    fusionTickets: 0,
                    permanentSuccessBonus: 0,
                    weeklyRankingBonus: 0,
                    consecutiveSuccess: 0,
                    totalInvested: 0,
                    godBlessingUsed: null
                };
            }
            
            const currentCount = user.energyFragments.fragments.get(String(fragmentLevel)) || 0;
            user.energyFragments.fragments.set(String(fragmentLevel), currentCount + fragmentCount);
            user.energyFragments.lastMine = new Date();
            
            user.markModified('energyFragments');
            await user.save();
            
            const mineEmbed = new EmbedBuilder()
                .setColor('#00ff00')
                .setTitle('â›ï¸ ì—ë„ˆì§€ ì±„êµ´ ì„±ê³µ!')
                .setDescription(`Lv.${fragmentLevel} ì—ë„ˆì§€ ì¡°ê° ${fragmentCount}ê°œë¥¼ íšë“í–ˆìŠµë‹ˆë‹¤!`)
                .addFields(
                    { name: 'ğŸ’° ì‚¬ìš© ê³¨ë“œ', value: `${mineCost} ê³¨ë“œ`, inline: true },
                    { name: 'ğŸ’ íšë“ ì¡°ê°', value: `Lv.${fragmentLevel} x${fragmentCount}ê°œ`, inline: true },
                    { name: 'ğŸ’µ ë‚¨ì€ ê³¨ë“œ', value: `${user.gold.toLocaleString()} ê³¨ë“œ`, inline: true }
                )
                .setFooter({ text: '2ë¶„ í›„ ë‹¤ì‹œ ì±„êµ´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.' });
                
            await interaction.reply({ embeds: [mineEmbed], flags: 64 });
        }
        
        // ì—ë„ˆì§€ ìœµí•©
        else if (interaction.customId === 'energy_fusion') {
            await showEnergyFusionMenu(interaction);
        }
        
        // ì¡°ê° ìë™ ìœµí•©
        else if (interaction.customId === 'fragment_auto_fusion') {
            const user = await getUser(interaction.user.id);
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            // ìë™ ìœµí•© ì‹¤í–‰ (ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œì™€ ë™ì¼í•œ ë¡œì§)
            const autoFusionCommand = client.application.commands.cache.find(cmd => cmd.name === 'ì¡°ê°ìœµí•©');
            if (autoFusionCommand) {
                // ìë™ ìœµí•© ë¡œì§ ì‹¤í–‰
                await interaction.deferReply({ flags: 64 });
                
                // ê¸°ì¡´ ì¡°ê°ìœµí•© ëª…ë ¹ì–´ì˜ execute ë¡œì§ì„ ì—¬ê¸°ì„œ ì‹¤í–‰
                // ê°„ë‹¨íˆ ë©”ì‹œì§€ë§Œ í‘œì‹œ
                await interaction.editReply({ content: 'ğŸ”„ ìë™ ìœµí•©ì„ ì‹œì‘í•©ë‹ˆë‹¤...\n/ì¡°ê°ìœµí•© ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•´ì£¼ì„¸ìš”!' });
            }
        }
        
        // ì¡°ê° ìˆ˜ë™ ìœµí•©
        else if (interaction.customId === 'fragment_manual_fusion') {
            const user = await getUser(interaction.user.id);
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            await interaction.reply({ content: 'ğŸ¯ ìˆ˜ë™ ìœµí•©ì„ ì‹œì‘í•©ë‹ˆë‹¤...\n/ìœµí•©ìˆ˜ë™ ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•´ì£¼ì„¸ìš”!', flags: 64 });
        }
        
        // ìœµí•© ì •ë³´
        else if (interaction.customId === 'fusion_info') {
            const infoEmbed = new EmbedBuilder()
                .setColor('#00ffff')
                .setTitle('âš¡ ì—ë„ˆì§€ ìœµí•© ì‹œìŠ¤í…œ ê°€ì´ë“œ')
                .setDescription('ì—ë„ˆì§€ ì¡°ê°ì„ ìœµí•©í•˜ì—¬ ë” ë†’ì€ ë ˆë²¨ì˜ ì¡°ê°ì„ ë§Œë“œëŠ” ì‹œìŠ¤í…œì…ë‹ˆë‹¤.')
                .addFields(
                    { name: 'â›ï¸ ì¡°ê° íšë“', value: '- ì±„êµ´: 500ê³¨ë“œë¡œ Lv.1~3 ì¡°ê° íšë“\n- ì¿¨íƒ€ì„: 2ë¶„', inline: false },
                    { name: 'ğŸ”„ ìœµí•© ë°©ì‹', value: '- ê°™ì€ ë ˆë²¨ ì¡°ê° 3ê°œ â†’ ë‹¤ìŒ ë ˆë²¨ 1ê°œ\n- ì„±ê³µë¥ : 85%(1-10) â†’ 70%(11-25) â†’ 50%(26+)', inline: false },
                    { name: 'ğŸ“ˆ ì‹¤íŒ¨ ìŠ¤íƒ', value: '- ì‹¤íŒ¨ ì‹œ 50% í™•ë¥ ë¡œ ìŠ¤íƒ íšë“\n- 10ìŠ¤íƒ = 100% ì„±ê³µ ë³´ì¥', inline: false },
                    { name: 'ğŸ¯ ë³´ë„ˆìŠ¤', value: '- ê°•í™” +20/+25/+30: ì„±ê³µë¥  +5%/+10%/+15%\n- ì¼ì¼ ì œí•œ: 20íšŒ (ìœµí•©ê¶Œ ì‚¬ìš© ì‹œ ë¬´ì œí•œ)', inline: false }
                );
                
            await interaction.reply({ embeds: [infoEmbed], flags: 64 });
        }
        
        // ìœµí•© ëŒì•„ê°€ê¸°
        else if (interaction.customId === 'fusion_back') {
            const fusionMenu = MENU_ITEMS['fusion'];
            const menuEmbed = new EmbedBuilder()
                .setColor('#ff1493')
                .setTitle('âš¡ ì—ë„ˆì§€ ìœµí•© ì‹œìŠ¤í…œ')
                .setDescription('ì—ë„ˆì§€ ì¡°ê°ì„ ìœµí•©í•˜ì—¬ ë” ë†’ì€ ë“±ê¸‰ì˜ ì¡°ê°ì„ ë§Œë“¤ì–´ë³´ì„¸ìš”!');
            
            const menuButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('energy_mine')
                        .setLabel('â›ï¸ ì—ë„ˆì§€ ì±„êµ´')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('energy_fusion')
                        .setLabel('âœ¨ ì—ë„ˆì§€ ìœµí•©')
                        .setStyle(ButtonStyle.Success),
                    new ButtonBuilder()
                        .setCustomId('fusion_ranking')
                        .setLabel('ğŸ† ìœµí•© ë­í‚¹')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            await interaction.update({ embeds: [menuEmbed], components: [menuButtons] });
        }

        // í™€ì§ ê²Œì„ ì‹œì‘
        else if (interaction.customId === 'start_game') {
            try {
                await oddEvenGame.playMultipleBets(interaction);
            } catch (error) {
                console.error('í™€ì§ ê²Œì„ ì‹œì‘ ì˜¤ë¥˜:', error);
                if (!interaction.replied && !interaction.deferred) {
                    await interaction.reply({ content: 'ê²Œì„ ì‹œì‘ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.', flags: 64 });
                }
            }
        }

        // í™€ì§ ê²Œì„ ë² íŒ… ì´ˆê¸°í™”
        else if (interaction.customId === 'clear_bets') {
            try {
                const user = await User.findOne({ discordId: interaction.user.id });
                if (user.oddEvenStats?.currentBets) {
                    user.oddEvenStats.currentBets = [];
                    await user.save();
                }
                await oddEvenGame.showBettingMenu(interaction);
            } catch (error) {
                console.error('ë² íŒ… ì´ˆê¸°í™” ì˜¤ë¥˜:', error);
                if (!interaction.replied && !interaction.deferred) {
                    await interaction.reply({ content: 'ë² íŒ… ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.', flags: 64 });
                }
            }
        }
        
        // ğŸ„ ë…ë²„ì„¯ ê²Œì„ ë²„íŠ¼ í•¸ë“¤ëŸ¬
        else if (interaction.customId.startsWith('mushroom_start_')) {
            const userId = interaction.customId.split('_')[2];
            if (userId !== interaction.user.id) {
                await interaction.reply({ content: 'ë‹¤ë¥¸ í”Œë ˆì´ì–´ì˜ ê²Œì„ì…ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            await mushroomGame.startRound(interaction, userId);
        }
        
        else if (interaction.customId.startsWith('mushroom_select_')) {
            const parts = interaction.customId.split('_');
            const userId = parts[2];
            const position = parseInt(parts[3]);
            
            if (userId !== interaction.user.id) {
                await interaction.reply({ content: 'ë‹¤ë¥¸ í”Œë ˆì´ì–´ì˜ ê²Œì„ì…ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            await mushroomGame.processMushroomSelection(interaction, userId, position);
        }
        
        else if (interaction.customId.startsWith('mushroom_continue_')) {
            const userId = interaction.customId.split('_')[2];
            if (userId !== interaction.user.id) {
                await interaction.reply({ content: 'ë‹¤ë¥¸ í”Œë ˆì´ì–´ì˜ ê²Œì„ì…ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            await mushroomGame.startRound(interaction, userId);
        }
        
        else if (interaction.customId.startsWith('mushroom_end_')) {
            const userId = interaction.customId.split('_')[2];
            if (userId !== interaction.user.id) {
                await interaction.reply({ content: 'ë‹¤ë¥¸ í”Œë ˆì´ì–´ì˜ ê²Œì„ì…ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            await mushroomGame.endGame(interaction, userId);
        }
        
        else if (interaction.customId.startsWith('mushroom_cancel_')) {
            const userId = interaction.customId.split('_')[2];
            if (userId !== interaction.user.id) {
                await interaction.reply({ content: 'ë‹¤ë¥¸ í”Œë ˆì´ì–´ì˜ ë§¤ì¹­ì…ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            if (mushroomMatchmakingQueue.has(userId)) {
                mushroomMatchmakingQueue.delete(userId);
                
                const cancelEmbed = new EmbedBuilder()
                    .setColor('#808080')
                    .setTitle('âŒ ë§¤ì¹­ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤')
                    .setDescription('ì–¸ì œë“ ì§€ ë‹¤ì‹œ ë„ì „í•´ë³´ì„¸ìš”!');

                await interaction.update({
                    embeds: [cancelEmbed],
                    components: []
                });
            }
        }
        
        // ì „ì²´ ê¸°ì—… ì°¨íŠ¸ ë²„íŠ¼ ì²˜ë¦¬
        else if (interaction.customId === 'all_companies_chart') {
            await interaction.deferUpdate();
            
            try {
                // ëª¨ë“  ê¸°ì—… ìˆ˜ì§‘
                const allCompanies = [];
                for (const regionKey of Object.keys(STOCK_MARKET.regions)) {
                    const region = STOCK_MARKET.regions[regionKey];
                    region.companies.forEach(company => {
                        allCompanies.push({
                            ...company,
                            region: region.name
                        });
                    });
                }
                
                STOCK_MARKET.chains.forEach(company => {
                    allCompanies.push({
                        ...company,
                        region: 'ğŸŒ ì „ì§€ì—­'
                    });
                });
                
                // 25ê°œì”© í˜ì´ì§€ ë‚˜ëˆ„ê¸°
                const itemsPerPage = 25;
                const totalPages = Math.ceil(allCompanies.length / itemsPerPage);
                const currentPage = 0;
                const startIndex = currentPage * itemsPerPage;
                const currentCompanies = allCompanies.slice(startIndex, startIndex + itemsPerPage);
                
                // ì „ì²´ ê¸°ì—… ì„ íƒ ë©”ë‰´ ìƒì„± (Discordì˜ 25ê°œ ì œí•œ)
                const companyOptions = currentCompanies.map((company, index) => {
                    const chartHistory = STOCK_MARKET.chart_history;
                    let changeText = '';
                    
                    if (chartHistory.top_companies[company.id] && chartHistory.top_companies[company.id].length > 1) {
                        const prices = chartHistory.top_companies[company.id];
                        const change = ((prices[prices.length - 1] - prices[0]) / prices[0] * 100).toFixed(1);
                        changeText = ` (${change > 0 ? '+' : ''}${change}%)`;
                    }
                    
                    return {
                        label: company.name + changeText,
                        description: `${company.region} | ${company.price.toLocaleString()}G`,
                        value: `company_chart_${company.id}`
                    };
                });
                
                const allCompanySelect = new StringSelectMenuBuilder()
                    .setCustomId('select_company_chart')
                    .setPlaceholder('ì „ì²´ ê¸°ì—… ëª©ë¡ì—ì„œ ì„ íƒí•˜ì„¸ìš”')
                    .addOptions(companyOptions);
                
                const selectRow = new ActionRowBuilder().addComponents(allCompanySelect);
                
                const navigationButtons = new ActionRowBuilder()
                    .addComponents(
                        new ButtonBuilder()
                            .setCustomId('company_charts')
                            .setLabel('ğŸ”™ ìƒìœ„ ê¸°ì—…ë§Œ')
                            .setStyle(ButtonStyle.Secondary),
                        new ButtonBuilder()
                            .setCustomId('stock_chart')
                            .setLabel('ğŸ“Š ì „ì²´ ì°¨íŠ¸')
                            .setStyle(ButtonStyle.Primary)
                    );
                
                const embed = new EmbedBuilder()
                    .setColor('#9b59b6')
                    .setTitle('ğŸ“Š ì „ì²´ ê¸°ì—… ì°¨íŠ¸ ì„ íƒ')
                    .setDescription(`ëª¨ë“  ê¸°ì—…ì˜ ê°œë³„ ì°¨íŠ¸ë¥¼ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n\n**ì´ ${allCompanies.length}ê°œ ê¸°ì—…** (í˜ì´ì§€ ${currentPage + 1}/${totalPages})`)
                    .addFields(
                        { 
                            name: 'ğŸ“‹ ê¸°ì—… ëª©ë¡', 
                            value: currentCompanies.map((c, i) => `${startIndex + i + 1}. **${c.name}** (${c.region})`).join('\n'), 
                            inline: false 
                        }
                    );
                
                await interaction.editReply({
                    embeds: [embed],
                    components: [selectRow, navigationButtons],
                    files: []
                });
                
            } catch (error) {
                console.error('ì „ì²´ ê¸°ì—… ì°¨íŠ¸ ì˜¤ë¥˜:', error);
                await interaction.editReply({
                    content: 'âŒ ì „ì²´ ê¸°ì—… ì°¨íŠ¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
                    embeds: [],
                    components: []
                });
            }
        }
        
        // ë‚´ ì£¼ì‹ ë³µêµ¬ ë²„íŠ¼
        else if (interaction.customId === 'recover_my_stocks') {
            await interaction.deferReply({ flags: 64 });
            
            try {
                const user = await User.findOne({ discordId: interaction.user.id });
                if (!user) {
                    await interaction.editReply({ content: 'âŒ ìœ ì € ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!' });
                    return;
                }
                
                // ì˜ˆì‹œ ë³µêµ¬ (ì‹¤ì œ ìƒí™©ì— ë§ê²Œ ìˆ˜ì • í•„ìš”)
                if (!user.stockPortfolio) {
                    user.stockPortfolio = { stocks: new Map(), totalInvested: 0, lastUpdate: new Date() };
                }
                
                // ì„ì‹œ ë³µêµ¬ - ì—¬í–‰ì ì—¬ê´€ 1ì£¼
                user.stockPortfolio.stocks.set('traveler_inn', {
                    shares: 1,
                    avgPrice: 1379
                });
                
                await user.save();
                
                await interaction.editReply({ 
                    content: 'âœ… ì£¼ì‹ ë°ì´í„°ê°€ ë³µêµ¬ë˜ì—ˆìŠµë‹ˆë‹¤!\nğŸ¨ ì—¬í–‰ì ì—¬ê´€: 1ì£¼ (í‰ê· ê°€: 1,379ê³¨ë“œ)\n\n**ì‹¤ì œ ë³´ìœ í•˜ì‹  ì£¼ì‹ì´ ë‹¤ë¥´ë‹¤ë©´ ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•´ì£¼ì„¸ìš”.**' 
                });
                
            } catch (error) {
                console.error('ì£¼ì‹ ë³µêµ¬ ì˜¤ë¥˜:', error);
                await interaction.editReply({ content: 'âŒ ì£¼ì‹ ë³µêµ¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤!' });
            }
        }
        
        // ì£¼ì‹ ë„ì›€ë§ ë²„íŠ¼
        else if (interaction.customId === 'stock_help') {
            const helpEmbed = new EmbedBuilder()
                .setColor('#3498db')
                .setTitle('ğŸ“ˆ ì£¼ì‹ ì‹œìŠ¤í…œ ë„ì›€ë§')
                .setDescription('ê¹€í—Œí„° ì£¼ì‹ ì‹œìŠ¤í…œ ì‚¬ìš©ë²•ì„ ì•ˆë‚´í•´ë“œë¦½ë‹ˆë‹¤!')
                .addFields(
                    { name: 'ğŸ“Š ê¸°ë³¸ ì‚¬ìš©ë²•', value: 'â€¢ ì§€ì—­ë³„/ì²´ì¸ ê¸°ì—…ì—ì„œ ì£¼ì‹ ë§¤ìˆ˜/ë§¤ë„\nâ€¢ í¬íŠ¸í´ë¦¬ì˜¤ì—ì„œ ë³´ìœ  í˜„í™© í™•ì¸\nâ€¢ ì°¨íŠ¸ì—ì„œ ì£¼ê°€ ë™í–¥ ë¶„ì„', inline: false },
                    { name: 'ğŸ’° ë§¤ìˆ˜/ë§¤ë„', value: 'â€¢ ê¸°ì—… ì„ íƒ â†’ ë§¤ìˆ˜/ë§¤ë„ ë²„íŠ¼ í´ë¦­\nâ€¢ íŒì—…ì°½ì—ì„œ ìˆ˜ëŸ‰ ì…ë ¥\nâ€¢ ì‹¤ì‹œê°„ ì£¼ê°€ë¡œ ê±°ë˜ ì²´ê²°', inline: false },
                    { name: 'ğŸ”§ ë°ì´í„° ë³µêµ¬', value: 'â€¢ ë´‡ ì¬ì‹œì‘ìœ¼ë¡œ ì£¼ì‹ì´ ì‚¬ë¼ì§„ ê²½ìš°\nâ€¢ "ë‚´ ì£¼ì‹ ë³µêµ¬" ë²„íŠ¼ í´ë¦­\nâ€¢ ê´€ë¦¬ìì—ê²Œ ì •í™•í•œ ë³µêµ¬ ìš”ì²­', inline: false },
                    { name: 'ğŸ“ˆ ì°¨íŠ¸ ê¸°ëŠ¥', value: 'â€¢ ì‹¤ì‹œê°„ ì‹œì¥ ì°¨íŠ¸\nâ€¢ ê°œë³„ ê¸°ì—… ì°¨íŠ¸\nâ€¢ ì „ì²´ ê¸°ì—… ëª©ë¡ ì¡°íšŒ', inline: false }
                )
                .setFooter({ text: 'ì£¼ì‹ íˆ¬ìëŠ” ì‹ ì¤‘í•˜ê²Œ! ê°€ê²© ë³€ë™ì— ìœ ì˜í•˜ì„¸ìš”.' });
            
            await interaction.reply({ embeds: [helpEmbed], flags: 64 });
        }
        
        // ìƒì  êµ¬ë§¤ í™•ì¸ ë²„íŠ¼
        else if (interaction.customId.startsWith('confirm_buy_')) {
            const [_, __, category, itemIndex] = interaction.customId.split('_');
            const categoryData = SHOP_CATEGORIES[category];
            const item = categoryData.items[parseInt(itemIndex)];
            
            if (!item) {
                await interaction.reply({ content: 'âŒ ì•„ì´í…œì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            const user = await getUser(interaction.user.id);
            
            if (user.gold < item.price) {
                await interaction.reply({ content: 'âŒ ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            // ì¸ë²¤í† ë¦¬ì— ë¹ˆ ìŠ¬ë¡¯ ì°¾ê¸°
            let emptySlot = -1;
            for (let i = 0; i < user.maxInventorySlots; i++) {
                if (!user.inventory.find(item => item.inventorySlot === i)) {
                    emptySlot = i;
                    break;
                }
            }
            
            if (emptySlot === -1) {
                await interaction.reply({ content: 'âŒ ì¸ë²¤í† ë¦¬ê°€ ê°€ë“ ì°¼ìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            // ëœë¤ ìŠ¤íƒ¯ ìƒì„±
            const randomStats = generateRandomStats(item.stats);
            
            // ëœë¤ ì¶”ê°€ ì˜µì…˜ ìƒì„±
            const randomOptions = generateRandomOptions(item.rarity);
            
            // ê³¨ë“œ ì°¨ê° ë° ì•„ì´í…œ ì¶”ê°€
            user.gold -= item.price;
            user.inventory.push({
                id: item.id || `${category}_${itemIndex}_${Date.now()}`, // idê°€ ì—†ìœ¼ë©´ ì„ì‹œ ìƒì„±
                name: item.name,
                type: item.type,
                rarity: item.rarity,
                setName: item.setName,
                level: item.level || 1,
                quantity: 1,
                enhanceLevel: 0,
                stats: randomStats,
                price: item.price,
                description: item.description,
                equipped: false,
                inventorySlot: emptySlot,
                randomOptions: randomOptions
            });
            
            await user.save();
            
            const successEmbed = new EmbedBuilder()
                .setColor('#00ff00')
                .setTitle('âœ… êµ¬ë§¤ ì™„ë£Œ!')
                .setDescription(`**${item.name}**ì„(ë¥¼) êµ¬ë§¤í–ˆìŠµë‹ˆë‹¤!`)
                .addFields(
                    { name: 'ì§€ë¶ˆí•œ ê³¨ë“œ', value: `${item.price.toLocaleString()}G`, inline: true },
                    { name: 'ë‚¨ì€ ê³¨ë“œ', value: `${user.gold.toLocaleString()}G`, inline: true }
                );
            
            await interaction.update({ embeds: [successEmbed], components: [] });
        }
        
        // ìƒì  êµ¬ë§¤ ì·¨ì†Œ ë²„íŠ¼
        else if (interaction.customId === 'cancel_buy') {
            await interaction.update({ content: 'âŒ êµ¬ë§¤ë¥¼ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.', embeds: [], components: [] });
        }
        
        // ìƒì  ì¹´í…Œê³ ë¦¬ë¡œ ëŒì•„ê°€ê¸° (ë²„íŠ¼ í´ë¦­ ì‹œ)
        else if (interaction.customId === 'shop' && interaction.isButton()) {
            await interaction.deferUpdate();
            
            const user = await getUser(interaction.user.id);
            const shopEmbed = new EmbedBuilder()
                .setColor('#00ff7f')
                .setTitle('ğŸ›’ ê¹€í—Œí„° ìƒì ')
                .setDescription('ì›í•˜ëŠ” ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•˜ì„¸ìš”\n\nğŸ’° ë³´ìœ  ê³¨ë“œ: ' + user.gold.toLocaleString() + 'G');
            
            // ì¹´í…Œê³ ë¦¬ ë“œë¡­ë‹¤ìš´ ë©”ë‰´
            const categoryOptions = [
                {
                    label: 'âš”ï¸ ë¬´ê¸°',
                    description: 'ë‹¤ì–‘í•œ ë¬´ê¸°ë¥¼ êµ¬ë§¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤',
                    value: 'shop_category_weapon',
                    emoji: 'âš”ï¸'
                },
                {
                    label: 'ğŸ›¡ï¸ ê°‘ì˜·',
                    description: 'íŠ¼íŠ¼í•œ ê°‘ì˜·ì„ êµ¬ë§¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤',
                    value: 'shop_category_armor',
                    emoji: 'ğŸ›¡ï¸'
                },
                {
                    label: 'â›‘ï¸ í—¬ë©§',
                    description: 'ë¨¸ë¦¬ë¥¼ ë³´í˜¸í•˜ëŠ” í—¬ë©§ì„ êµ¬ë§¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤',
                    value: 'shop_category_helmet',
                    emoji: 'â›‘ï¸'
                },
                {
                    label: 'ğŸ§¬ ì¥ê°‘',
                    description: 'ì†ì„ ë³´í˜¸í•˜ëŠ” ì¥ê°‘ì„ êµ¬ë§¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤',
                    value: 'shop_category_gloves',
                    emoji: 'ğŸ§¬'
                },
                {
                    label: 'ğŸ‘¢ ë¶€ì¸ ',
                    description: 'ë°œì„ ë³´í˜¸í•˜ëŠ” ë¶€ì¸ ë¥¼ êµ¬ë§¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤',
                    value: 'shop_category_boots',
                    emoji: 'ğŸ‘¢'
                },
                {
                    label: 'ğŸ’ ì•¡ì„¸ì„œë¦¬',
                    description: 'íŠ¹ë³„í•œ íš¨ê³¼ë¥¼ ê°€ì§„ ì•¡ì„¸ì„œë¦¬ë¥¼ êµ¬ë§¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤',
                    value: 'shop_category_accessory',
                    emoji: 'ğŸ’'
                }
            ];
            
            const categorySelectMenu = new StringSelectMenuBuilder()
                .setCustomId('shop_category_select')
                .setPlaceholder('ğŸ›ï¸ êµ¬ë§¤í•  ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•˜ì„¸ìš”')
                .addOptions(categoryOptions);
            
            const selectRow = new ActionRowBuilder().addComponents(categorySelectMenu);
            
            const backButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('back_to_game_menu')
                        .setLabel('ğŸ® ê²Œì„ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸°')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            await interaction.editReply({ 
                embeds: [shopEmbed], 
                components: [selectRow, backButton] 
            });
        }
        
        // ì¥ë¹„ ê°•í™” ë²„íŠ¼ ì²˜ë¦¬
        else if (interaction.customId === 'enhance') {
            await interaction.deferUpdate();
            
            const user = await getUser(interaction.user.id);
            if (!user || !user.registered) {
                await interaction.editReply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', embeds: [], components: [] });
                return;
            }
            
            // ì¥ì°©ëœ ì¥ë¹„ ì •ë³´ í‘œì‹œ
            const equipmentSlots = ['weapon', 'armor', 'helmet', 'gloves', 'boots', 'accessory'];
            const slotNames = {
                weapon: 'âš”ï¸ ë¬´ê¸°',
                armor: 'ğŸ›¡ï¸ ê°‘ì˜·',
                helmet: 'â›‘ï¸ í—¬ë©§',
                gloves: 'ğŸ§¤ ì¥ê°‘',
                boots: 'ğŸ‘¢ ë¶€ì¸ ',
                accessory: 'ğŸ’ ì•¡ì„¸ì„œë¦¬'
            };
            
            let equipmentInfo = '';
            let hasEquipment = false;
            
            for (const slot of equipmentSlots) {
                if (user.equipment[slot] !== -1 && user.equipment[slot] !== null) {
                    const item = user.inventory.find(inv => inv.inventorySlot === user.equipment[slot]);
                    if (item) {
                        hasEquipment = true;
                        const enhanceLevel = item.enhanceLevel || 0;
                        const itemLevel = ITEM_LEVELS[item.setName] || ITEM_LEVELS[item.name] || 1;
                        const cost = calculateEnhanceCost(itemLevel, enhanceLevel);
                        const successRate = calculateSuccessRate(enhanceLevel);
                        
                        equipmentInfo += `${slotNames[slot]}: **${item.name}** (+${enhanceLevel}ê°•)\n`;
                        equipmentInfo += `â”œ ê°•í™” ë¹„ìš©: ${cost.toLocaleString()}G\n`;
                        equipmentInfo += `â”œ ì„±ê³µë¥ : ${(successRate * 100).toFixed(1)}%\n`;
                        equipmentInfo += `â”” ë³´í˜¸ê¶Œ í•„ìš”: ${enhanceLevel >= 15 ? 'í•„ìˆ˜' : 'ì„ íƒ'}\n\n`;
                    }
                }
            }
            
            if (!hasEquipment) {
                await interaction.editReply({ 
                    content: 'âŒ ê°•í™”í•  ì¥ë¹„ê°€ ì—†ìŠµë‹ˆë‹¤! ë¨¼ì € ì¥ë¹„ë¥¼ ì¥ì°©í•´ì£¼ì„¸ìš”.', 
                    embeds: [], 
                    components: [] 
                });
                return;
            }
            
            const enhanceEmbed = new EmbedBuilder()
                .setColor('#ffd700')
                .setTitle('âš”ï¸ ì¥ë¹„ ê°•í™”')
                .setDescription('í˜„ì¬ ì°©ìš© ì¤‘ì¸ ì¥ë¹„ ëª©ë¡ì…ë‹ˆë‹¤.\nê°•í™”í•  ë¶€ìœ„ë¥¼ ì„ íƒí•˜ì„¸ìš”.')
                .addFields(
                    { name: 'ğŸ“‹ ì°©ìš© ì¥ë¹„', value: equipmentInfo || 'ì—†ìŒ', inline: false },
                    { name: 'ğŸ’° ë³´ìœ  ê³¨ë“œ', value: `${user.gold.toLocaleString()}G`, inline: true },
                    { name: 'ğŸ›¡ï¸ ë³´í˜¸ê¶Œ', value: `${user.protectionScrolls || 0}ê°œ`, inline: true },
                    { name: 'ğŸ“Š ê°•í™” í†µê³„', value: `ì„±ê³µ: ${user.enhanceStats?.successCount || 0}íšŒ\nì‹¤íŒ¨: ${(user.enhanceStats?.totalAttempts || 0) - (user.enhanceStats?.successCount || 0)}íšŒ`, inline: true }
                );
            
            // ì¥ì°©ëœ ì¥ë¹„ ë¶€ìœ„ë³„ ë²„íŠ¼ ìƒì„±
            const enhanceButtons = [];
            const row1 = new ActionRowBuilder();
            const row2 = new ActionRowBuilder();
            let buttonCount = 0;
            
            for (const slot of equipmentSlots) {
                if (user.equipment[slot] !== -1 && user.equipment[slot] !== null) {
                    const item = user.inventory.find(inv => inv.inventorySlot === user.equipment[slot]);
                    if (item) {
                        const button = new ButtonBuilder()
                            .setCustomId(`enhance_slot_${slot}`)
                            .setLabel(`${slotNames[slot]} (+${item.enhanceLevel || 0})`)
                            .setStyle(ButtonStyle.Primary);
                        
                        if (buttonCount < 3) {
                            row1.addComponents(button);
                        } else {
                            row2.addComponents(button);
                        }
                        buttonCount++;
                    }
                }
            }
            
            const components = [];
            if (row1.components.length > 0) components.push(row1);
            if (row2.components.length > 0) components.push(row2);
            
            const backButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('enhancement')
                        .setLabel('ğŸ”™ ê°•í™”ì†Œ ë©”ë‰´')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            components.push(backButton);
            
            await interaction.editReply({
                embeds: [enhanceEmbed],
                components: components
            });
        }
        
        // ì¥ë¹„ ë¶€ìœ„ë³„ ê°•í™” ë²„íŠ¼ ì²˜ë¦¬
        else if (interaction.customId.startsWith('enhance_slot_')) {
            // ë¨¼ì € defer ì²˜ë¦¬ - flags ì‚¬ìš©
            await interaction.deferReply({ flags: 64 });
            
            const slot = interaction.customId.replace('enhance_slot_', '');
            const user = await getUser(interaction.user.id);
            if (!user || !user.registered) {
                await interaction.editReply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', embeds: [], components: [] });
                return;
            }
            
            // í•´ë‹¹ ìŠ¬ë¡¯ì˜ ì¥ë¹„ ì°¾ê¸°
            const inventorySlot = user.equipment[slot];
            if (inventorySlot === -1 || inventorySlot === null) {
                await interaction.editReply({ content: 'í•´ë‹¹ ë¶€ìœ„ì— ì¥ì°©ëœ ì¥ë¹„ê°€ ì—†ìŠµë‹ˆë‹¤!', embeds: [], components: [] });
                return;
            }
            
            const item = user.inventory.find(inv => inv.inventorySlot === inventorySlot);
            if (!item) {
                await interaction.editReply({ content: 'ì¥ë¹„ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', embeds: [], components: [] });
                return;
            }
            
            const currentEnhance = item.enhanceLevel || 0;
            const itemLevel = ITEM_LEVELS[item.setName] || ITEM_LEVELS[item.name] || 1;
            const cost = calculateEnhanceCost(itemLevel, currentEnhance);
            const successRate = calculateSuccessRate(currentEnhance);
            
            // ê³¨ë“œ í™•ì¸
            if (user.gold < cost) {
                await interaction.editReply({ 
                    content: `âŒ ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤! (í•„ìš”: ${cost.toLocaleString()}G, ë³´ìœ : ${user.gold.toLocaleString()}G)`, 
                    embeds: [], 
                    components: [] 
                });
                return;
            }
            
            // 15ê°• ì´ìƒì€ ë³´í˜¸ê¶Œ í•„ìˆ˜
            if (currentEnhance >= 15 && user.protectionScrolls < 1) {
                await interaction.editReply({ 
                    content: `âŒ 15ê°• ì´ìƒì€ ë³´í˜¸ê¶Œì´ í•„ìš”í•©ë‹ˆë‹¤! (ë³´ìœ : ${user.protectionScrolls || 0}ê°œ)`, 
                    embeds: [], 
                    components: [] 
                });
                return;
            }
            
            const enhanceEmbed = new EmbedBuilder()
                .setColor('#ffd700')
                .setTitle(`âš”ï¸ ${item.name} ê°•í™”`)
                .setDescription(`í˜„ì¬ ê°•í™”: +${currentEnhance} â†’ +${currentEnhance + 1}`)
                .addFields(
                    { name: 'ğŸ’° ê°•í™” ë¹„ìš©', value: `${cost.toLocaleString()}G`, inline: true },
                    { name: 'ğŸ“Š ì„±ê³µë¥ ', value: `${successRate}%`, inline: true },
                    { name: 'ğŸ›¡ï¸ ë³´í˜¸ê¶Œ', value: `${user.protectionScrolls || 0}ê°œ`, inline: true },
                    { name: 'âš ï¸ ì‹¤íŒ¨ ì‹œ', value: currentEnhance >= 20 ? 'íŒŒê´´' : currentEnhance >= 15 ? '-1 ê°•í™”' : currentEnhance >= 10 ? '-1 ê°•í™”' : 'ë³€í™” ì—†ìŒ', inline: true }
                );
            
            const confirmButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId(`confirm_enhance_${slot}`)
                        .setLabel('âœ… ê°•í™” ì§„í–‰')
                        .setStyle(ButtonStyle.Success),
                    new ButtonBuilder()
                        .setCustomId('enhance')
                        .setLabel('âŒ ì·¨ì†Œ')
                        .setStyle(ButtonStyle.Danger)
                );
            
            if (currentEnhance >= 10 && currentEnhance < 15 && user.protectionScrolls > 0) {
                confirmButtons.addComponents(
                    new ButtonBuilder()
                        .setCustomId(`confirm_enhance_protect_${slot}`)
                        .setLabel('ğŸ›¡ï¸ ë³´í˜¸ê¶Œ ì‚¬ìš© ê°•í™”')
                        .setStyle(ButtonStyle.Primary)
                );
            }
            
            await interaction.editReply({
                embeds: [enhanceEmbed],
                components: [confirmButtons]
            });
        }
        
        // ê°•í™” í™•ì¸ ë²„íŠ¼ ì²˜ë¦¬
        else if (interaction.customId.startsWith('confirm_enhance_')) {
            const parts = interaction.customId.split('_');
            const useProtection = parts[2] === 'protect';
            const slot = useProtection ? parts[3] : parts[2];
            
            await interaction.deferUpdate();
            
            const user = await getUser(interaction.user.id);
            const inventorySlot = user.equipment[slot];
            const item = user.inventory.find(inv => inv.inventorySlot === inventorySlot);
            
            if (!item) {
                await interaction.editReply({ content: 'ì¥ë¹„ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', embeds: [], components: [] });
                return;
            }
            
            const currentEnhance = item.enhanceLevel || 0;
            const itemLevel = ITEM_LEVELS[item.setName] || ITEM_LEVELS[item.name] || 1;
            const cost = calculateEnhanceCost(itemLevel, currentEnhance);
            const successRate = calculateSuccessRate(currentEnhance);
            
            // ê³¨ë“œ ì°¨ê°
            user.gold -= cost;
            
            // ë³´í˜¸ê¶Œ ì‚¬ìš©
            if (useProtection || currentEnhance >= 15) {
                user.protectionScrolls -= 1;
            }
            
            // ê°•í™” í†µê³„ ì—…ë°ì´íŠ¸
            if (!user.enhanceStats) {
                user.enhanceStats = { totalAttempts: 0, totalCost: 0, destroyCount: 0, successCount: 0, maxEnhanceLevel: 0 };
            }
            user.enhanceStats.totalAttempts += 1;
            user.enhanceStats.totalCost += cost;
            
            // ê°•í™” ì‹œë„
            const rates = ENHANCEMENT_RATES[currentEnhance];
            const random = Math.random() * 100;
            const success = random < rates.success;
            
            let resultEmbed;
            
            if (success) {
                // ê°•í™” ì„±ê³µ
                item.enhanceLevel = currentEnhance + 1;
                user.enhanceStats.successCount += 1;
                if (item.enhanceLevel > user.enhanceStats.maxEnhanceLevel) {
                    user.enhanceStats.maxEnhanceLevel = item.enhanceLevel;
                }
                
                // ìŠ¤íƒ¯ ì¦ê°€
                const statIncrease = Math.floor(itemLevel * 2);
                item.stats.attack += statIncrease;
                item.stats.defense += statIncrease;
                
                resultEmbed = new EmbedBuilder()
                    .setColor('#00ff00')
                    .setTitle('âœ… ê°•í™” ì„±ê³µ!')
                    .setDescription(`**${item.name}**ì´(ê°€) **+${currentEnhance}**ì—ì„œ **+${item.enhanceLevel}**ë¡œ ê°•í™”ë˜ì—ˆìŠµë‹ˆë‹¤!`)
                    .addFields(
                        { name: 'ğŸ“ˆ ìŠ¤íƒ¯ ì¦ê°€', value: `ê³µê²©ë ¥ +${statIncrease}, ë°©ì–´ë ¥ +${statIncrease}`, inline: true },
                        { name: 'ğŸ’° ì†Œëª¨ ê³¨ë“œ', value: `${cost.toLocaleString()}G`, inline: true },
                        { name: 'ğŸ’° ë‚¨ì€ ê³¨ë“œ', value: `${user.gold.toLocaleString()}G`, inline: true }
                    );
            } else {
                // ê°•í™” ì‹¤íŒ¨ ë˜ëŠ” íŒŒê´´ í™•ì¸
                const isDestroy = random >= (100 - rates.destroy) && currentEnhance >= 15 && !useProtection;
                
                if (isDestroy) {
                    // íŒŒê´´
                    user.inventory = user.inventory.filter(inv => inv.inventorySlot !== inventorySlot);
                    user.equipment[slot] = -1;
                    user.enhanceStats.destroyCount += 1;
                    
                    resultEmbed = new EmbedBuilder()
                        .setColor('#ff0000')
                        .setTitle('ğŸ’¥ ì¥ë¹„ íŒŒê´´!')
                        .setDescription(`**${item.name}**ì´(ê°€) íŒŒê´´ë˜ì—ˆìŠµë‹ˆë‹¤...`)
                        .addFields(
                            { name: 'ğŸ’° ì†Œëª¨ ê³¨ë“œ', value: `${cost.toLocaleString()}G`, inline: true },
                            { name: 'ğŸ’° ë‚¨ì€ ê³¨ë“œ', value: `${user.gold.toLocaleString()}G`, inline: true }
                        );
                } else if (currentEnhance >= 10 && !useProtection) {
                    // ê°•í™” ë ˆë²¨ í•˜ë½
                    item.enhanceLevel = Math.max(0, currentEnhance - 1);
                    const statDecrease = Math.floor(itemLevel * 2);
                    item.stats.attack = Math.max(0, item.stats.attack - statDecrease);
                    item.stats.defense = Math.max(0, item.stats.defense - statDecrease);
                    
                    resultEmbed = new EmbedBuilder()
                        .setColor('#ff6600')
                        .setTitle('âŒ ê°•í™” ì‹¤íŒ¨!')
                        .setDescription(`**${item.name}**ì˜ ê°•í™”ê°€ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.\nê°•í™” ë ˆë²¨: +${currentEnhance} â†’ +${item.enhanceLevel}`)
                        .addFields(
                            { name: 'ğŸ“‰ ìŠ¤íƒ¯ ê°ì†Œ', value: `ê³µê²©ë ¥ -${statDecrease}, ë°©ì–´ë ¥ -${statDecrease}`, inline: true },
                            { name: 'ğŸ’° ì†Œëª¨ ê³¨ë“œ', value: `${cost.toLocaleString()}G`, inline: true },
                            { name: 'ğŸ’° ë‚¨ì€ ê³¨ë“œ', value: `${user.gold.toLocaleString()}G`, inline: true }
                        );
                } else {
                    // ë³€í™” ì—†ìŒ
                    resultEmbed = new EmbedBuilder()
                        .setColor('#ffff00')
                        .setTitle('âŒ ê°•í™” ì‹¤íŒ¨!')
                        .setDescription(`**${item.name}**ì˜ ê°•í™”ê°€ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.\nê°•í™” ë ˆë²¨ì€ ìœ ì§€ë©ë‹ˆë‹¤.`)
                        .addFields(
                            { name: 'ğŸ’° ì†Œëª¨ ê³¨ë“œ', value: `${cost.toLocaleString()}G`, inline: true },
                            { name: 'ğŸ’° ë‚¨ì€ ê³¨ë“œ', value: `${user.gold.toLocaleString()}G`, inline: true }
                        );
                }
            }
            
            await user.save();
            
            const backButton = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('enhance')
                        .setLabel('ğŸ”„ ê³„ì† ê°•í™”í•˜ê¸°')
                        .setStyle(ButtonStyle.Primary),
                    new ButtonBuilder()
                        .setCustomId('enhancement')
                        .setLabel('ğŸ”™ ê°•í™”ì†Œ ë©”ë‰´')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            await interaction.editReply({
                embeds: [resultEmbed],
                components: [backButton]
            });
        }
        
        // ì¸ë²¤í† ë¦¬ ì•„ì´í…œ ì‚¬ìš© ë²„íŠ¼ ì²˜ë¦¬
//         else if (interaction.customId.startsWith('inv_use_')) {
//             const parts = interaction.customId.split('_');
//             const itemId = parts[2];
//             const timestamp = parts[3];
//             const category = parts[5];
//             const page = parseInt(parts[6]);
//             
//             const user = await getUser(interaction.user.id);
//             const item = user.inventory.find(inv => inv.id === itemId);
//             
//             if (!item) {
//                 await interaction.reply({ content: 'í•´ë‹¹ ì•„ì´í…œì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
//                 return;
//             }
//             
//             // ì¥ë¹„ ì•„ì´í…œì¸ ê²½ìš° ì¥ì°©
//             if (['weapon', 'armor', 'helmet', 'gloves', 'boots', 'accessory'].includes(item.type)) {
//                 // í˜„ì¬ ì¥ì°©ëœ ì•„ì´í…œ í•´ì œ
//                 const currentEquipped = user.equipment[item.type];
//                 if (currentEquipped !== -1 && currentEquipped !== null) {
//                     const oldItem = user.inventory.find(inv => inv.inventorySlot === currentEquipped);
//                     if (oldItem) {
//                         oldItem.equipped = false;
//                     }
//                 }
//                 
//                 // ìƒˆ ì•„ì´í…œ ì¥ì°©
//                 user.equipment[item.type] = item.inventorySlot;
//                 item.equipped = true;
//                 
//                 await user.save();
//                 
//                 await interaction.reply({
//                     content: `âœ… **${item.name}**ì„(ë¥¼) ì¥ì°©í–ˆìŠµë‹ˆë‹¤!`,
//                     flags: 64
//                 });
//                 
//                 // ì¸ë²¤í† ë¦¬ í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨
//                 setTimeout(async () => {
//                     const categoryItems = user.inventory.filter(inv => {
//                         if (category === 'all') return true;
//                         if (category === 'equipment') return ['weapon', 'armor', 'helmet', 'gloves', 'boots', 'accessory'].includes(inv.type);
//                         if (category === 'consumable') return inv.type === 'consumable';
//                         if (category === 'etc') return inv.type === 'etc';
//                         return false;
//                     });
//                     
//                     const itemsPerPage = 5;
//                     const totalPages = Math.ceil(categoryItems.length / itemsPerPage);
//                     const startIndex = page * itemsPerPage;
//                     const currentItems = categoryItems.slice(startIndex, startIndex + itemsPerPage);
//                     
//                     const categoryEmbed = new EmbedBuilder()
//                         .setColor('#ff69b4')
//                         .setTitle(`ğŸ’ ì¸ë²¤í† ë¦¬ - ${category === 'all' ? 'ì „ì²´' : category === 'equipment' ? 'ì¥ë¹„' : category === 'consumable' ? 'ì†Œë¹„' : 'ê¸°íƒ€'}`)
//                         .setDescription(`í˜ì´ì§€ ${page + 1}/${totalPages}\n\në³´ìœ  ì•„ì´í…œ ëª©ë¡:`);
//                     
//                     let itemList = '';
//                     currentItems.forEach((item, index) => {
//                         const globalIndex = startIndex + index;
//                         const isEquipped = user.equipment[item.type] === item.inventorySlot;
//                         itemList += `**${globalIndex + 1}.** ${getRarityEmoji(item.rarity)} ${item.name}`;
//                         if (item.enhanceLevel > 0) itemList += ` (+${item.enhanceLevel}ê°•)`;
//                         if (isEquipped) itemList += ' ğŸ“Œ';
//                         itemList += `\n`;
//                         
//                         if (item.stats) {
//                             let statsText = '';
//                             for (const [statName, value] of Object.entries(item.stats)) {
//                                 if (value !== 0) {
//                                     const statDisplay = statName === 'attack' ? 'ê³µê²©ë ¥' : 
//                                                       statName === 'defense' ? 'ë°©ì–´ë ¥' : 
//                                                       statName === 'dodge' ? 'íšŒí”¼ë ¥' : 
//                                                       statName === 'luck' ? 'í–‰ìš´' : statName;
//                                     statsText += `${statDisplay}: ${value > 0 ? '+' : ''}${value} `;
//                                 }
//                             }
//                             itemList += `${statsText}\n`;
//                         }
//                         
//                         itemList += `ğŸ’° íŒë§¤ê°€: ${Math.floor(item.price * 0.7).toLocaleString()}<:currency_emoji:1377404064316522778>\n\n`;
//                     });
//                     
//                     categoryEmbed.addFields({ name: 'ë³´ìœ  ì•„ì´í…œ', value: itemList || 'ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤.', inline: false });
//                     
//                     // ì•„ì´í…œ ë²„íŠ¼ ì—…ë°ì´íŠ¸
//                     const itemButtons = new ActionRowBuilder();
//                     currentItems.forEach((item, index) => {
//                         const globalIndex = startIndex + index;
//                         const isEquipped = user.equipment[item.type] === item.inventorySlot;
//                         const isEquipment = ['weapon', 'armor', 'helmet', 'gloves', 'boots', 'accessory'].includes(item.type);
//                         
//                         itemButtons.addComponents(
//                             new ButtonBuilder()
//                                 .setCustomId(`inv_use_${item.id}_${Date.now()}_r${Math.random().toString(36).substring(7)}_${category}_${page}`)
//                                 .setLabel(`${globalIndex + 1}. ${isEquipment ? 'ì¥ì°©' : 'ì‚¬ìš©'}`)
//                                 .setStyle(isEquipped ? ButtonStyle.Success : ButtonStyle.Primary)
//                                 .setDisabled(isEquipped)
//                         );
//                     });
//                     
//                     const navButtons = new ActionRowBuilder()
//                         .addComponents(
//                             new ButtonBuilder()
//                                 .setCustomId(`inv_${category}_prev_${page}`)
//                                 .setLabel('â—€ ì´ì „')
//                                 .setStyle(ButtonStyle.Secondary)
//                                 .setDisabled(page === 0),
//                             new ButtonBuilder()
//                                 .setCustomId(`inv_${category}_page_${page}`)
//                                 .setLabel(`${page + 1}/${totalPages}`)
//                                 .setStyle(ButtonStyle.Secondary)
//                                 .setDisabled(true),
//                             new ButtonBuilder()
//                                 .setCustomId(`inv_${category}_next_${page}`)
//                                 .setLabel('ë‹¤ìŒ â–¶')
//                                 .setStyle(ButtonStyle.Secondary)
//                                 .setDisabled(page >= totalPages - 1),
//                             new ButtonBuilder()
//                                 .setCustomId('inventory')
//                                 .setLabel('ğŸ”™ ì¸ë²¤í† ë¦¬ ë©”ì¸')
//                                 .setStyle(ButtonStyle.Primary)
//                         );
//                     
//                     const components = [itemButtons];
//                     if (totalPages > 1 || categoryItems.length > 0) {
//                         components.push(navButtons);
//                     }
//                     
//                     await interaction.editReply({
//                         embeds: [categoryEmbed],
//                         components: components
//                     });
//                 }, 1000);
//             }
//             // ì†Œë¹„ ì•„ì´í…œì¸ ê²½ìš° ì‚¬ìš©
//             else if (item.type === 'consumable') {
//                 // ì†Œë¹„ ì•„ì´í…œ ì‚¬ìš© ë¡œì§
//                 item.quantity -= 1;
//                 if (item.quantity <= 0) {
//                     user.inventory = user.inventory.filter(inv => inv.id !== itemId);
//                 }
//                 
//                 await user.save();
//                 await interaction.reply({
//                     content: `âœ… **${item.name}**ì„(ë¥¼) ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤!`,
//                     flags: 64
//                 });
//             }
//         }
        
        // ê° ëŠ¥ë ¥ì¹˜ë³„ í¬ì¸íŠ¸ ì¶”ê°€ ë²„íŠ¼ ì²˜ë¦¬
        else if (interaction.customId.startsWith('add_strength_') || 
                 interaction.customId.startsWith('add_agility_') ||
                 interaction.customId.startsWith('add_intelligence_') ||
                 interaction.customId.startsWith('add_vitality_') ||
                 interaction.customId.startsWith('add_luck_')) {
            
            const parts = interaction.customId.split('_');
            const stat = parts[1];
            const amount = parseInt(parts[2]);
            
            const user = await getUser(interaction.user.id);
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            if (user.statPoints < amount) {
                await interaction.reply({ content: `í¬ì¸íŠ¸ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤! (í•„ìš”: ${amount}, ë³´ìœ : ${user.statPoints})`, flags: 64 });
                return;
            }
            
            // ëŠ¥ë ¥ì¹˜ ì¦ê°€
            user.stats[stat] += amount;
            user.statPoints -= amount;
            
            await user.save();
            
            const statName = {
                strength: 'ğŸ’ª í˜',
                agility: 'ğŸƒ ë¯¼ì²©',
                intelligence: 'ğŸ§  ì§€ëŠ¥',
                vitality: 'â¤ï¸ ì²´ë ¥',
                luck: 'ğŸ€ í–‰ìš´'
            }[stat];
            
            await interaction.reply({
                content: `âœ… ${statName}ì´(ê°€) ${amount} ì¦ê°€í–ˆìŠµë‹ˆë‹¤! (í˜„ì¬: ${user.stats[stat]})`,
                flags: 64
            });
        }
        
        // ëŠ¥ë ¥ì¹˜ í¬ì¸íŠ¸ ë²„íŠ¼ ì²˜ë¦¬ (êµ¬ë²„ì „)
        else if (interaction.customId.startsWith('stat_add_')) {
            const amount = parseInt(interaction.customId.split('_')[2]);
            
            const user = await getUser(interaction.user.id);
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            if (user.statPoints < amount) {
                await interaction.reply({ content: 'í¬ì¸íŠ¸ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            // ëŠ¥ë ¥ì¹˜ ì„ íƒ ë©”ë‰´
            const statOptions = [
                { label: 'âš”ï¸ ê³µê²©ë ¥', description: `í˜„ì¬: ${user.baseStats.attack}`, value: `add_attack_${amount}`, emoji: 'âš”ï¸' },
                { label: 'ğŸ›¡ï¸ ë°©ì–´ë ¥', description: `í˜„ì¬: ${user.baseStats.defense}`, value: `add_defense_${amount}`, emoji: 'ğŸ›¡ï¸' },
                { label: 'ğŸ’¨ íšŒí”¼ë ¥', description: `í˜„ì¬: ${user.baseStats.dodge}`, value: `add_dodge_${amount}`, emoji: 'ğŸ’¨' },
                { label: 'ğŸ€ í–‰ìš´', description: `í˜„ì¬: ${user.baseStats.luck}`, value: `add_luck_${amount}`, emoji: 'ğŸ€' }
            ];
            
            const statSelectMenu = new StringSelectMenuBuilder()
                .setCustomId('stat_select')
                .setPlaceholder(`${amount} í¬ì¸íŠ¸ë¥¼ íˆ¬ìí•  ëŠ¥ë ¥ì¹˜ë¥¼ ì„ íƒí•˜ì„¸ìš”`)
                .addOptions(statOptions);
            
            const selectRow = new ActionRowBuilder().addComponents(statSelectMenu);
            
            const statEmbed = new EmbedBuilder()
                .setColor('#00b894')
                .setTitle(`ğŸ“Š ëŠ¥ë ¥ì¹˜ í¬ì¸íŠ¸ ${amount} íˆ¬ì`)
                .setDescription('ì–´ë–¤ ëŠ¥ë ¥ì¹˜ë¥¼ ì˜¬ë¦¬ì‹œê² ìŠµë‹ˆê¹Œ?')
                .addFields(
                    { name: 'ğŸ’° ë‚¨ì€ í¬ì¸íŠ¸', value: `${user.statPoints} â†’ ${user.statPoints - amount}`, inline: false }
                );
            
            await interaction.reply({
                embeds: [statEmbed],
                components: [selectRow],
                flags: 64
            });
        }
        
        // ëŠ¥ë ¥ì¹˜ ì„ íƒ ì²˜ë¦¬
        else if (interaction.customId === 'stat_select') {
            const [action, stat, amount] = interaction.values[0].split('_');
            const points = parseInt(amount);
            
            const user = await getUser(interaction.user.id);
            if (!user || user.statPoints < points) {
                await interaction.reply({ content: 'í¬ì¸íŠ¸ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            // í¬ì¸íŠ¸ ì°¨ê° ë° ëŠ¥ë ¥ì¹˜ ì¦ê°€
            user.statPoints -= points;
            user.baseStats[stat] += points;
            
            await user.save();
            
            const statNames = {
                'attack': 'ê³µê²©ë ¥',
                'defense': 'ë°©ì–´ë ¥',
                'dodge': 'íšŒí”¼ë ¥',
                'luck': 'í–‰ìš´'
            };
            
            await interaction.update({
                content: `âœ… **${statNames[stat]}**ì´ ${points} ì¦ê°€í–ˆìŠµë‹ˆë‹¤!\ní˜„ì¬ ${statNames[stat]}: ${user.baseStats[stat]}`,
                embeds: [],
                components: []
            });
        }
        
        // ìŠ¤íƒ¯ ì´ˆê¸°í™” ë²„íŠ¼ ì²˜ë¦¬
        else if (interaction.customId === 'stat_reset') {
            const user = await getUser(interaction.user.id);
            if (!user || !user.registered) {
                await interaction.reply({ content: 'ë¨¼ì € íšŒì›ê°€ì…ì„ í•´ì£¼ì„¸ìš”!', flags: 64 });
                return;
            }
            
            const resetCost = user.level * 1000; // ë ˆë²¨ë‹¹ 1000ê³¨ë“œ
            
            if (user.gold < resetCost) {
                await interaction.reply({ content: `ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤! í•„ìš” ê³¨ë“œ: ${resetCost.toLocaleString()}G`, flags: 64 });
                return;
            }
            
            // í™•ì¸ ë²„íŠ¼
            const confirmEmbed = new EmbedBuilder()
                .setColor('#e74c3c')
                .setTitle('ğŸ”„ ìŠ¤íƒ¯ ì´ˆê¸°í™”')
                .setDescription('ì •ë§ë¡œ ëª¨ë“  ëŠ¥ë ¥ì¹˜ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')
                .addFields(
                    { name: 'ğŸ’° ë¹„ìš©', value: `${resetCost.toLocaleString()}G`, inline: true },
                    { name: 'ğŸ’µ í˜„ì¬ ê³¨ë“œ', value: `${user.gold.toLocaleString()}G`, inline: true },
                    { name: 'âš ï¸ ê²½ê³ ', value: 'ëª¨ë“  ëŠ¥ë ¥ì¹˜ê°€ ê¸°ë³¸ê°’ìœ¼ë¡œ ì´ˆê¸°í™”ë˜ê³ \ní¬ì¸íŠ¸ê°€ í™˜ê¸‰ë©ë‹ˆë‹¤!', inline: false }
                );
            
            const confirmButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId('confirm_stat_reset')
                        .setLabel('âœ… í™•ì¸')
                        .setStyle(ButtonStyle.Danger),
                    new ButtonBuilder()
                        .setCustomId('cancel_stat_reset')
                        .setLabel('âŒ ì·¨ì†Œ')
                        .setStyle(ButtonStyle.Secondary)
                );
            
            await interaction.reply({
                embeds: [confirmEmbed],
                components: [confirmButtons],
                flags: 64
            });
        }
        
        // ìŠ¤íƒ¯ ì´ˆê¸°í™” í™•ì¸
        else if (interaction.customId === 'confirm_stat_reset') {
            const user = await getUser(interaction.user.id);
            const resetCost = user.level * 1000;
            
            if (user.gold < resetCost) {
                await interaction.update({ content: 'ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!', embeds: [], components: [] });
                return;
            }
            
            // íˆ¬ìí•œ í¬ì¸íŠ¸ ê³„ì‚°
            const totalInvested = (user.baseStats.attack - 10) + (user.baseStats.defense - 10) + 
                                 (user.baseStats.dodge - 5) + (user.baseStats.luck - 5);
            
            // ì´ˆê¸°í™”
            user.gold -= resetCost;
            user.baseStats = {
                attack: 10,
                defense: 10,
                dodge: 5,
                luck: 5
            };
            user.statPoints += totalInvested;
            
            await user.save();
            
            await interaction.update({
                content: `âœ… ìŠ¤íƒ¯ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤!\ní™˜ê¸‰ëœ í¬ì¸íŠ¸: ${totalInvested}`,
                embeds: [],
                components: []
            });
        }
        
        // ìŠ¤íƒ¯ ì´ˆê¸°í™” ì·¨ì†Œ
        else if (interaction.customId === 'cancel_stat_reset') {
            await interaction.update({ content: 'ìŠ¤íƒ¯ ì´ˆê¸°í™”ë¥¼ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.', embeds: [], components: [] });
        }
        
        // ìƒì  í˜ì´ì§€ ë„¤ë¹„ê²Œì´ì…˜
        else if (interaction.customId.startsWith('shop_page_')) {
            const parts = interaction.customId.split('_');
            const category = parts[2];
            const action = parts[3]; // prev ë˜ëŠ” next
            
            if (action === 'info') return; // í˜ì´ì§€ ì •ë³´ ë²„íŠ¼ì€ ë¬´ì‹œ
            
            const categoryData = SHOP_CATEGORIES[category];
            if (!categoryData) {
                await interaction.reply({ content: 'âŒ ì¹´í…Œê³ ë¦¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', flags: 64 });
                return;
            }
            
            // í˜„ì¬ í˜ì´ì§€ ê³„ì‚°
            const itemsPerPage = 5;
            const totalPages = Math.ceil(categoryData.items.length / itemsPerPage);
            
            // í˜„ì¬ ì»´í¬ë„ŒíŠ¸ì—ì„œ í˜ì´ì§€ ì •ë³´ ì¶”ì¶œ
            const currentPageButton = interaction.message.components[1].components.find(c => c.customId.includes('_info'));
            const pageInfo = currentPageButton.label.split('/');
            let currentPage = parseInt(pageInfo[0]) - 1;
            
            // í˜ì´ì§€ ë³€ê²½
            if (action === 'prev' && currentPage > 0) {
                currentPage--;
            } else if (action === 'next' && currentPage < totalPages - 1) {
                currentPage++;
            }
            
            // ìƒˆë¡œìš´ í˜ì´ì§€ì˜ ì•„ì´í…œ ëª©ë¡
            const startIndex = currentPage * itemsPerPage;
            const endIndex = Math.min(startIndex + itemsPerPage, categoryData.items.length);
            const currentItems = categoryData.items.slice(startIndex, endIndex);
            
            // ì•„ì´í…œ ì˜µì…˜ ìƒì„±
            const itemOptions = currentItems.map((item, index) => ({
                label: `${item.name} - ${item.price.toLocaleString()}G`,
                description: `${item.rarity} | ${item.description.substring(0, 50)}...`,
                value: `buy_${category}_${startIndex + index}`,
                emoji: getRarityEmoji(item.rarity)
            }));
            
            const itemSelectMenu = new StringSelectMenuBuilder()
                .setCustomId('shop_item_select')
                .setPlaceholder('ğŸ›ï¸ êµ¬ë§¤í•  ì•„ì´í…œì„ ì„ íƒí•˜ì„¸ìš”')
                .addOptions(itemOptions);
            
            const selectRow = new ActionRowBuilder().addComponents(itemSelectMenu);
            
            // í˜ì´ì§€ë„¤ì´ì…˜ ë²„íŠ¼ ì—…ë°ì´íŠ¸
            const navButtons = new ActionRowBuilder()
                .addComponents(
                    new ButtonBuilder()
                        .setCustomId(`shop_page_${category}_prev`)
                        .setLabel('â—€ ì´ì „')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(currentPage === 0),
                    new ButtonBuilder()
                        .setCustomId(`shop_page_${category}_info`)
                        .setLabel(`${currentPage + 1}/${totalPages}`)
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(true),
                    new ButtonBuilder()
                        .setCustomId(`shop_page_${category}_next`)
                        .setLabel('ë‹¤ìŒ â–¶')
                        .setStyle(ButtonStyle.Secondary)
                        .setDisabled(currentPage >= totalPages - 1),
                    new ButtonBuilder()
                        .setCustomId('shop')
                        .setLabel('ğŸ”™ ì¹´í…Œê³ ë¦¬ ì„ íƒ')
                        .setStyle(ButtonStyle.Primary)
                );
            
            const user = await getUser(interaction.user.id);
            
            const categoryEmbed = new EmbedBuilder()
                .setColor('#00ff7f')
                .setTitle(`${categoryData.emoji} ${categoryData.name} ìƒì `)
                .setDescription(`ğŸ’° ë³´ìœ  ê³¨ë“œ: ${user.gold.toLocaleString()}G\n\nêµ¬ë§¤í•  ì•„ì´í…œì„ ì„ íƒí•˜ì„¸ìš”!`)
                .setThumbnail(`attachment://${categoryData.gif}`)
                .setFooter({ text: `í˜ì´ì§€ ${currentPage + 1}/${totalPages}` });
            
            const categoryAttachment = new AttachmentBuilder(
                path.join(__dirname, 'resource', categoryData.gif), 
                { name: categoryData.gif }
            );
            
            await interaction.update({
                embeds: [categoryEmbed],
                components: [selectRow, navButtons],
                files: [categoryAttachment]
            });
        }

    } catch (error) {
        console.error('ì¸í„°ë ‰ì…˜ ì²˜ë¦¬ ì˜¤ë¥˜:', error);
        
        // ì¸í„°ë™ì…˜ ì‘ë‹µ ì²˜ë¦¬
        try {
            if (!interaction.replied && !interaction.deferred) {
                await interaction.reply({ content: 'ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”!', flags: 64 });
            } else if (interaction.deferred) {
                await interaction.editReply({ content: 'ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”!' });
            }
        } catch (e) {
            console.error('ì˜¤ë¥˜ ì‘ë‹µ ì‹¤íŒ¨:', e);
        }
    }
});

// ì¤‘ë³µ ì œê±°ë¨ - ê¸°ì¡´ spawnBoss, startBossBattle, handleBossDefeat í•¨ìˆ˜ëŠ” ì´ë¯¸ ìœ„ì— ì •ì˜ë˜ì–´ ìˆìŒ
    
    await channel.send({ embeds: [defeatEmbed] });
    
    // ë³´ìŠ¤ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    BOSS_SYSTEM.activeBoss = null;
    BOSS_SYSTEM.participants.clear();
    BOSS_SYSTEM.damageDealt.clear();
}

// ë´‡ ë¡œê·¸ì¸
client.login(TOKEN); 
